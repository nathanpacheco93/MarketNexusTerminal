{"file_contents":{"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport yfinance as yf\n\n# Import modules\nfrom modules import market_data, charts, portfolio, news, screener, economic_calendar, earnings_calendar, utils, options, backtesting, risk_management, bonds, alerts, profile_manager, futures_overview\nfrom modules.user_auth import user_auth\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Bloomberg Terminal\",\n    page_icon=\"üìà\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Custom CSS for Bloomberg-style appearance\nst.markdown(\"\"\"\n<style>\n    .main-header {\n        font-size: 2.5rem;\n        font-weight: bold;\n        color: #FF6B35;\n        text-align: center;\n        margin-bottom: 2rem;\n    }\n    .metric-container {\n        background-color: #262730;\n        padding: 1rem;\n        border-radius: 0.5rem;\n        margin: 0.5rem 0;\n    }\n    .positive {\n        color: #00FF00;\n    }\n    .negative {\n        color: #FF0000;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# Initialize user authentication\nuser_auth.initialize_session()\n\n# Main title\nst.markdown('<h1 class=\"main-header\">üèõÔ∏è BLOOMBERG TERMINAL</h1>', unsafe_allow_html=True)\n\n# Check if user is logged in\nif not user_auth.is_logged_in():\n    # Show login form if not logged in\n    user_auth.display_login_form()\n    st.stop()\n\n# User is logged in - show main application\n# Sidebar navigation\nst.sidebar.title(\"Navigation\")\n\n# Display user menu in sidebar\nuser_auth.display_user_menu()\n\npage = st.sidebar.selectbox(\n    \"Select Module\",\n    [\"Market Overview\", \"Futures Overview\", \"Interactive Charts\", \"Options Chain\", \"Strategy Backtesting\", \"Risk Management\", \"Bond Market\", \"Alerts & Notifications\", \"Portfolio Management\", \n     \"Market Screener\", \"Economic Calendar\", \"Earnings Calendar\", \"Financial News\", \"Watchlist\", \"Profile Management\"]\n)\n\n# Initialize session state for portfolio and watchlist (will be loaded from database)\nif 'portfolio' not in st.session_state:\n    st.session_state.portfolio = []\nif 'watchlist' not in st.session_state:\n    st.session_state.watchlist = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'NVDA', 'AMZN']\n\n# Load user data if not already loaded\nif not st.session_state.get('user_data_loaded'):\n    user_auth.load_user_data()\n    st.session_state.user_data_loaded = True\n\n# Main content area\nif page == \"Market Overview\":\n    st.header(\"üìä Market Overview\")\n    \n    # Major indices\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.subheader(\"S&P 500\")\n        sp500_data = market_data.get_index_data(\"^GSPC\")\n        if sp500_data:\n            st.metric(\n                label=\"S&P 500\",\n                value=f\"${sp500_data['price']:.2f}\",\n                delta=f\"{sp500_data['change']:.2f} ({sp500_data['change_percent']:.2f}%)\"\n            )\n    \n    with col2:\n        st.subheader(\"NASDAQ\")\n        nasdaq_data = market_data.get_index_data(\"^IXIC\")\n        if nasdaq_data:\n            st.metric(\n                label=\"NASDAQ\",\n                value=f\"${nasdaq_data['price']:.2f}\",\n                delta=f\"{nasdaq_data['change']:.2f} ({nasdaq_data['change_percent']:.2f}%)\"\n            )\n    \n    with col3:\n        st.subheader(\"DOW JONES\")\n        dow_data = market_data.get_index_data(\"^DJI\")\n        if dow_data:\n            st.metric(\n                label=\"DOW\",\n                value=f\"${dow_data['price']:.2f}\",\n                delta=f\"{dow_data['change']:.2f} ({dow_data['change_percent']:.2f}%)\"\n            )\n    \n    # Currency and commodities section\n    st.header(\"üí± Currencies & Commodities\")\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        eur_usd = market_data.get_currency_data(\"EURUSD=X\")\n        if eur_usd:\n            st.metric(\"EUR/USD\", f\"{eur_usd['price']:.4f}\", f\"{eur_usd['change']:.4f}\")\n    \n    with col2:\n        gbp_usd = market_data.get_currency_data(\"GBPUSD=X\")\n        if gbp_usd:\n            st.metric(\"GBP/USD\", f\"{gbp_usd['price']:.4f}\", f\"{gbp_usd['change']:.4f}\")\n    \n    with col3:\n        gold = market_data.get_commodity_data(\"GC=F\")\n        if gold:\n            st.metric(\"Gold\", f\"${gold['price']:.2f}\", f\"{gold['change']:.2f}\")\n    \n    with col4:\n        oil = market_data.get_commodity_data(\"CL=F\")\n        if oil:\n            st.metric(\"Crude Oil\", f\"${oil['price']:.2f}\", f\"{oil['change']:.2f}\")\n    \n    # Crypto section\n    st.header(\"‚Çø Cryptocurrency\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        btc = market_data.get_crypto_data(\"BTC-USD\")\n        if btc:\n            st.metric(\"Bitcoin\", f\"${btc['price']:.2f}\", f\"{btc['change']:.2f}\")\n    \n    with col2:\n        eth = market_data.get_crypto_data(\"ETH-USD\")\n        if eth:\n            st.metric(\"Ethereum\", f\"${eth['price']:.2f}\", f\"{eth['change']:.2f}\")\n    \n    with col3:\n        ada = market_data.get_crypto_data(\"ADA-USD\")\n        if ada:\n            st.metric(\"Cardano\", f\"${ada['price']:.4f}\", f\"{ada['change']:.4f}\")\n\nelif page == \"Futures Overview\":\n    futures_overview.display_futures_overview()\n\nelif page == \"Interactive Charts\":\n    st.header(\"üìà Interactive Charts\")\n    charts.display_charts()\n\nelif page == \"Options Chain\":\n    st.header(\"üìä Options Chain & Derivatives\")\n    options.display_options()\n\nelif page == \"Strategy Backtesting\":\n    st.header(\"üîÑ Strategy Backtesting\")\n    backtesting.display_backtesting()\n\nelif page == \"Risk Management\":\n    st.header(\"‚ö†Ô∏è Risk Management\")\n    risk_management.display_risk_management()\n\nelif page == \"Bond Market\":\n    st.header(\"üè¶ Bond Market\")\n    bonds.display_bonds()\n\nelif page == \"Alerts & Notifications\":\n    st.header(\"üö® Alerts & Notifications\")\n    alerts.display_alerts()\n\nelif page == \"Portfolio Management\":\n    st.header(\"üíº Portfolio Management\")\n    portfolio.display_portfolio()\n\nelif page == \"Market Screener\":\n    st.header(\"üîç Market Screener\")\n    screener.display_screener()\n\nelif page == \"Economic Calendar\":\n    st.header(\"üìÖ Economic Calendar\")\n    economic_calendar.display_calendar()\n\nelif page == \"Earnings Calendar\":\n    earnings_calendar.display_earnings_calendar()\n\nelif page == \"Financial News\":\n    st.header(\"üì∞ Financial News\")\n    news.display_news()\n\nelif page == \"Watchlist\":\n    st.header(\"üëÅÔ∏è Market Watchlist\")\n    \n    # Add new symbol to watchlist\n    col1, col2 = st.columns([3, 1])\n    with col1:\n        new_symbol = st.text_input(\"Add Symbol to Watchlist\", placeholder=\"e.g., AAPL\")\n    with col2:\n        if st.button(\"Add Symbol\"):\n            if new_symbol and new_symbol.upper() not in st.session_state.watchlist:\n                st.session_state.watchlist.append(new_symbol.upper())\n                # Auto-save to database\n                user_auth.auto_save_watchlist_symbol(new_symbol.upper(), 'add')\n                st.success(f\"Added {new_symbol.upper()} to watchlist\")\n                st.rerun()\n    \n    # Display watchlist\n    if st.session_state.watchlist:\n        watchlist_data = []\n        for symbol in st.session_state.watchlist:\n            try:\n                ticker = yf.Ticker(symbol)\n                info = ticker.info\n                hist = ticker.history(period=\"2d\")\n                \n                if not hist.empty and len(hist) >= 2:\n                    current_price = hist['Close'].iloc[-1]\n                    prev_price = hist['Close'].iloc[-2]\n                    change = current_price - prev_price\n                    change_percent = (change / prev_price) * 100\n                    \n                    watchlist_data.append({\n                        'Symbol': symbol,\n                        'Company': info.get('longName', symbol),\n                        'Price': f\"${current_price:.2f}\",\n                        'Change': f\"${change:.2f}\",\n                        'Change %': f\"{change_percent:.2f}%\",\n                        'Volume': f\"{info.get('volume', 0):,}\" if info.get('volume') else \"N/A\",\n                        'Market Cap': f\"${info.get('marketCap', 0)/1e9:.2f}B\" if info.get('marketCap') else \"N/A\"\n                    })\n            except Exception as e:\n                st.error(f\"Error fetching data for {symbol}: {str(e)}\")\n        \n        if watchlist_data:\n            df = pd.DataFrame(watchlist_data)\n            \n            # Remove symbol button\n            col1, col2 = st.columns([4, 1])\n            with col1:\n                st.dataframe(df, use_container_width=True)\n            with col2:\n                st.write(\"Remove:\")\n                for symbol in st.session_state.watchlist:\n                    if st.button(f\"‚ùå {symbol}\", key=f\"remove_{symbol}\"):\n                        st.session_state.watchlist.remove(symbol)\n                        # Auto-save to database\n                        user_auth.auto_save_watchlist_symbol(symbol, 'remove')\n                        st.success(f\"Removed {symbol} from watchlist\")\n                        st.rerun()\n    else:\n        st.info(\"Your watchlist is empty. Add some symbols to get started!\")\n\nelif page == \"Profile Management\":\n    profile_manager.display_profile_management()\n\n# Auto-save current state periodically\nuser_auth.save_current_state()\n\n# Footer\nst.markdown(\"---\")\nst.markdown(\"*Data provided by Yahoo Finance. For educational purposes only.*\")\n","size_bytes":9294},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"beautifulsoup4>=4.13.5\",\n    \"feedparser>=6.0.12\",\n    \"modules>=1.0.0\",\n    \"nltk>=3.9.1\",\n    \"numpy>=2.3.3\",\n    \"pandas>=2.3.2\",\n    \"plotly>=6.3.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"requests>=2.32.5\",\n    \"scipy>=1.16.2\",\n    \"streamlit>=1.49.1\",\n    \"textblob>=0.19.0\",\n    \"yfinance>=0.2.66\",\n]\n","size_bytes":488},"replit.md":{"content":"# Bloomberg Terminal Clone\n\n## Overview\n\nThis is a comprehensive financial data terminal application built with Streamlit that replicates core Bloomberg Terminal functionality. The application provides real-time market data, interactive charts, options pricing, portfolio management, risk analytics, and various financial tools for traders and analysts.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: Streamlit web application framework\n- **Layout**: Wide layout with expandable sidebar navigation\n- **Styling**: Custom CSS for Bloomberg-inspired dark theme with metric containers\n- **Visualization**: Plotly for interactive charts and financial data visualization\n- **Navigation**: Tab-based interface within modules for organized feature access\n\n### Application Structure\n- **Modular Design**: Each major feature is separated into dedicated modules in the `/modules` directory\n- **Main Application**: `app.py` serves as the entry point with navigation and page routing\n- **Module System**: Eleven specialized modules handle different financial functions:\n  - Market data and overview\n  - Interactive charting\n  - Options chain and derivatives\n  - Strategy backtesting\n  - Risk management and portfolio analytics\n  - Bond market analysis\n  - Alert and notification system\n  - Portfolio management\n  - Market screening\n  - Financial news aggregation\n  - Economic calendar\n\n### Data Management\n- **Data Source**: Yahoo Finance (yfinance) as primary data provider\n- **Caching Strategy**: Streamlit's `@st.cache_data` with 60-second TTL for real-time data\n- **User Profile System**: Comprehensive PostgreSQL database for persistent user data storage\n- **Session State**: Used for maintaining portfolio data, alerts, and user preferences across page refreshes\n- **Data Processing**: Pandas for data manipulation and NumPy for financial calculations\n- **Auto-Save**: Automatic persistence of user data across all modules\n\n### Financial Analytics Engine\n- **Options Pricing**: Black-Scholes model implementation using SciPy\n- **Risk Calculations**: VaR, volatility, correlation analysis, and portfolio optimization\n- **Technical Analysis**: Moving averages, RSI, MACD, Bollinger Bands\n- **Backtesting Framework**: Historical strategy testing with performance metrics\n- **Bond Analytics**: Yield curve analysis and fixed income calculations\n\n### Real-time Features\n- **Market Data**: Live price feeds for stocks, indices, currencies, and commodities\n- **Alert System**: Price-based and technical indicator alerts with notification management\n- **Auto-refresh**: Configurable automatic data updates for market monitoring\n- **User Profile System**: Real-time auto-save of user preferences, portfolio, alerts, and watchlists\n\n### User Profile & Persistence System\n- **User Authentication**: Simple username-based identification system\n- **Database Schema**: PostgreSQL tables for users, portfolios, alerts, watchlists, and preferences\n- **Auto-Save Functionality**: Seamless persistence across all modules:\n  - Portfolio holdings and transactions\n  - Active alerts and alert history\n  - Watchlist symbols and favorites\n  - Chart preferences and indicator settings\n  - Personal user settings and configurations\n- **Profile Management**: Comprehensive interface for data overview, export, and management\n- **Data Integrity**: Robust CRUD operations with error handling and validation\n\n## External Dependencies\n\n### Data Providers\n- **Yahoo Finance API**: Primary source for stock prices, options data, and market information via `yfinance` library\n- **RSS Feeds**: Financial news from Yahoo Finance, MarketWatch, Reuters, Bloomberg, and Financial Times\n- **Economic Calendar**: Simulated economic events (designed for future integration with real APIs)\n\n### Python Libraries\n- **Core Framework**: `streamlit` for web application interface\n- **Data Processing**: `pandas` for data manipulation, `numpy` for numerical computations\n- **Visualization**: `plotly` for interactive charts and financial plots\n- **Financial Calculations**: `scipy` for optimization and statistical functions\n- **Web Requests**: `requests` for API calls and data fetching\n- **Feed Parsing**: `feedparser` for RSS news feed processing\n\n### Mathematical Models\n- **Options Pricing**: Black-Scholes model for derivatives valuation\n- **Risk Models**: Modern Portfolio Theory, VaR calculations, correlation analysis\n- **Technical Indicators**: Standard technical analysis formulas and momentum indicators\n- **Bond Pricing**: Fixed income analytics and yield curve interpolation\n\n### Recent Changes (September 2025)\n- **User Profile System**: Implemented comprehensive user authentication and data persistence\n- **Database Integration**: Added PostgreSQL database with 5 tables for user data management\n- **Auto-Save Functionality**: Integrated throughout all modules for seamless data persistence\n- **Profile Management**: Added dedicated interface for user data management and export\n- **Enhanced User Experience**: Personalized settings and preferences that persist across sessions\n\n### Database Architecture\n- **users**: User authentication and account information\n- **user_portfolios**: Portfolio holdings, transactions, and position tracking\n- **user_alerts**: Alert configurations, triggers, and notification history\n- **user_watchlists**: Personal symbol watchlists and favorites\n- **user_preferences**: Chart settings, indicator preferences, and custom configurations\n\n### Limitations and Considerations\n- Real-time data limited by Yahoo Finance API rate limits and availability\n- No direct Bloomberg Terminal or professional market data integration\n- Economic calendar uses simulated data pending API integration\n- User data persists in development database (production deployment may require migration)","size_bytes":5870},"modules/__init__.py":{"content":"# Bloomberg Terminal Modules Package","size_bytes":36},"modules/alerts.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom modules.user_auth import user_auth\nfrom modules.data_service import get_data_service, format_data_quality_indicator, get_data_quality_color\n\ndef display_alerts():\n    \"\"\"Display alerts and notifications system\"\"\"\n    \n    st.subheader(\"üö® Alerts & Notifications\")\n    \n    # Initialize session state for alerts\n    if 'alerts' not in st.session_state:\n        st.session_state.alerts = []\n    \n    if 'alert_history' not in st.session_state:\n        st.session_state.alert_history = []\n    \n    # Alert management tabs\n    tab1, tab2, tab3, tab4 = st.tabs([\"üîî Active Alerts\", \"‚ûï Create Alert\", \"üìà Alert Dashboard\", \"üìã Alert History\"])\n    \n    with tab1:\n        display_active_alerts()\n    \n    with tab2:\n        display_create_alert()\n    \n    with tab3:\n        display_alert_dashboard()\n    \n    with tab4:\n        display_alert_history()\n\ndef display_active_alerts():\n    \"\"\"Display currently active alerts\"\"\"\n    \n    st.markdown(\"### üéØ Active Alerts\")\n    \n    if not st.session_state.alerts:\n        st.info(\"No active alerts. Create your first alert in the 'Create Alert' tab.\")\n        return\n    \n    # Check alerts button\n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        if st.button(\"üîÑ Check All Alerts\"):\n            with st.spinner(\"Checking alerts...\"):\n                triggered_alerts = check_all_alerts()\n                if triggered_alerts:\n                    st.success(f\"Found {len(triggered_alerts)} triggered alerts!\")\n                    for alert in triggered_alerts:\n                        st.warning(f\"üö® ALERT: {alert['message']}\")\n                else:\n                    st.info(\"No alerts triggered.\")\n    \n    with col2:\n        if st.button(\"üóëÔ∏è Clear All Alerts\"):\n            st.session_state.alerts = []\n            st.success(\"All alerts cleared!\")\n            st.rerun()\n    \n    # Display alerts table\n    if st.session_state.alerts:\n        alerts_df = pd.DataFrame(st.session_state.alerts)\n        \n        # Format for display\n        display_df = alerts_df.copy()\n        if 'created_at' in display_df.columns:\n            display_df['created_at'] = pd.to_datetime(display_df['created_at']).dt.strftime('%Y-%m-%d %H:%M')\n        \n        st.dataframe(display_df, use_container_width=True)\n\ndef display_create_alert():\n    \"\"\"Display alert creation interface\"\"\"\n    \n    st.markdown(\"### ‚ûï Create New Alert\")\n    \n    # Alert type selection\n    alert_type = st.selectbox(\n        \"Alert Type\",\n        [\"Price Alert\", \"Volume Alert\", \"Technical Indicator Alert\", \"News Alert\"]\n    )\n    \n    if alert_type == \"Price Alert\":\n        create_price_alert()\n    elif alert_type == \"Volume Alert\":\n        create_volume_alert()\n    elif alert_type == \"Technical Indicator Alert\":\n        create_technical_alert()\n    elif alert_type == \"News Alert\":\n        create_news_alert()\n\ndef create_price_alert():\n    \"\"\"Create price-based alert\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol\", value='AAPL')\n        \n        condition = st.selectbox(\n            \"Condition\",\n            [\"Above\", \"Below\", \"Between\"]\n        )\n        \n        if condition in [\"Above\", \"Below\"]:\n            target_price = st.number_input(\n                f\"Target Price\",\n                value=150.0,\n                min_value=0.01,\n                step=0.01\n            )\n        else:\n            col1a, col1b = st.columns(2)\n            with col1a:\n                lower_price = st.number_input(\"Lower Price\", value=140.0, min_value=0.01, step=0.01)\n            with col1b:\n                upper_price = st.number_input(\"Upper Price\", value=160.0, min_value=0.01, step=0.01)\n    \n    with col2:\n        alert_name = st.text_input(\"Alert Name\", value=f\"{symbol} Price Alert\")\n        \n        notification_method = st.multiselect(\n            \"Notification Method\",\n            [\"Browser Notification\", \"Email\", \"SMS\"],\n            default=[\"Browser Notification\"]\n        )\n    \n    # Get current price for reference using real-time data service\n    try:\n        data_service = get_data_service()\n        quote_data = data_service.get_stock_quote(symbol)\n        if quote_data and quote_data.get('price'):\n            current_price = quote_data['price']\n            data_quality = quote_data.get('data_quality', 'unknown')\n            quality_indicator = format_data_quality_indicator(data_quality, quote_data.get('cache_age', 0))\n            \n            st.info(f\"Current price of {symbol}: ${current_price:.2f} | {quality_indicator}\")\n            \n            # Show data source and freshness\n            col1, col2 = st.columns(2)\n            with col1:\n                st.caption(f\"Source: {quote_data.get('source', 'unknown')}\")\n            with col2:\n                if quote_data.get('timestamp'):\n                    try:\n                        timestamp = datetime.fromisoformat(quote_data['timestamp'].replace('Z', '+00:00'))\n                        st.caption(f\"Updated: {timestamp.strftime('%H:%M:%S')}\")\n                    except:\n                        st.caption(\"Updated: Recent\")\n        else:\n            st.warning(\"Could not fetch current price - using fallback data\")\n    except Exception as e:\n        st.warning(f\"Could not fetch current price: {str(e)}\")\n    \n    if st.button(\"üîî Create Alert\"):\n        # Create alert dictionary\n        alert = {\n            'id': len(st.session_state.alerts),\n            'alert_type': 'Price Alert',\n            'symbol': symbol.upper(),\n            'condition': condition,\n            'alert_name': alert_name,\n            'notification_method': notification_method,\n            'created_at': datetime.now().isoformat(),\n            'status': 'Active',\n            'triggered_count': 0\n        }\n        \n        # Add price parameters based on condition\n        if condition in [\"Above\", \"Below\"]:\n            alert['target_price'] = target_price\n        else:\n            alert['lower_price'] = lower_price\n            alert['upper_price'] = upper_price\n        \n        # Auto-save to database\n        if user_auth.auto_save_alert(alert):\n            st.session_state.alerts.append(alert)\n            st.success(\"Alert created and saved successfully!\")\n            st.rerun()\n        else:\n            st.error(\"Failed to save alert to database\")\n\ndef create_volume_alert():\n    \"\"\"Create volume-based alert\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol\", value='AAPL')\n        volume_multiplier = st.number_input(\"Volume Multiplier (x average)\", value=2.0, min_value=0.1, step=0.1)\n    \n    with col2:\n        alert_name = st.text_input(\"Alert Name\", value=f\"{symbol} Volume Alert\")\n        notification_method = st.multiselect(\n            \"Notification Method\",\n            [\"Browser Notification\", \"Email\", \"SMS\"],\n            default=[\"Browser Notification\"]\n        )\n    \n    if st.button(\"üîî Create Volume Alert\"):\n        alert = {\n            'id': len(st.session_state.alerts),\n            'alert_type': 'Volume Alert',\n            'symbol': symbol.upper(),\n            'volume_multiplier': volume_multiplier,\n            'alert_name': alert_name,\n            'notification_method': notification_method,\n            'created_at': datetime.now().isoformat(),\n            'status': 'Active',\n            'triggered_count': 0\n        }\n        \n        st.session_state.alerts.append(alert)\n        st.success(\"Volume alert created successfully!\")\n        st.rerun()\n\ndef create_technical_alert():\n    \"\"\"Create technical indicator alert\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol\", value='AAPL')\n        indicator = st.selectbox(\"Technical Indicator\", [\"RSI\", \"MACD\", \"Moving Average Crossover\"])\n    \n    with col2:\n        alert_name = st.text_input(\"Alert Name\", value=f\"{symbol} {indicator} Alert\")\n        notification_method = st.multiselect(\n            \"Notification Method\",\n            [\"Browser Notification\", \"Email\", \"SMS\"],\n            default=[\"Browser Notification\"]\n        )\n    \n    if st.button(\"üîî Create Technical Alert\"):\n        alert = {\n            'id': len(st.session_state.alerts),\n            'alert_type': 'Technical Indicator Alert',\n            'symbol': symbol.upper(),\n            'indicator': indicator,\n            'alert_name': alert_name,\n            'notification_method': notification_method,\n            'created_at': datetime.now().isoformat(),\n            'status': 'Active',\n            'triggered_count': 0\n        }\n        \n        st.session_state.alerts.append(alert)\n        st.success(\"Technical indicator alert created successfully!\")\n        st.rerun()\n\ndef create_news_alert():\n    \"\"\"Create news-based alert\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol (optional)\", value='', help=\"Leave empty for general market news\")\n        keywords = st.text_input(\"Keywords (comma-separated)\", value='earnings, acquisition, merger')\n    \n    with col2:\n        alert_name = st.text_input(\"Alert Name\", value=f\"News Alert - {symbol or 'Market'}\")\n        notification_method = st.multiselect(\n            \"Notification Method\",\n            [\"Browser Notification\", \"Email\", \"SMS\"],\n            default=[\"Browser Notification\"]\n        )\n    \n    if st.button(\"üîî Create News Alert\"):\n        alert = {\n            'id': len(st.session_state.alerts),\n            'alert_type': 'News Alert',\n            'symbol': symbol.upper() if symbol else '',\n            'keywords': keywords,\n            'alert_name': alert_name,\n            'notification_method': notification_method,\n            'created_at': datetime.now().isoformat(),\n            'status': 'Active',\n            'triggered_count': 0\n        }\n        \n        st.session_state.alerts.append(alert)\n        st.success(\"News alert created successfully!\")\n        st.rerun()\n\ndef display_alert_dashboard():\n    \"\"\"Display alert dashboard with analytics\"\"\"\n    \n    st.markdown(\"### üìä Alert Dashboard\")\n    \n    if not st.session_state.alerts:\n        st.info(\"No alerts to display in dashboard.\")\n        return\n    \n    # Alert statistics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    total_alerts = len(st.session_state.alerts)\n    active_alerts = len([a for a in st.session_state.alerts if a.get('status') == 'Active'])\n    total_triggered = sum(a.get('triggered_count', 0) for a in st.session_state.alerts)\n    alert_types = len(set(a['alert_type'] for a in st.session_state.alerts))\n    \n    with col1:\n        st.metric(\"Total Alerts\", total_alerts)\n    \n    with col2:\n        st.metric(\"Active Alerts\", active_alerts)\n    \n    with col3:\n        st.metric(\"Total Triggered\", total_triggered)\n    \n    with col4:\n        st.metric(\"Alert Types\", alert_types)\n    \n    # Alert types distribution\n    alert_type_counts = pd.Series([a['alert_type'] for a in st.session_state.alerts]).value_counts()\n    \n    fig_types = px.pie(\n        values=alert_type_counts.values,\n        names=alert_type_counts.index,\n        title=\"Alert Types Distribution\"\n    )\n    \n    fig_types.update_layout(template=\"plotly_dark\", height=400)\n    st.plotly_chart(fig_types, use_container_width=True)\n    \n    # Most watched symbols\n    symbols = [a.get('symbol', 'N/A') for a in st.session_state.alerts if a.get('symbol')]\n    if symbols:\n        symbol_counts = pd.Series(symbols).value_counts().head(10)\n        \n        st.markdown(\"**Most Watched Symbols:**\")\n        \n        fig_symbols = px.bar(\n            x=symbol_counts.values,\n            y=symbol_counts.index,\n            orientation='h',\n            title=\"Top 10 Most Watched Symbols\"\n        )\n        \n        fig_symbols.update_layout(template=\"plotly_dark\", height=400)\n        st.plotly_chart(fig_symbols, use_container_width=True)\n\ndef display_alert_history():\n    \"\"\"Display alert history and triggered alerts\"\"\"\n    \n    st.markdown(\"### üìã Alert History\")\n    \n    if not st.session_state.alert_history:\n        st.info(\"No alert history available.\")\n        return\n    \n    # Display history\n    history_df = pd.DataFrame(st.session_state.alert_history)\n    history_df['triggered_at'] = pd.to_datetime(history_df['triggered_at']).dt.strftime('%Y-%m-%d %H:%M:%S')\n    \n    st.dataframe(history_df, use_container_width=True)\n    \n    # Clear history button\n    if st.button(\"üóëÔ∏è Clear Alert History\"):\n        st.session_state.alert_history = []\n        st.success(\"Alert history cleared!\")\n        st.rerun()\n\ndef check_all_alerts():\n    \"\"\"Check all active alerts and return triggered ones\"\"\"\n    \n    triggered_alerts = []\n    \n    for i, alert in enumerate(st.session_state.alerts):\n        if alert.get('status') != 'Active':\n            continue\n        \n        triggered = False\n        message = \"\"\n        \n        try:\n            if alert['alert_type'] == 'Price Alert':\n                triggered, message = check_price_alert(alert)\n            elif alert['alert_type'] == 'Volume Alert':\n                triggered, message = check_volume_alert(alert)\n            elif alert['alert_type'] == 'Technical Indicator Alert':\n                triggered, message = check_technical_alert(alert)\n            elif alert['alert_type'] == 'News Alert':\n                triggered, message = check_news_alert(alert)\n            \n            if triggered:\n                # Update alert\n                st.session_state.alerts[i]['triggered_count'] = alert.get('triggered_count', 0) + 1\n                st.session_state.alerts[i]['last_triggered'] = datetime.now().isoformat()\n                \n                # Add to history\n                history_entry = alert.copy()\n                history_entry['triggered_at'] = datetime.now().isoformat()\n                history_entry['message'] = message\n                st.session_state.alert_history.append(history_entry)\n                \n                # Add to triggered list\n                triggered_alerts.append({\n                    'alert': alert,\n                    'message': message\n                })\n        \n        except Exception as e:\n            continue  # Skip alerts that fail to check\n    \n    return triggered_alerts\n\ndef check_price_alert(alert):\n    \"\"\"Check if price alert should trigger using real-time data\"\"\"\n    \n    try:\n        symbol = alert['symbol']\n        data_service = get_data_service()\n        quote_data = data_service.get_stock_quote(symbol, force_refresh=True)  # Force refresh for alerts\n        \n        if not quote_data or not quote_data.get('price'):\n            return False, \"Could not fetch current price\"\n        \n        current_price = quote_data['price']\n        data_quality = quote_data.get('data_quality', 'unknown')\n        condition = alert['condition']\n        \n        # Add data quality to alert message for transparency\n        quality_suffix = f\" [{format_data_quality_indicator(data_quality, quote_data.get('cache_age', 0))}]\"\n        \n        if condition == \"Above\":\n            target_price = alert['target_price']\n            if current_price > target_price:\n                return True, f\"{symbol} is above ${target_price:.2f} (Current: ${current_price:.2f}){quality_suffix}\"\n        \n        elif condition == \"Below\":\n            target_price = alert['target_price']\n            if current_price < target_price:\n                return True, f\"{symbol} is below ${target_price:.2f} (Current: ${current_price:.2f}){quality_suffix}\"\n        \n        elif condition == \"Between\":\n            lower_price = alert['lower_price']\n            upper_price = alert['upper_price']\n            if lower_price <= current_price <= upper_price:\n                return True, f\"{symbol} is between ${lower_price:.2f} and ${upper_price:.2f} (Current: ${current_price:.2f}){quality_suffix}\"\n        \n        return False, \"\"\n        \n    except Exception as e:\n        return False, f\"Error checking price alert: {str(e)}\"\n\ndef check_volume_alert(alert):\n    \"\"\"Check if volume alert should trigger using real-time data\"\"\"\n    \n    try:\n        symbol = alert['symbol']\n        data_service = get_data_service()\n        \n        # Get current quote for volume\n        quote_data = data_service.get_stock_quote(symbol, force_refresh=True)\n        if not quote_data or not quote_data.get('volume'):\n            return False, \"Could not fetch current volume data\"\n        \n        current_volume = quote_data['volume']\n        \n        # Get historical data to calculate average volume\n        hist_data = data_service.get_historical_data(symbol, period=\"5d\")\n        if hist_data is None or hist_data.empty:\n            return False, \"Could not fetch historical volume data for comparison\"\n        \n        avg_volume = hist_data['Volume'].mean()\n        multiplier = alert.get('volume_multiplier', 2.0)\n        \n        if current_volume > avg_volume * multiplier:\n            quality_indicator = format_data_quality_indicator(\n                quote_data.get('data_quality', 'unknown'), \n                quote_data.get('cache_age', 0)\n            )\n            return True, f\"{symbol} volume is {multiplier}x above average (Current: {current_volume:,.0f}, Avg: {avg_volume:,.0f}) [{quality_indicator}]\"\n        \n        return False, \"\"\n        \n    except Exception as e:\n        return False, f\"Error checking volume alert: {str(e)}\"\n\ndef check_technical_alert(alert):\n    \"\"\"Check if technical indicator alert should trigger\"\"\"\n    \n    # Simplified check for demo purposes\n    if np.random.random() > 0.98:  # 2% chance for demo\n        symbol = alert.get('symbol', 'UNKNOWN')\n        indicator = alert.get('indicator', 'UNKNOWN')\n        return True, f\"{symbol} {indicator} indicator triggered\"\n    \n    return False, \"\"\n\ndef check_news_alert(alert):\n    \"\"\"Check if news alert should trigger\"\"\"\n    \n    # Simplified check for demo purposes\n    if np.random.random() > 0.99:  # 1% chance for demo\n        symbol = alert.get('symbol', 'Market')\n        keywords = alert.get('keywords', 'news')\n        return True, f\"News alert triggered for {symbol}: {keywords.split(',')[0].strip()}\"\n    \n    return False, \"\"","size_bytes":18418},"modules/backtesting.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom datetime import datetime, timedelta\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef display_backtesting():\n    \"\"\"Display backtesting framework for trading strategies\"\"\"\n    \n    st.subheader(\"üîÑ Strategy Backtesting Framework\")\n    \n    # Strategy selection and configuration\n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        st.markdown(\"**üéØ Strategy Configuration**\")\n        \n        strategy_type = st.selectbox(\n            \"Select Strategy Type\",\n            [\"Simple Moving Average Crossover\", \"RSI Mean Reversion\", \"Bollinger Bands Bounce\", \n             \"MACD Signal\", \"Buy and Hold\", \"Custom Strategy\"]\n        )\n        \n        symbol = st.text_input(\"Stock Symbol\", value=\"AAPL\", placeholder=\"e.g., AAPL, TSLA, SPY\")\n        \n        col1a, col1b = st.columns(2)\n        with col1a:\n            start_date = st.date_input(\"Start Date\", value=datetime.now() - timedelta(days=365*2))\n        with col1b:\n            end_date = st.date_input(\"End Date\", value=datetime.now())\n        \n        initial_capital = st.number_input(\"Initial Capital ($)\", value=10000, min_value=1000, step=1000)\n        \n    with col2:\n        st.markdown(\"**‚öôÔ∏è Strategy Parameters**\")\n        \n        if strategy_type == \"Simple Moving Average Crossover\":\n            short_window = st.number_input(\"Short MA Period\", value=20, min_value=5, max_value=200)\n            long_window = st.number_input(\"Long MA Period\", value=50, min_value=10, max_value=300)\n            if short_window >= long_window:\n                st.warning(\"Short MA period should be less than Long MA period\")\n        \n        elif strategy_type == \"RSI Mean Reversion\":\n            rsi_period = st.number_input(\"RSI Period\", value=14, min_value=5, max_value=50)\n            rsi_oversold = st.number_input(\"Oversold Threshold\", value=30, min_value=10, max_value=40)\n            rsi_overbought = st.number_input(\"Overbought Threshold\", value=70, min_value=60, max_value=90)\n        \n        elif strategy_type == \"Bollinger Bands Bounce\":\n            bb_period = st.number_input(\"Bollinger Bands Period\", value=20, min_value=10, max_value=50)\n            bb_std = st.number_input(\"Standard Deviations\", value=2.0, min_value=1.0, max_value=3.0, step=0.1)\n        \n        elif strategy_type == \"MACD Signal\":\n            macd_fast = st.number_input(\"MACD Fast Period\", value=12, min_value=5, max_value=30)\n            macd_slow = st.number_input(\"MACD Slow Period\", value=26, min_value=20, max_value=50)\n            macd_signal = st.number_input(\"MACD Signal Period\", value=9, min_value=5, max_value=20)\n        \n        # Risk management parameters\n        st.markdown(\"**‚ö†Ô∏è Risk Management**\")\n        stop_loss = st.number_input(\"Stop Loss (%)\", value=5.0, min_value=0.0, max_value=20.0, step=0.5) / 100\n        take_profit = st.number_input(\"Take Profit (%)\", value=10.0, min_value=0.0, max_value=50.0, step=0.5) / 100\n        max_position_size = st.number_input(\"Max Position Size (%)\", value=100, min_value=10, max_value=100, step=5) / 100\n    \n    # Run backtest button\n    if st.button(\"üöÄ Run Backtest\", type=\"primary\"):\n        if symbol and start_date < end_date:\n            with st.spinner(f\"Running backtest for {strategy_type} on {symbol}...\"):\n                results = run_backtest(\n                    symbol, start_date, end_date, strategy_type, initial_capital,\n                    {\n                        'short_window': locals().get('short_window', 20),\n                        'long_window': locals().get('long_window', 50),\n                        'rsi_period': locals().get('rsi_period', 14),\n                        'rsi_oversold': locals().get('rsi_oversold', 30),\n                        'rsi_overbought': locals().get('rsi_overbought', 70),\n                        'bb_period': locals().get('bb_period', 20),\n                        'bb_std': locals().get('bb_std', 2.0),\n                        'macd_fast': locals().get('macd_fast', 12),\n                        'macd_slow': locals().get('macd_slow', 26),\n                        'macd_signal': locals().get('macd_signal', 9),\n                        'stop_loss': stop_loss,\n                        'take_profit': take_profit,\n                        'max_position_size': max_position_size\n                    }\n                )\n                \n                if results is not None:\n                    display_backtest_results(results)\n                else:\n                    st.error(\"Failed to run backtest. Please check the symbol and try again.\")\n        else:\n            st.error(\"Please enter a valid symbol and ensure start date is before end date.\")\n\ndef run_backtest(symbol, start_date, end_date, strategy_type, initial_capital, params):\n    \"\"\"Run backtest for specified strategy\"\"\"\n    \n    try:\n        # Fetch data\n        ticker = yf.Ticker(symbol)\n        data = ticker.history(start=start_date, end=end_date)\n        \n        if data.empty:\n            return None\n        \n        # Calculate strategy signals\n        if strategy_type == \"Simple Moving Average Crossover\":\n            signals = calculate_ma_crossover_signals(data, params['short_window'], params['long_window'])\n        elif strategy_type == \"RSI Mean Reversion\":\n            signals = calculate_rsi_signals(data, params['rsi_period'], params['rsi_oversold'], params['rsi_overbought'])\n        elif strategy_type == \"Bollinger Bands Bounce\":\n            signals = calculate_bb_signals(data, params['bb_period'], params['bb_std'])\n        elif strategy_type == \"MACD Signal\":\n            signals = calculate_macd_signals(data, params['macd_fast'], params['macd_slow'], params['macd_signal'])\n        elif strategy_type == \"Buy and Hold\":\n            signals = calculate_buy_hold_signals(data)\n        else:\n            signals = calculate_buy_hold_signals(data)  # Default\n        \n        # Add signals to data\n        data = data.join(signals)\n        \n        # Calculate positions and returns\n        portfolio = calculate_portfolio_performance(\n            data, initial_capital, params['stop_loss'], params['take_profit'], params['max_position_size']\n        )\n        \n        # Calculate metrics\n        metrics = calculate_performance_metrics(portfolio, data)\n        \n        return {\n            'symbol': symbol,\n            'strategy': strategy_type,\n            'data': data,\n            'portfolio': portfolio,\n            'metrics': metrics,\n            'params': params,\n            'initial_capital': initial_capital\n        }\n        \n    except Exception as e:\n        st.error(f\"Error running backtest: {str(e)}\")\n        return None\n\ndef calculate_ma_crossover_signals(data, short_window, long_window):\n    \"\"\"Calculate moving average crossover signals\"\"\"\n    \n    signals = pd.DataFrame(index=data.index)\n    \n    # Calculate moving averages\n    signals['short_ma'] = data['Close'].rolling(window=short_window).mean()\n    signals['long_ma'] = data['Close'].rolling(window=long_window).mean()\n    \n    # Generate signals\n    signals['signal'] = 0\n    signals['signal'][short_window:] = np.where(\n        signals['short_ma'][short_window:] > signals['long_ma'][short_window:], 1, 0\n    )\n    \n    # Calculate positions (1 for long, 0 for no position, -1 for short)\n    signals['position'] = signals['signal'].diff()\n    \n    return signals\n\ndef calculate_rsi_signals(data, period, oversold, overbought):\n    \"\"\"Calculate RSI mean reversion signals\"\"\"\n    \n    signals = pd.DataFrame(index=data.index)\n    \n    # Calculate RSI\n    delta = data['Close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n    rs = gain / loss\n    signals['rsi'] = 100 - (100 / (1 + rs))\n    \n    # Generate signals\n    signals['signal'] = 0\n    signals.loc[signals['rsi'] < oversold, 'signal'] = 1  # Buy when oversold\n    signals.loc[signals['rsi'] > overbought, 'signal'] = -1  # Sell when overbought\n    \n    # Calculate positions\n    signals['position'] = signals['signal'].diff()\n    \n    return signals\n\ndef calculate_bb_signals(data, period, std_dev):\n    \"\"\"Calculate Bollinger Bands bounce signals\"\"\"\n    \n    signals = pd.DataFrame(index=data.index)\n    \n    # Calculate Bollinger Bands\n    signals['middle'] = data['Close'].rolling(window=period).mean()\n    signals['std'] = data['Close'].rolling(window=period).std()\n    signals['upper'] = signals['middle'] + (signals['std'] * std_dev)\n    signals['lower'] = signals['middle'] - (signals['std'] * std_dev)\n    \n    # Generate signals\n    signals['signal'] = 0\n    signals.loc[data['Close'] < signals['lower'], 'signal'] = 1  # Buy when below lower band\n    signals.loc[data['Close'] > signals['upper'], 'signal'] = -1  # Sell when above upper band\n    \n    # Calculate positions\n    signals['position'] = signals['signal'].diff()\n    \n    return signals\n\ndef calculate_macd_signals(data, fast_period, slow_period, signal_period):\n    \"\"\"Calculate MACD signals\"\"\"\n    \n    signals = pd.DataFrame(index=data.index)\n    \n    # Calculate MACD\n    ema_fast = data['Close'].ewm(span=fast_period).mean()\n    ema_slow = data['Close'].ewm(span=slow_period).mean()\n    signals['macd'] = ema_fast - ema_slow\n    signals['signal_line'] = signals['macd'].ewm(span=signal_period).mean()\n    signals['histogram'] = signals['macd'] - signals['signal_line']\n    \n    # Generate signals\n    signals['signal'] = 0\n    signals['signal'][1:] = np.where(\n        (signals['macd'][1:] > signals['signal_line'][1:]) & \n        (signals['macd'][:-1].values <= signals['signal_line'][:-1].values), 1, 0\n    )\n    signals['signal'][1:] = np.where(\n        (signals['macd'][1:] < signals['signal_line'][1:]) & \n        (signals['macd'][:-1].values >= signals['signal_line'][:-1].values), -1, signals['signal'][1:]\n    )\n    \n    # Calculate positions\n    signals['position'] = signals['signal'].diff()\n    \n    return signals\n\ndef calculate_buy_hold_signals(data):\n    \"\"\"Calculate buy and hold signals\"\"\"\n    \n    signals = pd.DataFrame(index=data.index)\n    signals['signal'] = 0  # Initialize as no signal\n    signals['position'] = 0\n    \n    # Generate buy signal on the first day\n    if len(signals) > 0:\n        signals.iloc[0, signals.columns.get_loc('signal')] = 1\n        signals.iloc[0, signals.columns.get_loc('position')] = 1\n    \n    return signals\n\ndef calculate_portfolio_performance(data, initial_capital, stop_loss, take_profit, max_position_size):\n    \"\"\"Calculate portfolio performance with risk management and proper execution timing\"\"\"\n    \n    portfolio = pd.DataFrame(index=data.index)\n    \n    # Use Adjusted Close for accurate pricing (accounts for splits/dividends)\n    if 'Adj Close' in data.columns:\n        portfolio['price'] = data['Adj Close']\n    else:\n        portfolio['price'] = data['Close']\n    \n    # Shift signals by 1 to avoid look-ahead bias (trade on next bar)\n    portfolio['signal'] = data['signal'].shift(1).fillna(0)\n    portfolio['position'] = data['position'].shift(1).fillna(0)\n    \n    # Initialize portfolio values\n    portfolio['holdings'] = 0.0\n    portfolio['cash'] = float(initial_capital)\n    portfolio['total'] = float(initial_capital)\n    portfolio['returns'] = 0.0\n    \n    # Track entry prices for stop loss/take profit and trades\n    entry_price = 0.0\n    current_position = 0\n    trade_log = []  # Track actual trades\n    \n    # Transaction costs (0.1% per trade)\n    transaction_cost = 0.001\n    \n    for i in range(1, len(portfolio)):\n        current_price = portfolio['price'].iloc[i]\n        \n        # Check for new signals\n        if portfolio['position'].iloc[i] != 0:\n            # New position signal\n            if current_position == 0:  # Not currently in position\n                position_value = portfolio['cash'].iloc[i-1] * max_position_size\n                \n                if portfolio['position'].iloc[i] > 0:  # Buy signal\n                    # Calculate shares and costs\n                    gross_cost = position_value\n                    total_cost = gross_cost * (1 + transaction_cost)\n                    \n                    if total_cost <= portfolio['cash'].iloc[i-1]:\n                        shares_to_buy = gross_cost / current_price\n                        portfolio.loc[portfolio.index[i], 'holdings'] = shares_to_buy\n                        portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i-1] - total_cost\n                        entry_price = current_price\n                        current_position = 1\n                        \n                        # Log trade\n                        trade_log.append({\n                            'date': portfolio.index[i],\n                            'action': 'BUY',\n                            'price': current_price,\n                            'shares': shares_to_buy,\n                            'value': gross_cost,\n                            'cost': total_cost - gross_cost,\n                            'reason': 'SIGNAL'\n                        })\n                    else:\n                        # Insufficient cash\n                        portfolio.loc[portfolio.index[i], 'holdings'] = portfolio['holdings'].iloc[i-1]\n                        portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i-1]\n                \n                elif portfolio['position'].iloc[i] < 0:  # Sell signal (close position)\n                    if current_position == 1:\n                        # Close long position\n                        shares = portfolio['holdings'].iloc[i-1]\n                        gross_value = shares * current_price\n                        transaction_fee = gross_value * transaction_cost\n                        net_value = gross_value - transaction_fee\n                        \n                        portfolio.loc[portfolio.index[i], 'holdings'] = 0\n                        portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i-1] + net_value\n                        \n                        # Log trade\n                        trade_log.append({\n                            'date': portfolio.index[i],\n                            'action': 'SELL',\n                            'price': current_price,\n                            'shares': shares,\n                            'value': gross_value,\n                            'cost': transaction_fee,\n                            'reason': 'SIGNAL',\n                            'pnl': net_value - (shares * entry_price * (1 + transaction_cost))\n                        })\n                        \n                        current_position = 0\n                        entry_price = 0\n                    else:\n                        # No position to close\n                        portfolio.loc[portfolio.index[i], 'holdings'] = portfolio['holdings'].iloc[i-1]\n                        portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i-1]\n        else:\n            # No new signal, carry forward positions\n            portfolio.loc[portfolio.index[i], 'holdings'] = portfolio['holdings'].iloc[i-1]\n            portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i-1]\n        \n        # Check stop loss and take profit\n        if current_position == 1 and entry_price > 0:\n            price_change = (current_price - entry_price) / entry_price\n            \n            if price_change <= -stop_loss or price_change >= take_profit:\n                # Trigger stop loss or take profit\n                shares = portfolio['holdings'].iloc[i]\n                gross_value = shares * current_price\n                transaction_fee = gross_value * transaction_cost\n                net_value = gross_value - transaction_fee\n                \n                portfolio.loc[portfolio.index[i], 'holdings'] = 0\n                portfolio.loc[portfolio.index[i], 'cash'] = portfolio['cash'].iloc[i] + net_value\n                \n                # Log trade\n                reason = 'STOP_LOSS' if price_change <= -stop_loss else 'TAKE_PROFIT'\n                trade_log.append({\n                    'date': portfolio.index[i],\n                    'action': 'SELL',\n                    'price': current_price,\n                    'shares': shares,\n                    'value': gross_value,\n                    'cost': transaction_fee,\n                    'reason': reason,\n                    'pnl': net_value - (shares * entry_price * (1 + transaction_cost))\n                })\n                \n                current_position = 0\n                entry_price = 0\n        \n        # Calculate total portfolio value\n        portfolio.loc[portfolio.index[i], 'total'] = (\n            portfolio['cash'].iloc[i] + portfolio['holdings'].iloc[i] * current_price\n        )\n        \n        # Calculate returns\n        portfolio.loc[portfolio.index[i], 'returns'] = (\n            (portfolio['total'].iloc[i] / portfolio['total'].iloc[i-1]) - 1\n        )\n    \n    # Store trade log in portfolio for analysis\n    portfolio.attrs['trade_log'] = trade_log\n    \n    return portfolio\n\ndef calculate_performance_metrics(portfolio, data):\n    \"\"\"Calculate comprehensive performance metrics\"\"\"\n    \n    # Basic returns\n    total_return = (portfolio['total'].iloc[-1] / portfolio['total'].iloc[0]) - 1\n    \n    # Annualized return\n    days = (portfolio.index[-1] - portfolio.index[0]).days\n    annualized_return = (1 + total_return) ** (365.25 / days) - 1\n    \n    # Volatility (annualized)\n    daily_returns = portfolio['returns'].dropna()\n    volatility = daily_returns.std() * np.sqrt(252) if len(daily_returns) > 1 else 0\n    \n    # Sharpe ratio (proper calculation using daily excess returns)\n    risk_free_rate = 0.05\n    daily_rf = risk_free_rate / 252  # Daily risk-free rate\n    excess_returns = daily_returns - daily_rf\n    sharpe_ratio = (excess_returns.mean() / excess_returns.std() * np.sqrt(252)) if excess_returns.std() > 0 else 0\n    \n    # Max drawdown\n    rolling_max = portfolio['total'].cummax()\n    drawdown = (portfolio['total'] - rolling_max) / rolling_max\n    max_drawdown = drawdown.min()\n    \n    # Trade-based metrics using actual trade log\n    trade_log = portfolio.attrs.get('trade_log', [])\n    \n    # Calculate actual trade statistics\n    if trade_log:\n        # Group buy/sell pairs\n        trade_pairs = []\n        buy_trades = [t for t in trade_log if t['action'] == 'BUY']\n        sell_trades = [t for t in trade_log if t['action'] == 'SELL']\n        \n        for i, sell in enumerate(sell_trades):\n            if i < len(buy_trades):\n                buy = buy_trades[i]\n                trade_pairs.append({\n                    'entry_date': buy['date'],\n                    'exit_date': sell['date'],\n                    'entry_price': buy['price'],\n                    'exit_price': sell['price'],\n                    'shares': buy['shares'],\n                    'pnl': sell.get('pnl', 0),\n                    'return': (sell['price'] - buy['price']) / buy['price'],\n                    'duration': (sell['date'] - buy['date']).days,\n                    'exit_reason': sell['reason']\n                })\n        \n        if trade_pairs:\n            winning_trades = sum(1 for t in trade_pairs if t['pnl'] > 0)\n            total_trades = len(trade_pairs)\n            win_rate = winning_trades / total_trades\n            \n            avg_win = np.mean([t['pnl'] for t in trade_pairs if t['pnl'] > 0]) if winning_trades > 0 else 0\n            avg_loss = np.mean([t['pnl'] for t in trade_pairs if t['pnl'] < 0]) if (total_trades - winning_trades) > 0 else 0\n            profit_factor = abs(avg_win / avg_loss) if avg_loss != 0 else 0\n            \n            avg_trade_duration = np.mean([t['duration'] for t in trade_pairs])\n        else:\n            total_trades = 0\n            win_rate = 0\n            profit_factor = 0\n            avg_trade_duration = 0\n    else:\n        total_trades = 0\n        win_rate = 0\n        profit_factor = 0\n        avg_trade_duration = 0\n    \n    # Buy and hold comparison (using adjusted close if available)\n    price_col = 'Adj Close' if 'Adj Close' in data.columns else 'Close'\n    buy_hold_return = (data[price_col].iloc[-1] / data[price_col].iloc[0]) - 1\n    buy_hold_annualized = (1 + buy_hold_return) ** (365.25 / days) - 1\n    \n    # Calmar ratio\n    calmar_ratio = annualized_return / abs(max_drawdown) if max_drawdown != 0 else 0\n    \n    # Exposure (time in market)\n    exposure = (portfolio['holdings'] > 0).sum() / len(portfolio)\n    \n    return {\n        'total_return': total_return,\n        'annualized_return': annualized_return,\n        'volatility': volatility,\n        'sharpe_ratio': sharpe_ratio,\n        'max_drawdown': max_drawdown,\n        'win_rate': win_rate,\n        'total_trades': total_trades,\n        'profit_factor': profit_factor,\n        'avg_trade_duration': avg_trade_duration,\n        'exposure': exposure,\n        'buy_hold_return': buy_hold_return,\n        'buy_hold_annualized': buy_hold_annualized,\n        'calmar_ratio': calmar_ratio,\n        'final_value': portfolio['total'].iloc[-1]\n    }\n\ndef display_backtest_results(results):\n    \"\"\"Display comprehensive backtest results\"\"\"\n    \n    st.subheader(f\"üìä Backtest Results: {results['strategy']} on {results['symbol']}\")\n    \n    # Performance metrics\n    metrics = results['metrics']\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            \"Total Return\", \n            f\"{metrics['total_return']:.2%}\",\n            f\"vs B&H: {(metrics['total_return'] - metrics['buy_hold_return']):.2%}\"\n        )\n        st.metric(\"Annualized Return\", f\"{metrics['annualized_return']:.2%}\")\n    \n    with col2:\n        st.metric(\"Sharpe Ratio\", f\"{metrics['sharpe_ratio']:.2f}\")\n        st.metric(\"Calmar Ratio\", f\"{metrics['calmar_ratio']:.2f}\")\n    \n    with col3:\n        st.metric(\"Max Drawdown\", f\"{metrics['max_drawdown']:.2%}\")\n        st.metric(\"Volatility\", f\"{metrics['volatility']:.2%}\")\n    \n    with col4:\n        st.metric(\"Win Rate\", f\"{metrics['win_rate']:.2%}\")\n        st.metric(\"Total Trades\", f\"{metrics['total_trades']}\")\n    \n    # Portfolio value chart\n    st.subheader(\"üìà Portfolio Performance\")\n    \n    fig = make_subplots(\n        rows=3, cols=1,\n        subplot_titles=('Portfolio Value vs Buy & Hold', 'Daily Returns', 'Drawdown'),\n        vertical_spacing=0.08,\n        row_heights=[0.5, 0.25, 0.25]\n    )\n    \n    # Portfolio value\n    portfolio_data = results['portfolio']\n    buy_hold_value = results['initial_capital'] * (results['data']['Close'] / results['data']['Close'].iloc[0])\n    \n    fig.add_trace(\n        go.Scatter(\n            x=portfolio_data.index,\n            y=portfolio_data['total'],\n            mode='lines',\n            name='Strategy',\n            line=dict(color='#00ff41', width=2)\n        ),\n        row=1, col=1\n    )\n    \n    fig.add_trace(\n        go.Scatter(\n            x=buy_hold_value.index,\n            y=buy_hold_value.values,\n            mode='lines',\n            name='Buy & Hold',\n            line=dict(color='#ff6b6b', width=2, dash='dash')\n        ),\n        row=1, col=1\n    )\n    \n    # Daily returns\n    fig.add_trace(\n        go.Bar(\n            x=portfolio_data.index,\n            y=portfolio_data['returns'] * 100,\n            name='Daily Returns (%)',\n            marker_color=np.where(portfolio_data['returns'] > 0, '#00ff41', '#ff6b6b'),\n            showlegend=False\n        ),\n        row=2, col=1\n    )\n    \n    # Drawdown\n    rolling_max = portfolio_data['total'].cummax()\n    drawdown = ((portfolio_data['total'] - rolling_max) / rolling_max) * 100\n    \n    fig.add_trace(\n        go.Scatter(\n            x=portfolio_data.index,\n            y=drawdown,\n            mode='lines',\n            fill='tonexty',\n            name='Drawdown (%)',\n            line=dict(color='#ff6b6b'),\n            fillcolor='rgba(255, 107, 107, 0.3)',\n            showlegend=False\n        ),\n        row=3, col=1\n    )\n    \n    fig.update_layout(\n        title=f\"Backtest Analysis: {results['strategy']}\",\n        template=\"plotly_dark\",\n        height=800,\n        showlegend=True\n    )\n    \n    fig.update_xaxes(title_text=\"Date\", row=3, col=1)\n    fig.update_yaxes(title_text=\"Portfolio Value ($)\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Returns (%)\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Drawdown (%)\", row=3, col=1)\n    \n    st.plotly_chart(fig, use_container_width=True)\n    \n    # Trade analysis\n    if 'position' in results['data'].columns:\n        trades = analyze_trades(results['portfolio'], results['data'])\n        if trades is not None and len(trades) > 0:\n            st.subheader(\"üìù Trade Analysis\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.markdown(\"**Recent Trades:**\")\n                trade_display = trades[['entry_date', 'exit_date', 'return', 'duration']].tail(10)\n                trade_display['return'] = trade_display['return'].apply(lambda x: f\"{x:.2%}\")\n                trade_display['duration'] = trade_display['duration'].apply(lambda x: f\"{x} days\")\n                st.dataframe(trade_display, use_container_width=True)\n            \n            with col2:\n                st.markdown(\"**Trade Distribution:**\")\n                \n                # Returns distribution\n                fig_dist = go.Figure()\n                fig_dist.add_trace(\n                    go.Histogram(\n                        x=trades['return'] * 100,\n                        nbinsx=20,\n                        name='Trade Returns',\n                        marker_color='#00ff41',\n                        opacity=0.7\n                    )\n                )\n                \n                fig_dist.update_layout(\n                    title=\"Trade Returns Distribution\",\n                    template=\"plotly_dark\",\n                    height=300,\n                    xaxis_title=\"Return (%)\",\n                    yaxis_title=\"Frequency\"\n                )\n                \n                st.plotly_chart(fig_dist, use_container_width=True)\n    \n    # Strategy-specific analysis\n    display_strategy_analysis(results)\n\ndef analyze_trades(portfolio, data):\n    \"\"\"Analyze individual trades using actual trade log\"\"\"\n    \n    try:\n        # Use the actual trade log from portfolio execution\n        trade_log = portfolio.attrs.get('trade_log', [])\n        \n        if not trade_log:\n            return None\n        \n        # Group buy/sell pairs\n        trades = []\n        buy_trades = [t for t in trade_log if t['action'] == 'BUY']\n        sell_trades = [t for t in trade_log if t['action'] == 'SELL']\n        \n        for i, sell in enumerate(sell_trades):\n            if i < len(buy_trades):\n                buy = buy_trades[i]\n                trades.append({\n                    'entry_date': buy['date'],\n                    'exit_date': sell['date'],\n                    'entry_price': buy['price'],\n                    'exit_price': sell['price'],\n                    'shares': buy['shares'],\n                    'pnl': sell.get('pnl', 0),\n                    'return': (sell['price'] - buy['price']) / buy['price'],\n                    'duration': (sell['date'] - buy['date']).days,\n                    'exit_reason': sell['reason']\n                })\n        \n        return pd.DataFrame(trades) if trades else None\n        \n    except Exception as e:\n        return None\n\ndef display_strategy_analysis(results):\n    \"\"\"Display strategy-specific analysis\"\"\"\n    \n    st.subheader(\"üîç Strategy Analysis\")\n    \n    strategy = results['strategy']\n    data = results['data']\n    \n    if strategy == \"Simple Moving Average Crossover\":\n        # MA analysis\n        fig = go.Figure()\n        \n        fig.add_trace(\n            go.Scatter(\n                x=data.index,\n                y=data['Close'],\n                mode='lines',\n                name='Price',\n                line=dict(color='white', width=1)\n            )\n        )\n        \n        if 'short_ma' in data.columns:\n            fig.add_trace(\n                go.Scatter(\n                    x=data.index,\n                    y=data['short_ma'],\n                    mode='lines',\n                    name=f\"Short MA ({results['params']['short_window']})\",\n                    line=dict(color='#00ff41', width=1)\n                )\n            )\n        \n        if 'long_ma' in data.columns:\n            fig.add_trace(\n                go.Scatter(\n                    x=data.index,\n                    y=data['long_ma'],\n                    mode='lines',\n                    name=f\"Long MA ({results['params']['long_window']})\",\n                    line=dict(color='#ff6b6b', width=1)\n                )\n            )\n        \n        # Add buy/sell signals\n        buy_signals = data[data['position'] > 0]\n        sell_signals = data[data['position'] < 0]\n        \n        if not buy_signals.empty:\n            fig.add_trace(\n                go.Scatter(\n                    x=buy_signals.index,\n                    y=buy_signals['Close'],\n                    mode='markers',\n                    name='Buy Signal',\n                    marker=dict(color='#00ff41', symbol='triangle-up', size=10)\n                )\n            )\n        \n        if not sell_signals.empty:\n            fig.add_trace(\n                go.Scatter(\n                    x=sell_signals.index,\n                    y=sell_signals['Close'],\n                    mode='markers',\n                    name='Sell Signal',\n                    marker=dict(color='#ff6b6b', symbol='triangle-down', size=10)\n                )\n            )\n        \n        fig.update_layout(\n            title=\"Moving Average Crossover Strategy\",\n            template=\"plotly_dark\",\n            height=400,\n            xaxis_title=\"Date\",\n            yaxis_title=\"Price ($)\"\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n    \n    elif strategy == \"RSI Mean Reversion\":\n        # RSI analysis\n        if 'rsi' in data.columns:\n            fig = make_subplots(\n                rows=2, cols=1,\n                subplot_titles=('Price & Signals', 'RSI'),\n                vertical_spacing=0.1,\n                row_heights=[0.7, 0.3]\n            )\n            \n            # Price chart\n            fig.add_trace(\n                go.Scatter(x=data.index, y=data['Close'], mode='lines', name='Price', line=dict(color='white')),\n                row=1, col=1\n            )\n            \n            # Buy/sell signals\n            buy_signals = data[data['position'] > 0]\n            sell_signals = data[data['position'] < 0]\n            \n            if not buy_signals.empty:\n                fig.add_trace(\n                    go.Scatter(\n                        x=buy_signals.index, y=buy_signals['Close'], mode='markers',\n                        name='Buy Signal', marker=dict(color='#00ff41', symbol='triangle-up', size=8)\n                    ),\n                    row=1, col=1\n                )\n            \n            if not sell_signals.empty:\n                fig.add_trace(\n                    go.Scatter(\n                        x=sell_signals.index, y=sell_signals['Close'], mode='markers',\n                        name='Sell Signal', marker=dict(color='#ff6b6b', symbol='triangle-down', size=8)\n                    ),\n                    row=1, col=1\n                )\n            \n            # RSI chart\n            fig.add_trace(\n                go.Scatter(x=data.index, y=data['rsi'], mode='lines', name='RSI', line=dict(color='orange')),\n                row=2, col=1\n            )\n            \n            # RSI levels\n            fig.add_hline(y=results['params']['rsi_overbought'], line_dash=\"dash\", line_color=\"red\", row=2, col=1)\n            fig.add_hline(y=results['params']['rsi_oversold'], line_dash=\"dash\", line_color=\"green\", row=2, col=1)\n            fig.add_hline(y=50, line_dash=\"solid\", line_color=\"gray\", row=2, col=1)\n            \n            fig.update_layout(\n                title=\"RSI Mean Reversion Strategy\",\n                template=\"plotly_dark\",\n                height=500\n            )\n            \n            fig.update_yaxes(title_text=\"Price ($)\", row=1, col=1)\n            fig.update_yaxes(title_text=\"RSI\", row=2, col=1, range=[0, 100])\n            fig.update_xaxes(title_text=\"Date\", row=2, col=1)\n            \n            st.plotly_chart(fig, use_container_width=True)\n    \n    # Parameter sensitivity analysis\n    if st.button(\"üìä Run Parameter Sensitivity Analysis\"):\n        with st.spinner(\"Running sensitivity analysis...\"):\n            sensitivity_results = run_sensitivity_analysis(results)\n            if sensitivity_results:\n                display_sensitivity_analysis(sensitivity_results)\n\ndef run_sensitivity_analysis(base_results):\n    \"\"\"Run parameter sensitivity analysis\"\"\"\n    \n    # This is a simplified version - in practice, you'd vary key parameters\n    # and show how performance changes\n    \n    strategy = base_results['strategy']\n    symbol = base_results['symbol']\n    \n    # For demonstration, we'll just show the concept\n    # In a full implementation, you'd vary parameters and re-run backtests\n    \n    return {\n        'strategy': strategy,\n        'base_sharpe': base_results['metrics']['sharpe_ratio'],\n        'base_return': base_results['metrics']['annualized_return'],\n        'parameter_ranges': {\n            'short_window': [10, 15, 20, 25, 30] if strategy == \"Simple Moving Average Crossover\" else [],\n            'long_window': [40, 45, 50, 55, 60] if strategy == \"Simple Moving Average Crossover\" else []\n        }\n    }\n\ndef display_sensitivity_analysis(sensitivity_results):\n    \"\"\"Display parameter sensitivity analysis results\"\"\"\n    \n    st.subheader(\"üéõÔ∏è Parameter Sensitivity Analysis\")\n    \n    # This would show how different parameter values affect performance\n    st.info(\"Parameter sensitivity analysis helps optimize strategy parameters by showing how performance changes with different values.\")\n    \n    # In a full implementation, this would show:\n    # - Heatmaps of parameter combinations vs performance\n    # - Optimization results\n    # - Robustness analysis\n    \n    st.markdown(\"\"\"\n    **Key Areas for Sensitivity Analysis:**\n    - **Moving Average Periods**: Test different short/long window combinations\n    - **RSI Thresholds**: Optimize oversold/overbought levels\n    - **Risk Management**: Test different stop-loss and take-profit levels\n    - **Position Sizing**: Analyze impact of different position sizes\n    \"\"\")\n    \n    # Example parameter impact (simplified)\n    if sensitivity_results['strategy'] == \"Simple Moving Average Crossover\":\n        st.markdown(f\"\"\"\n        **Current Performance:**\n        - Sharpe Ratio: {sensitivity_results['base_sharpe']:.2f}\n        - Annualized Return: {sensitivity_results['base_return']:.2%}\n        \n        **Parameter Optimization Suggestions:**\n        - Test shorter MA periods for more responsive signals\n        - Consider longer periods for trend-following in volatile markets\n        - Optimize stop-loss levels based on average true range\n        \"\"\")","size_bytes":35253},"modules/bonds.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom datetime import datetime, timedelta\nimport requests\nfrom scipy.interpolate import interp1d\nfrom scipy.optimize import fsolve\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef display_bonds():\n    \"\"\"Display bond market data and fixed income analytics\"\"\"\n    \n    st.subheader(\"üèõÔ∏è Bond Market & Fixed Income Analytics\")\n    \n    # Treasury yield curve section\n    st.markdown(\"### üìà Treasury Yield Curve\")\n    \n    col1, col2 = st.columns([3, 1])\n    \n    with col2:\n        # Yield curve controls\n        curve_date = st.date_input(\"Curve Date\", value=datetime.now().date())\n        historical_comparison = st.checkbox(\"Show Historical Comparison\")\n        \n        if historical_comparison:\n            comparison_periods = st.multiselect(\n                \"Compare with\",\n                [\"1 Month Ago\", \"3 Months Ago\", \"6 Months Ago\", \"1 Year Ago\"],\n                default=[\"3 Months Ago\", \"1 Year Ago\"]\n            )\n        \n        refresh_data = st.button(\"üîÑ Refresh Treasury Data\")\n    \n    with col1:\n        # Fetch and display yield curve\n        yield_data = fetch_treasury_yields()\n        \n        if yield_data is not None:\n            display_yield_curve(yield_data, historical_comparison, \n                               comparison_periods if historical_comparison else [])\n        else:\n            st.error(\"Unable to fetch treasury yield data\")\n    \n    # Bond analytics section\n    st.markdown(\"### üî¢ Bond Calculator & Analytics\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.markdown(\"**Bond Parameters:**\")\n        face_value = st.number_input(\"Face Value ($)\", value=1000, min_value=100, step=100)\n        coupon_rate = st.number_input(\"Coupon Rate (%)\", value=5.0, min_value=0.0, max_value=20.0, step=0.1) / 100\n        years_to_maturity = st.number_input(\"Years to Maturity\", value=10, min_value=0.1, max_value=50.0, step=0.1)\n        payment_frequency = st.selectbox(\"Payment Frequency\", [1, 2, 4, 12], index=1, \n                                       format_func=lambda x: {1: \"Annual\", 2: \"Semi-Annual\", 4: \"Quarterly\", 12: \"Monthly\"}[x])\n    \n    with col2:\n        st.markdown(\"**Market Data:**\")\n        yield_to_maturity = st.number_input(\"Yield to Maturity (%)\", value=4.5, min_value=0.0, max_value=20.0, step=0.1) / 100\n        current_price = st.number_input(\"Current Price ($)\", value=1050.0, min_value=100.0, step=1.0)\n        \n        # Calculate bond metrics\n        bond_metrics = calculate_bond_metrics(face_value, coupon_rate, years_to_maturity, \n                                            payment_frequency, yield_to_maturity, current_price)\n    \n    with col3:\n        st.markdown(\"**Calculated Metrics:**\")\n        if bond_metrics:\n            st.metric(\"Bond Price\", f\"${bond_metrics['price']:.2f}\")\n            st.metric(\"Duration\", f\"{bond_metrics['duration']:.2f} years\")\n            st.metric(\"Modified Duration\", f\"{bond_metrics['modified_duration']:.2f}\")\n            st.metric(\"Convexity\", f\"{bond_metrics['convexity']:.2f}\")\n            st.metric(\"DV01\", f\"${bond_metrics['dv01']:.2f}\")\n    \n    # Bond price sensitivity analysis\n    if bond_metrics:\n        st.markdown(\"### üìä Price Sensitivity Analysis\")\n        display_bond_sensitivity_analysis(face_value, coupon_rate, years_to_maturity, \n                                         payment_frequency, yield_to_maturity)\n    \n    # Corporate bond screener\n    st.markdown(\"### üè¢ Corporate Bond Analysis\")\n    display_corporate_bonds()\n    \n    # Fixed income portfolio analysis\n    st.markdown(\"### üíº Fixed Income Portfolio Analytics\")\n    display_portfolio_analytics()\n\ndef fetch_treasury_yields():\n    \"\"\"Fetch current treasury yield data\"\"\"\n    \n    try:\n        # Treasury yield symbols for different maturities\n        treasury_symbols = {\n            '1M': '^IRX',      # 13-week treasury\n            '3M': '^IRX',      # 3-month treasury\n            '6M': '^IRX',      # 6-month treasury  \n            '1Y': '^TNX',      # 10-year note (we'll use for 1Y approximation)\n            '2Y': '^TNX',      # 2-year note\n            '5Y': '^FVX',      # 5-year note\n            '10Y': '^TNX',     # 10-year note\n            '30Y': '^TYX'      # 30-year bond\n        }\n        \n        # Alternative: Create synthetic yield curve data for demonstration\n        # In production, you'd want to use FRED API or Bloomberg API\n        current_yields = {\n            '1M': 5.25,\n            '3M': 5.30,\n            '6M': 5.15,\n            '1Y': 4.85,\n            '2Y': 4.75,\n            '5Y': 4.65,\n            '10Y': 4.70,\n            '30Y': 4.85\n        }\n        \n        # Convert to DataFrame\n        maturities = [1/12, 3/12, 6/12, 1, 2, 5, 10, 30]  # In years\n        yields = list(current_yields.values())\n        \n        yield_data = pd.DataFrame({\n            'Maturity': maturities,\n            'Yield': yields,\n            'Maturity_Label': list(current_yields.keys())\n        })\n        \n        # Add some historical data for comparison (synthetic for demo)\n        yield_data['Yield_3M_Ago'] = [y + np.random.normal(0, 0.2) for y in yields]\n        yield_data['Yield_1Y_Ago'] = [y + np.random.normal(0, 0.5) for y in yields]\n        \n        return yield_data\n        \n    except Exception as e:\n        st.error(f\"Error fetching treasury data: {str(e)}\")\n        return None\n\ndef display_yield_curve(yield_data, show_historical, comparison_periods):\n    \"\"\"Display treasury yield curve\"\"\"\n    \n    fig = go.Figure()\n    \n    # Current yield curve\n    fig.add_trace(\n        go.Scatter(\n            x=yield_data['Maturity'],\n            y=yield_data['Yield'],\n            mode='lines+markers',\n            name='Current',\n            line=dict(color='#00ff41', width=3),\n            marker=dict(size=8)\n        )\n    )\n    \n    # Historical comparisons\n    if show_historical:\n        colors = ['#ff6b6b', '#ffa500', '#9370db']\n        \n        for i, period in enumerate(comparison_periods):\n            if period == \"3 Months Ago\" and 'Yield_3M_Ago' in yield_data.columns:\n                fig.add_trace(\n                    go.Scatter(\n                        x=yield_data['Maturity'],\n                        y=yield_data['Yield_3M_Ago'],\n                        mode='lines+markers',\n                        name='3M Ago',\n                        line=dict(color=colors[i % len(colors)], width=2, dash='dash'),\n                        marker=dict(size=6)\n                    )\n                )\n            elif period == \"1 Year Ago\" and 'Yield_1Y_Ago' in yield_data.columns:\n                fig.add_trace(\n                    go.Scatter(\n                        x=yield_data['Maturity'],\n                        y=yield_data['Yield_1Y_Ago'],\n                        mode='lines+markers',\n                        name='1Y Ago',\n                        line=dict(color=colors[(i+1) % len(colors)], width=2, dash='dot'),\n                        marker=dict(size=6)\n                    )\n                )\n    \n    # Add maturity labels\n    for _, row in yield_data.iterrows():\n        fig.add_annotation(\n            x=row['Maturity'],\n            y=row['Yield'],\n            text=row['Maturity_Label'],\n            showarrow=False,\n            yshift=15,\n            font=dict(size=10, color='white')\n        )\n    \n    fig.update_layout(\n        title=\"U.S. Treasury Yield Curve\",\n        template=\"plotly_dark\",\n        height=400,\n        xaxis_title=\"Maturity (Years)\",\n        yaxis_title=\"Yield (%)\",\n        xaxis=dict(type='log', tickmode='array', \n                  tickvals=[1/12, 3/12, 6/12, 1, 2, 5, 10, 30],\n                  ticktext=['1M', '3M', '6M', '1Y', '2Y', '5Y', '10Y', '30Y']),\n        hovermode='x unified'\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n    \n    # Yield curve analysis\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        # Curve steepness (10Y - 2Y spread)\n        steepness = yield_data[yield_data['Maturity_Label'] == '10Y']['Yield'].iloc[0] - \\\n                   yield_data[yield_data['Maturity_Label'] == '2Y']['Yield'].iloc[0]\n        st.metric(\"2Y-10Y Spread\", f\"{steepness:.2f} bps\")\n    \n    with col2:\n        # Short end (3M yield)\n        short_end = yield_data[yield_data['Maturity_Label'] == '3M']['Yield'].iloc[0]\n        st.metric(\"3M Treasury\", f\"{short_end:.2f}%\")\n    \n    with col3:\n        # Long end (30Y yield)\n        long_end = yield_data[yield_data['Maturity_Label'] == '30Y']['Yield'].iloc[0]\n        st.metric(\"30Y Treasury\", f\"{long_end:.2f}%\")\n\ndef calculate_bond_metrics(face_value, coupon_rate, years_to_maturity, payment_frequency, ytm, current_price):\n    \"\"\"Calculate comprehensive bond metrics\"\"\"\n    \n    try:\n        # Number of payments\n        n_payments = int(years_to_maturity * payment_frequency)\n        \n        # Periodic rates\n        periodic_coupon = coupon_rate / payment_frequency\n        periodic_ytm = ytm / payment_frequency\n        \n        # Cash flows\n        coupon_payment = face_value * periodic_coupon\n        \n        # Bond price calculation\n        if periodic_ytm == 0:\n            bond_price = face_value + coupon_payment * n_payments\n        else:\n            pv_coupons = coupon_payment * (1 - (1 + periodic_ytm)**(-n_payments)) / periodic_ytm\n            pv_face_value = face_value / (1 + periodic_ytm)**n_payments\n            bond_price = pv_coupons + pv_face_value\n        \n        # Duration calculation (Macaulay Duration)\n        duration = 0\n        for t in range(1, n_payments + 1):\n            if t < n_payments:\n                cash_flow = coupon_payment\n            else:\n                cash_flow = coupon_payment + face_value\n            \n            pv_cash_flow = cash_flow / (1 + periodic_ytm)**t\n            weight = pv_cash_flow / bond_price\n            duration += weight * (t / payment_frequency)\n        \n        # Modified Duration\n        modified_duration = duration / (1 + periodic_ytm)\n        \n        # Convexity calculation\n        convexity = 0\n        for t in range(1, n_payments + 1):\n            if t < n_payments:\n                cash_flow = coupon_payment\n            else:\n                cash_flow = coupon_payment + face_value\n            \n            pv_cash_flow = cash_flow / (1 + periodic_ytm)**t\n            convexity += (pv_cash_flow / bond_price) * (t * (t + 1)) / ((1 + periodic_ytm)**2 * payment_frequency**2)\n        \n        # DV01 (Dollar Value of 01)\n        dv01 = modified_duration * bond_price * 0.0001\n        \n        return {\n            'price': bond_price,\n            'duration': duration,\n            'modified_duration': modified_duration,\n            'convexity': convexity,\n            'dv01': dv01\n        }\n        \n    except Exception as e:\n        st.error(f\"Error calculating bond metrics: {str(e)}\")\n        return None\n\ndef display_bond_sensitivity_analysis(face_value, coupon_rate, years_to_maturity, payment_frequency, base_ytm):\n    \"\"\"Display bond price sensitivity to yield changes\"\"\"\n    \n    # Yield range for sensitivity analysis\n    yield_range = np.arange(max(0.001, base_ytm - 0.03), base_ytm + 0.03, 0.001)\n    \n    prices = []\n    durations = []\n    convexities = []\n    \n    for ytm in yield_range:\n        metrics = calculate_bond_metrics(face_value, coupon_rate, years_to_maturity, \n                                       payment_frequency, ytm, 0)\n        if metrics:\n            prices.append(metrics['price'])\n            durations.append(metrics['duration'])\n            convexities.append(metrics['convexity'])\n        else:\n            prices.append(None)\n            durations.append(None)\n            convexities.append(None)\n    \n    # Create sensitivity charts\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=('Price vs Yield', 'Duration vs Yield', 'Convexity vs Yield', 'Price Change Approximation'),\n        specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n               [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n    )\n    \n    # Price vs Yield\n    fig.add_trace(\n        go.Scatter(\n            x=yield_range * 100,\n            y=prices,\n            mode='lines',\n            name='Bond Price',\n            line=dict(color='#00ff41', width=2)\n        ),\n        row=1, col=1\n    )\n    \n    # Mark current yield\n    current_price = calculate_bond_metrics(face_value, coupon_rate, years_to_maturity, \n                                         payment_frequency, base_ytm, 0)['price']\n    fig.add_trace(\n        go.Scatter(\n            x=[base_ytm * 100],\n            y=[current_price],\n            mode='markers',\n            name='Current',\n            marker=dict(color='red', size=10, symbol='star')\n        ),\n        row=1, col=1\n    )\n    \n    # Duration vs Yield\n    fig.add_trace(\n        go.Scatter(\n            x=yield_range * 100,\n            y=durations,\n            mode='lines',\n            name='Duration',\n            line=dict(color='orange', width=2),\n            showlegend=False\n        ),\n        row=1, col=2\n    )\n    \n    # Convexity vs Yield\n    fig.add_trace(\n        go.Scatter(\n            x=yield_range * 100,\n            y=convexities,\n            mode='lines',\n            name='Convexity',\n            line=dict(color='purple', width=2),\n            showlegend=False\n        ),\n        row=2, col=1\n    )\n    \n    # Price change approximation (Duration + Convexity)\n    base_metrics = calculate_bond_metrics(face_value, coupon_rate, years_to_maturity, \n                                        payment_frequency, base_ytm, 0)\n    \n    yield_changes = (yield_range - base_ytm) * 100  # in basis points\n    \n    # Duration approximation\n    duration_approx = [-base_metrics['modified_duration'] * dy / 100 * current_price for dy in yield_changes]\n    \n    # Duration + Convexity approximation\n    duration_convexity_approx = [\n        -base_metrics['modified_duration'] * dy / 100 * current_price + \n        0.5 * base_metrics['convexity'] * (dy / 100)**2 * current_price\n        for dy in yield_changes\n    ]\n    \n    # Actual price changes\n    actual_changes = [p - current_price for p in prices]\n    \n    fig.add_trace(\n        go.Scatter(\n            x=yield_changes,\n            y=actual_changes,\n            mode='lines',\n            name='Actual',\n            line=dict(color='white', width=2)\n        ),\n        row=2, col=2\n    )\n    \n    fig.add_trace(\n        go.Scatter(\n            x=yield_changes,\n            y=duration_approx,\n            mode='lines',\n            name='Duration Only',\n            line=dict(color='orange', width=2, dash='dash')\n        ),\n        row=2, col=2\n    )\n    \n    fig.add_trace(\n        go.Scatter(\n            x=yield_changes,\n            y=duration_convexity_approx,\n            mode='lines',\n            name='Duration + Convexity',\n            line=dict(color='green', width=2, dash='dot')\n        ),\n        row=2, col=2\n    )\n    \n    fig.update_layout(\n        title=\"Bond Sensitivity Analysis\",\n        template=\"plotly_dark\",\n        height=600,\n        showlegend=True\n    )\n    \n    # Update axis labels\n    fig.update_xaxes(title_text=\"Yield (%)\", row=1, col=1)\n    fig.update_xaxes(title_text=\"Yield (%)\", row=1, col=2)\n    fig.update_xaxes(title_text=\"Yield (%)\", row=2, col=1)\n    fig.update_xaxes(title_text=\"Yield Change (bps)\", row=2, col=2)\n    \n    fig.update_yaxes(title_text=\"Price ($)\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Duration\", row=1, col=2)\n    fig.update_yaxes(title_text=\"Convexity\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Price Change ($)\", row=2, col=2)\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef display_corporate_bonds():\n    \"\"\"Display corporate bond analysis\"\"\"\n    \n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        st.markdown(\"**Corporate Bond Screener:**\")\n        \n        # Bond screening criteria\n        min_rating = st.selectbox(\"Minimum Rating\", [\"AAA\", \"AA\", \"A\", \"BBB\", \"BB\", \"B\"], index=2)\n        max_maturity = st.slider(\"Maximum Maturity (Years)\", 1, 30, 10)\n        min_yield = st.number_input(\"Minimum Yield (%)\", value=0.0, step=0.1)\n        max_yield = st.number_input(\"Maximum Yield (%)\", value=10.0, step=0.1)\n        \n        sectors = st.multiselect(\n            \"Sectors\",\n            [\"Financial\", \"Technology\", \"Healthcare\", \"Energy\", \"Utilities\", \"Consumer\", \"Industrial\"],\n            default=[\"Financial\", \"Technology\"]\n        )\n    \n    with col2:\n        st.markdown(\"**Sample Corporate Bonds:**\")\n        \n        # Create sample corporate bond data\n        sample_bonds = create_sample_corporate_bonds()\n        \n        if sample_bonds is not None:\n            # Filter based on criteria\n            filtered_bonds = sample_bonds[\n                (sample_bonds['Maturity_Years'] <= max_maturity) &\n                (sample_bonds['Yield'] >= min_yield) &\n                (sample_bonds['Yield'] <= max_yield)\n            ]\n            \n            if not filtered_bonds.empty:\n                st.dataframe(filtered_bonds, use_container_width=True)\n                \n                # Credit spread analysis\n                if st.button(\"üìä Analyze Credit Spreads\"):\n                    display_credit_spread_analysis(filtered_bonds)\n            else:\n                st.info(\"No bonds match the specified criteria\")\n\ndef create_sample_corporate_bonds():\n    \"\"\"Create sample corporate bond data for demonstration\"\"\"\n    \n    try:\n        bonds_data = {\n            'Issuer': ['Apple Inc', 'Microsoft Corp', 'JPMorgan Chase', 'Amazon.com Inc', 'Google Inc'],\n            'Coupon': [3.25, 2.88, 4.45, 3.15, 2.65],\n            'Maturity': ['2025-02-23', '2024-11-03', '2026-01-23', '2027-05-12', '2025-08-15'],\n            'Yield': [4.12, 3.95, 4.78, 4.32, 3.88],\n            'Rating': ['AA+', 'AAA', 'A-', 'AA', 'AA+'],\n            'Sector': ['Technology', 'Technology', 'Financial', 'Consumer', 'Technology'],\n            'Spread': [85, 68, 145, 98, 75]  # basis points over treasury\n        }\n        \n        df = pd.DataFrame(bonds_data)\n        \n        # Calculate years to maturity\n        df['Maturity'] = pd.to_datetime(df['Maturity'])\n        df['Maturity_Years'] = (df['Maturity'] - datetime.now()).dt.days / 365.25\n        \n        # Format for display\n        df['Maturity_Display'] = df['Maturity'].dt.strftime('%Y-%m-%d')\n        df['Yield_Display'] = df['Yield'].apply(lambda x: f\"{x:.2f}%\")\n        df['Spread_Display'] = df['Spread'].apply(lambda x: f\"{x} bps\")\n        \n        display_df = df[['Issuer', 'Coupon', 'Maturity_Display', 'Yield_Display', \n                        'Rating', 'Sector', 'Spread_Display']].copy()\n        display_df.columns = ['Issuer', 'Coupon %', 'Maturity', 'Yield', 'Rating', 'Sector', 'Spread']\n        \n        return df\n        \n    except Exception as e:\n        st.error(f\"Error creating bond data: {str(e)}\")\n        return None\n\ndef display_credit_spread_analysis(bonds_data):\n    \"\"\"Display credit spread analysis\"\"\"\n    \n    if bonds_data.empty:\n        return\n    \n    st.subheader(\"üí∞ Credit Spread Analysis\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        # Spread by rating\n        rating_spreads = bonds_data.groupby('Rating')['Spread'].mean().sort_values(ascending=True)\n        \n        fig_rating = px.bar(\n            x=rating_spreads.index,\n            y=rating_spreads.values,\n            title=\"Average Credit Spread by Rating\",\n            labels={'x': 'Rating', 'y': 'Spread (bps)'}\n        )\n        \n        fig_rating.update_layout(template=\"plotly_dark\", height=300)\n        st.plotly_chart(fig_rating, use_container_width=True)\n    \n    with col2:\n        # Spread by sector\n        sector_spreads = bonds_data.groupby('Sector')['Spread'].mean().sort_values(ascending=True)\n        \n        fig_sector = px.bar(\n            x=sector_spreads.index,\n            y=sector_spreads.values,\n            title=\"Average Credit Spread by Sector\",\n            labels={'x': 'Sector', 'y': 'Spread (bps)'}\n        )\n        \n        fig_sector.update_layout(template=\"plotly_dark\", height=300)\n        st.plotly_chart(fig_sector, use_container_width=True)\n    \n    # Yield vs Maturity scatter\n    fig_scatter = px.scatter(\n        bonds_data,\n        x='Maturity_Years',\n        y='Yield',\n        color='Rating',\n        size='Spread',\n        hover_data=['Issuer', 'Sector'],\n        title=\"Corporate Bond Yield vs Maturity\"\n    )\n    \n    fig_scatter.update_layout(\n        template=\"plotly_dark\",\n        height=400,\n        xaxis_title=\"Years to Maturity\",\n        yaxis_title=\"Yield (%)\"\n    )\n    \n    st.plotly_chart(fig_scatter, use_container_width=True)\n\ndef display_portfolio_analytics():\n    \"\"\"Display fixed income portfolio analytics\"\"\"\n    \n    st.markdown(\"**Fixed Income Portfolio Builder:**\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # Portfolio input\n        portfolio_input = st.text_area(\n            \"Enter Bond Portfolio (CUSIP/Name:Allocation, one per line)\",\n            value=\"US Treasury 2Y:0.3\\nApple 2025:0.2\\nMicrosoft 2024:0.2\\nJPMorgan 2026:0.3\",\n            help=\"Format: Bond_Name:Weight\"\n        )\n        \n        portfolio = parse_bond_portfolio(portfolio_input)\n        \n        if portfolio:\n            st.success(f\"Portfolio loaded: {len(portfolio)} bonds\")\n            \n            # Calculate portfolio duration and yield\n            portfolio_metrics = calculate_portfolio_duration_yield(portfolio)\n            \n            if portfolio_metrics:\n                col1a, col1b, col1c = st.columns(3)\n                \n                with col1a:\n                    st.metric(\"Portfolio Duration\", f\"{portfolio_metrics['duration']:.2f} years\")\n                \n                with col1b:\n                    st.metric(\"Portfolio Yield\", f\"{portfolio_metrics['yield']:.2f}%\")\n                \n                with col1c:\n                    st.metric(\"Convexity\", f\"{portfolio_metrics['convexity']:.2f}\")\n    \n    with col2:\n        st.markdown(\"**Portfolio Analysis:**\")\n        \n        target_duration = st.number_input(\"Target Duration\", value=5.0, min_value=0.1, max_value=30.0)\n        \n        if st.button(\"üéØ Optimize Duration\"):\n            st.info(\"Duration optimization would analyze bond weights to match target duration\")\n        \n        if st.button(\"üìä Risk Analysis\"):\n            display_portfolio_risk_analysis(portfolio if 'portfolio' in locals() else None)\n\ndef parse_bond_portfolio(portfolio_input):\n    \"\"\"Parse bond portfolio input\"\"\"\n    \n    try:\n        portfolio = {}\n        lines = portfolio_input.strip().split('\\n')\n        \n        for line in lines:\n            if ':' in line:\n                bond_name, weight = line.strip().split(':')\n                portfolio[bond_name.strip()] = float(weight.strip())\n        \n        return portfolio\n        \n    except Exception as e:\n        return None\n\ndef calculate_portfolio_duration_yield(portfolio):\n    \"\"\"Calculate portfolio-level duration and yield\"\"\"\n    \n    try:\n        # Sample bond characteristics (in practice, would fetch from database)\n        bond_data = {\n            'US Treasury 2Y': {'duration': 1.95, 'yield': 4.75, 'convexity': 3.8},\n            'Apple 2025': {'duration': 1.2, 'yield': 4.12, 'convexity': 1.5},\n            'Microsoft 2024': {'duration': 0.8, 'yield': 3.95, 'convexity': 0.7},\n            'JPMorgan 2026': {'duration': 2.8, 'yield': 4.78, 'convexity': 8.2}\n        }\n        \n        total_duration = 0\n        total_yield = 0\n        total_convexity = 0\n        \n        for bond_name, weight in portfolio.items():\n            if bond_name in bond_data:\n                bond_info = bond_data[bond_name]\n                total_duration += weight * bond_info['duration']\n                total_yield += weight * bond_info['yield']\n                total_convexity += weight * bond_info['convexity']\n        \n        return {\n            'duration': total_duration,\n            'yield': total_yield,\n            'convexity': total_convexity\n        }\n        \n    except Exception as e:\n        return None\n\ndef display_portfolio_risk_analysis(portfolio):\n    \"\"\"Display portfolio risk analysis\"\"\"\n    \n    if not portfolio:\n        st.warning(\"No portfolio data available for risk analysis\")\n        return\n    \n    st.subheader(\"‚ö†Ô∏è Portfolio Risk Analysis\")\n    \n    # Interest rate shock scenarios\n    rate_shocks = [-200, -100, -50, 0, 50, 100, 200]  # basis points\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"**Interest Rate Shock Analysis:**\")\n        \n        # Calculate portfolio impact for each shock\n        portfolio_metrics = calculate_portfolio_duration_yield(portfolio)\n        \n        if portfolio_metrics:\n            shock_results = []\n            \n            for shock in rate_shocks:\n                # Simplified calculation using duration\n                shock_decimal = shock / 10000  # Convert bps to decimal\n                price_change = -portfolio_metrics['duration'] * shock_decimal * 100  # Percentage\n                \n                shock_results.append({\n                    'Rate Shock (bps)': shock,\n                    'Portfolio Impact (%)': price_change\n                })\n            \n            shock_df = pd.DataFrame(shock_results)\n            st.dataframe(shock_df, use_container_width=True)\n            \n            # Shock visualization\n            fig_shock = px.bar(\n                shock_df,\n                x='Rate Shock (bps)',\n                y='Portfolio Impact (%)',\n                title=\"Interest Rate Shock Impact\"\n            )\n            \n            fig_shock.update_layout(template=\"plotly_dark\", height=300)\n            st.plotly_chart(fig_shock, use_container_width=True)\n    \n    with col2:\n        st.markdown(\"**Duration Contribution Analysis:**\")\n        \n        # Duration contribution by bond\n        contributions = []\n        \n        portfolio_metrics = calculate_portfolio_duration_yield(portfolio)\n        \n        bond_data = {\n            'US Treasury 2Y': {'duration': 1.95},\n            'Apple 2025': {'duration': 1.2},\n            'Microsoft 2024': {'duration': 0.8},\n            'JPMorgan 2026': {'duration': 2.8}\n        }\n        \n        for bond_name, weight in portfolio.items():\n            if bond_name in bond_data:\n                contribution = weight * bond_data[bond_name]['duration']\n                contributions.append({\n                    'Bond': bond_name,\n                    'Weight': f\"{weight:.1%}\",\n                    'Duration Contribution': f\"{contribution:.2f}\"\n                })\n        \n        if contributions:\n            contrib_df = pd.DataFrame(contributions)\n            st.dataframe(contrib_df, use_container_width=True)\n        \n        # Key risk metrics\n        if portfolio_metrics:\n            st.markdown(\"**Key Risk Metrics:**\")\n            st.metric(\"DV01 (per $1M)\", f\"${portfolio_metrics['duration'] * 100:.0f}\")\n            st.metric(\"Convexity\", f\"{portfolio_metrics['convexity']:.2f}\")\n            \n            # Estimate VaR (simplified)\n            daily_vol = 0.02  # Estimated daily yield volatility\n            var_95 = 1.645 * daily_vol * portfolio_metrics['duration'] * 100\n            st.metric(\"1-Day VaR (95%)\", f\"{var_95:.2f}%\")","size_bytes":27425},"modules/charts.py":{"content":"import streamlit as st\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nfrom modules.user_auth import user_auth\n\ndef display_charts():\n    \"\"\"Display interactive charts section\"\"\"\n    \n    # Symbol input\n    col1, col2, col3 = st.columns([2, 1, 1])\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol\", value=\"AAPL\", placeholder=\"e.g., AAPL, GOOGL, TSLA\")\n    \n    with col2:\n        default_period = user_auth.get_user_preference('charts', 'default_period', '1y')\n        period = st.selectbox(\"Time Period\", [\"1d\", \"5d\", \"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\", \"5y\"], \n                            index=[\"1d\", \"5d\", \"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\", \"5y\"].index(default_period))\n        user_auth.auto_save_preference('charts', 'default_period', period)\n    \n    with col3:\n        default_chart_type = user_auth.get_user_preference('charts', 'default_type', 'Candlestick')\n        chart_type = st.selectbox(\"Chart Type\", [\"Candlestick\", \"Line\", \"OHLC\"],\n                                index=[\"Candlestick\", \"Line\", \"OHLC\"].index(default_chart_type))\n        user_auth.auto_save_preference('charts', 'default_type', chart_type)\n    \n    if symbol:\n        try:\n            # Get stock data\n            ticker = yf.Ticker(symbol.upper())\n            data = ticker.history(period=period)\n            info = ticker.info\n            \n            if not data.empty:\n                # Display stock info\n                col1, col2, col3, col4 = st.columns(4)\n                \n                with col1:\n                    current_price = data['Close'].iloc[-1]\n                    prev_close = info.get('previousClose', data['Close'].iloc[-2] if len(data) > 1 else current_price)\n                    change = current_price - prev_close\n                    change_percent = (change / prev_close) * 100\n                    \n                    st.metric(\n                        label=f\"{symbol.upper()} - {info.get('longName', symbol.upper())}\",\n                        value=f\"${current_price:.2f}\",\n                        delta=f\"{change:.2f} ({change_percent:.2f}%)\"\n                    )\n                \n                with col2:\n                    st.metric(\"Volume\", f\"{data['Volume'].iloc[-1]:,.0f}\")\n                \n                with col3:\n                    st.metric(\"Market Cap\", f\"${info.get('marketCap', 0)/1e9:.2f}B\" if info.get('marketCap') else \"N/A\")\n                \n                with col4:\n                    st.metric(\"P/E Ratio\", f\"{info.get('trailingPE', 'N/A'):.2f}\" if info.get('trailingPE') else \"N/A\")\n                \n                # Indicator options - organized into logical groups\n                st.subheader(\"üìä Chart Options\")\n                \n                # Create three columns for indicator groups\n                trend_col, momentum_col, analysis_col = st.columns(3)\n                \n                with trend_col:\n                    st.markdown(\"**üìà Trend Indicators**\")\n                    show_ma = st.checkbox(\"Moving Averages (20, 50)\", \n                                        value=user_auth.get_user_preference('indicators', 'default_ma', True))\n                    user_auth.auto_save_preference('indicators', 'default_ma', show_ma)\n                    \n                    show_ema13 = st.checkbox(\"13 EMA\", \n                                           value=user_auth.get_user_preference('indicators', 'default_ema13', False))\n                    user_auth.auto_save_preference('indicators', 'default_ema13', show_ema13)\n                    \n                    show_bb = st.checkbox(\"Bollinger Bands\", \n                                        value=user_auth.get_user_preference('indicators', 'default_bb', False))\n                    user_auth.auto_save_preference('indicators', 'default_bb', show_bb)\n                \n                with momentum_col:\n                    st.markdown(\"**‚ö° Momentum Indicators**\")\n                    show_stoch = st.checkbox(\"Stochastic Oscillator\", \n                                           value=user_auth.get_user_preference('indicators', 'default_stoch', False))\n                    user_auth.auto_save_preference('indicators', 'default_stoch', show_stoch)\n                    \n                    show_will_r = st.checkbox(\"Williams %R\", \n                                            value=user_auth.get_user_preference('indicators', 'default_will_r', False))\n                    user_auth.auto_save_preference('indicators', 'default_will_r', show_will_r)\n                \n                with analysis_col:\n                    st.markdown(\"**üîç Analysis Tools**\")\n                    show_fib = st.checkbox(\"Fibonacci Retracement\", \n                                         value=user_auth.get_user_preference('indicators', 'default_fib', False))\n                    user_auth.auto_save_preference('indicators', 'default_fib', show_fib)\n                \n                # Create main chart with multiple subplots\n                rows = 2\n                subplot_count = 0\n                if show_stoch:\n                    subplot_count += 1\n                if show_will_r:\n                    subplot_count += 1\n                rows += subplot_count\n                \n                subplot_titles = [f'{symbol.upper()} Price Chart', 'Volume']\n                row_heights = [0.7, 0.3]\n                \n                # Adjust row heights and titles based on indicators\n                if subplot_count == 1:\n                    row_heights = [0.6, 0.2, 0.2]\n                elif subplot_count == 2:\n                    row_heights = [0.5, 0.2, 0.15, 0.15]\n                \n                if show_stoch:\n                    subplot_titles.append('Stochastic Oscillator')\n                if show_will_r:\n                    subplot_titles.append('Williams %R')\n                \n                fig = make_subplots(\n                    rows=rows, cols=1,\n                    shared_xaxes=True,\n                    vertical_spacing=0.05,\n                    subplot_titles=subplot_titles,\n                    row_heights=row_heights\n                )\n                \n                # Price chart\n                if chart_type == \"Candlestick\":\n                    fig.add_trace(\n                        go.Candlestick(\n                            x=data.index,\n                            open=data['Open'],\n                            high=data['High'],\n                            low=data['Low'],\n                            close=data['Close'],\n                            name=\"OHLC\"\n                        ),\n                        row=1, col=1\n                    )\n                elif chart_type == \"Line\":\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=data['Close'],\n                            mode='lines',\n                            name='Close Price',\n                            line=dict(color='#FF6B35', width=2)\n                        ),\n                        row=1, col=1\n                    )\n                else:  # OHLC\n                    fig.add_trace(\n                        go.Ohlc(\n                            x=data.index,\n                            open=data['Open'],\n                            high=data['High'],\n                            low=data['Low'],\n                            close=data['Close'],\n                            name=\"OHLC\"\n                        ),\n                        row=1, col=1\n                    )\n                \n                # Add moving averages\n                if show_ma and len(data) >= 20:\n                    data['MA20'] = data['Close'].rolling(window=20).mean()\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=data['MA20'],\n                            mode='lines',\n                            name='MA 20',\n                            line=dict(color='blue', width=1)\n                        ),\n                        row=1, col=1\n                    )\n                \n                if show_ma and len(data) >= 50:\n                    data['MA50'] = data['Close'].rolling(window=50).mean()\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=data['MA50'],\n                            mode='lines',\n                            name='MA 50',\n                            line=dict(color='red', width=1)\n                        ),\n                        row=1, col=1\n                    )\n                \n                # Add 13 EMA\n                if show_ema13 and len(data) >= 13:\n                    data['EMA13'] = calculate_ema_13(data['Close'])\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=data['EMA13'],\n                            mode='lines',\n                            name='EMA 13',\n                            line=dict(color='purple', width=1)\n                        ),\n                        row=1, col=1\n                    )\n                \n                # Add Bollinger Bands overlay\n                if show_bb and len(data) >= 20:\n                    bb_upper, bb_middle, bb_lower = calculate_bollinger_bands_series(data['Close'], 20, 2)\n                    \n                    # Upper band\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=bb_upper,\n                            mode='lines',\n                            name='BB Upper',\n                            line=dict(color='rgba(173,216,230,0.5)', width=1),\n                            showlegend=False\n                        ),\n                        row=1, col=1\n                    )\n                    \n                    # Lower band with fill\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=bb_lower,\n                            mode='lines',\n                            name='Bollinger Bands',\n                            line=dict(color='rgba(173,216,230,0.5)', width=1),\n                            fill='tonexty',\n                            fillcolor='rgba(173,216,230,0.1)'\n                        ),\n                        row=1, col=1\n                    )\n                    \n                    # Middle band (SMA)\n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=bb_middle,\n                            mode='lines',\n                            name='BB Middle',\n                            line=dict(color='orange', width=1, dash='dash'),\n                            showlegend=False\n                        ),\n                        row=1, col=1\n                    )\n                \n                # Add Fibonacci retracement levels overlay\n                if show_fib and len(data) >= 20:\n                    lookback = min(50, len(data))\n                    recent_data = data.tail(lookback)\n                    high_price = recent_data['High'].max()\n                    low_price = recent_data['Low'].min()\n                    fib_levels = calculate_fibonacci_levels(high_price, low_price)\n                    \n                    # Add horizontal lines for key Fibonacci levels\n                    for level_name, price in fib_levels.items():\n                        if any(fib in level_name for fib in ['23.6%', '38.2%', '50%', '61.8%']):\n                            fig.add_hline(\n                                y=price,\n                                line=dict(color='gold', width=1, dash='dot'),\n                                annotation_text=f\"{level_name}: ${price:.2f}\",\n                                annotation_position=\"right\",\n                                row=1\n                            )\n                \n                # Volume chart\n                colors = ['red' if data['Close'].iloc[i] < data['Open'].iloc[i] else 'green' \n                         for i in range(len(data))]\n                \n                fig.add_trace(\n                    go.Bar(\n                        x=data.index,\n                        y=data['Volume'],\n                        name='Volume',\n                        marker_color=colors,\n                        opacity=0.7\n                    ),\n                    row=2, col=1\n                )\n                \n                # Stochastic Oscillator chart\n                current_row = 3\n                if show_stoch and len(data) >= 14:\n                    stoch_k_series, stoch_d_series = calculate_stochastic_series(data, 14, 3)\n                    \n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=stoch_k_series,\n                            mode='lines',\n                            name='%K',\n                            line=dict(color='blue', width=2)\n                        ),\n                        row=current_row, col=1\n                    )\n                    \n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=stoch_d_series,\n                            mode='lines',\n                            name='%D',\n                            line=dict(color='red', width=2)\n                        ),\n                        row=current_row, col=1\n                    )\n                    \n                    # Add overbought/oversold lines\n                    fig.add_hline(y=80, line=dict(color='red', dash='dash'), row=current_row, col=1)\n                    fig.add_hline(y=20, line=dict(color='green', dash='dash'), row=current_row, col=1)\n                    current_row += 1\n                \n                # Williams %R chart\n                if show_will_r and len(data) >= 14:\n                    will_r_series = calculate_williams_r_series(data, 14)\n                    \n                    fig.add_trace(\n                        go.Scatter(\n                            x=data.index,\n                            y=will_r_series,\n                            mode='lines',\n                            name='Williams %R',\n                            line=dict(color='orange', width=2)\n                        ),\n                        row=current_row, col=1\n                    )\n                    \n                    # Add overbought/oversold lines for Williams %R\n                    fig.add_hline(y=-20, line=dict(color='red', dash='dash'), row=current_row, col=1)\n                    fig.add_hline(y=-80, line=dict(color='green', dash='dash'), row=current_row, col=1)\n                \n                # Update layout with dynamic height\n                height = 700 + (subplot_count * 150)  # Base height + 150px per indicator subplot\n                \n                fig.update_layout(\n                    title=f\"{symbol.upper()} - {period.upper()} Chart\",\n                    template=\"plotly_dark\",\n                    height=height,\n                    showlegend=True,\n                    xaxis_rangeslider_visible=False\n                )\n                \n                # Update y-axis labels\n                fig.update_yaxes(title_text=\"Price ($)\", row=1, col=1)\n                fig.update_yaxes(title_text=\"Volume\", row=2, col=1)\n                \n                # Set y-axis for indicator subplots\n                axis_row = 3\n                if show_stoch:\n                    fig.update_yaxes(title_text=\"Stochastic %\", row=axis_row, col=1, range=[0, 100])\n                    axis_row += 1\n                if show_will_r:\n                    fig.update_yaxes(title_text=\"Williams %R\", row=axis_row, col=1, range=[-100, 0])\n                \n                st.plotly_chart(fig, use_container_width=True)\n                \n                # MACD Chart (separate chart)\n                if len(data) >= 26:\n                    st.subheader(\"üìà MACD Analysis\")\n                    show_macd = st.checkbox(\"Show MACD Chart\", value=True)\n                    \n                    if show_macd:\n                        macd_line, macd_signal, macd_histogram = calculate_macd(data['Close'])\n                        \n                        if len(macd_line) > 0:\n                            # Create MACD subplot\n                            macd_fig = make_subplots(\n                                rows=2, cols=1,\n                                shared_xaxes=True,\n                                vertical_spacing=0.1,\n                                subplot_titles=('MACD Line & Signal', 'MACD Histogram'),\n                                row_heights=[0.7, 0.3]\n                            )\n                            \n                            # MACD Line and Signal - use proper index alignment\n                            macd_fig.add_trace(\n                                go.Scatter(\n                                    x=macd_line.index,\n                                    y=macd_line.values,\n                                    mode='lines',\n                                    name='MACD Line',\n                                    line=dict(color='blue', width=2)\n                                ),\n                                row=1, col=1\n                            )\n                            \n                            macd_fig.add_trace(\n                                go.Scatter(\n                                    x=macd_signal.index,\n                                    y=macd_signal.values,\n                                    mode='lines',\n                                    name='Signal Line',\n                                    line=dict(color='red', width=2)\n                                ),\n                                row=1, col=1\n                            )\n                            \n                            # MACD Histogram\n                            colors = ['red' if x < 0 else 'green' for x in macd_histogram.values]\n                            macd_fig.add_trace(\n                                go.Bar(\n                                    x=macd_histogram.index,\n                                    y=macd_histogram.values,\n                                    name='MACD Histogram',\n                                    marker_color=colors,\n                                    opacity=0.7\n                                ),\n                                row=2, col=1\n                            )\n                            \n                            macd_fig.update_layout(\n                                title=\"MACD Analysis\",\n                                template=\"plotly_dark\",\n                                height=400,\n                                showlegend=True\n                            )\n                            \n                            st.plotly_chart(macd_fig, use_container_width=True)\n                            \n                            # MACD interpretation\n                            current_macd = macd_line.iloc[-1] if len(macd_line) > 0 else 0\n                            current_signal = macd_signal.iloc[-1] if len(macd_signal) > 0 else 0\n                            \n                            col1, col2, col3 = st.columns(3)\n                            with col1:\n                                st.metric(\"MACD Value\", f\"{current_macd:.4f}\")\n                            with col2:\n                                st.metric(\"Signal Value\", f\"{current_signal:.4f}\")\n                            with col3:\n                                if current_macd > current_signal:\n                                    st.success(\"üìà Bullish Signal\")\n                                else:\n                                    st.warning(\"üìâ Bearish Signal\")\n                \n                # Technical indicators section\n                st.subheader(\"üîç Technical Indicators\")\n                \n                # Display indicators in two rows to accommodate Williams %R\n                col1, col2, col3, col4 = st.columns(4)\n                \n                with col1:\n                    # RSI calculation\n                    if len(data) >= 14:\n                        rsi = calculate_rsi_wilder(data['Close'], 14)\n                        st.metric(\"RSI (14)\", f\"{rsi:.2f}\")\n                        \n                        # RSI interpretation\n                        if rsi > 70:\n                            st.warning(\"‚ö†Ô∏è Overbought\")\n                        elif rsi < 30:\n                            st.success(\"üí° Oversold\")\n                        else:\n                            st.info(\"üìä Neutral\")\n                \n                with col2:\n                    # Bollinger Bands\n                    if len(data) >= 20:\n                        bb_upper_val, bb_middle_val, bb_lower_val = calculate_bollinger_bands_values(data['Close'], 20, 2)\n                        current_price = data['Close'].iloc[-1]\n                        \n                        if bb_upper_val > bb_lower_val:  # Avoid division by zero\n                            bb_position = ((current_price - bb_lower_val) / (bb_upper_val - bb_lower_val)) * 100\n                            st.metric(\"BB Position\", f\"{bb_position:.1f}%\")\n                            \n                            if bb_position > 80:\n                                st.warning(\"‚ö†Ô∏è Near upper\")\n                            elif bb_position < 20:\n                                st.success(\"üí° Near lower\")\n                            else:\n                                st.info(\"üìä Middle range\")\n                        else:\n                            st.info(\"BB: Insufficient data\")\n                \n                with col3:\n                    # Stochastic Oscillator\n                    if len(data) >= 14:\n                        stoch_k, stoch_d = calculate_stochastic(data, 14)\n                        st.metric(\"Stochastic %K\", f\"{stoch_k:.2f}\")\n                        \n                        if stoch_k > 80:\n                            st.warning(\"‚ö†Ô∏è Overbought\")\n                        elif stoch_k < 20:\n                            st.success(\"üí° Oversold\")\n                        else:\n                            st.info(\"üìä Neutral\")\n                \n                with col4:\n                    # Williams %R\n                    if len(data) >= 14:\n                        will_r = calculate_williams_r(data, 14)\n                        st.metric(\"Williams %R\", f\"{will_r:.2f}\")\n                        \n                        # Williams %R interpretation (overbought >-20, oversold <-80)\n                        if will_r > -20:\n                            st.warning(\"‚ö†Ô∏è Overbought\")\n                        elif will_r < -80:\n                            st.success(\"üí° Oversold\")\n                        else:\n                            st.info(\"üìä Neutral\")\n                \n                # Performance metrics\n                st.subheader(\"üìà Performance Metrics\")\n                \n                col1, col2, col3, col4 = st.columns(4)\n                \n                if len(data) >= 5:\n                    with col1:\n                        week_return = ((data['Close'].iloc[-1] / data['Close'].iloc[-5]) - 1) * 100\n                        st.metric(\"5-Day Return\", f\"{week_return:.2f}%\")\n                \n                if len(data) >= 22:\n                    with col2:\n                        month_return = ((data['Close'].iloc[-1] / data['Close'].iloc[-22]) - 1) * 100\n                        st.metric(\"1-Month Return\", f\"{month_return:.2f}%\")\n                \n                if len(data) >= 66:\n                    with col3:\n                        quarter_return = ((data['Close'].iloc[-1] / data['Close'].iloc[-66]) - 1) * 100\n                        st.metric(\"3-Month Return\", f\"{quarter_return:.2f}%\")\n                \n                if len(data) >= 252:\n                    with col4:\n                        year_return = ((data['Close'].iloc[-1] / data['Close'].iloc[-252]) - 1) * 100\n                        st.metric(\"1-Year Return\", f\"{year_return:.2f}%\")\n                \n            else:\n                st.error(\"No data available for this symbol. Please check the symbol and try again.\")\n                \n        except Exception as e:\n            st.error(f\"Error fetching data for {symbol}: {str(e)}\")\n\ndef calculate_rsi_wilder(prices, window=14):\n    \"\"\"Calculate RSI using Wilder's smoothing method\"\"\"\n    try:\n        delta = prices.diff()\n        gain = delta.where(delta > 0, 0)\n        loss = -delta.where(delta < 0, 0)\n        \n        # Use Wilder's smoothing (alpha = 1/window)\n        avg_gain = gain.ewm(alpha=1/window, adjust=False).mean()\n        avg_loss = loss.ewm(alpha=1/window, adjust=False).mean()\n        \n        rs = avg_gain / avg_loss.replace(0, 1)  # Avoid division by zero\n        rsi = 100 - (100 / (1 + rs))\n        \n        return rsi.iloc[-1] if not rsi.empty and not pd.isna(rsi.iloc[-1]) else 50\n    except Exception as e:\n        return 50\n\ndef calculate_bollinger_bands_series(prices, window=20, std_dev=2):\n    \"\"\"Calculate Bollinger Bands - full series\"\"\"\n    try:\n        sma = prices.rolling(window=window).mean()\n        std = prices.rolling(window=window).std()\n        upper_band = sma + (std * std_dev)\n        lower_band = sma - (std * std_dev)\n        return upper_band.fillna(method='bfill'), sma.fillna(method='bfill'), lower_band.fillna(method='bfill')\n    except Exception as e:\n        empty_series = pd.Series([0] * len(prices), index=prices.index)\n        return empty_series, empty_series, empty_series\n\ndef calculate_bollinger_bands_values(prices, window=20, std_dev=2):\n    \"\"\"Calculate Bollinger Bands - single values\"\"\"\n    try:\n        sma = prices.rolling(window=window).mean()\n        std = prices.rolling(window=window).std()\n        upper_band = sma + (std * std_dev)\n        lower_band = sma - (std * std_dev)\n        \n        upper_val = upper_band.iloc[-1] if not upper_band.empty and not pd.isna(upper_band.iloc[-1]) else 0\n        middle_val = sma.iloc[-1] if not sma.empty and not pd.isna(sma.iloc[-1]) else 0\n        lower_val = lower_band.iloc[-1] if not lower_band.empty and not pd.isna(lower_band.iloc[-1]) else 0\n        \n        return upper_val, middle_val, lower_val\n    except Exception as e:\n        return 0, 0, 0\n\ndef calculate_macd(prices, fast=12, slow=26, signal=9):\n    \"\"\"Calculate MACD (Moving Average Convergence Divergence)\"\"\"\n    try:\n        ema_fast = prices.ewm(span=fast, adjust=False).mean()\n        ema_slow = prices.ewm(span=slow, adjust=False).mean()\n        macd_line = ema_fast - ema_slow\n        signal_line = macd_line.ewm(span=signal, adjust=False).mean()\n        histogram = macd_line - signal_line\n        \n        return macd_line.dropna(), signal_line.dropna(), histogram.dropna()\n    except Exception as e:\n        # Return empty series if calculation fails\n        return pd.Series(), pd.Series(), pd.Series()\n\ndef calculate_fibonacci_levels(high, low):\n    \"\"\"Calculate Fibonacci retracement levels\"\"\"\n    diff = high - low\n    levels = {\n        '0% (High)': high,\n        '23.6%': high - 0.236 * diff,\n        '38.2%': high - 0.382 * diff,\n        '50%': high - 0.5 * diff,\n        '61.8%': high - 0.618 * diff,\n        '78.6%': high - 0.786 * diff,\n        '100% (Low)': low\n    }\n    return levels\n\ndef calculate_stochastic(data, k_period=14, d_period=3):\n    \"\"\"Calculate Stochastic Oscillator - single values\"\"\"\n    try:\n        low_k = data['Low'].rolling(window=k_period).min()\n        high_k = data['High'].rolling(window=k_period).max()\n        \n        # Handle division by zero\n        denominator = high_k - low_k\n        k_percent = 100 * ((data['Close'] - low_k) / denominator.replace(0, 1))\n        d_percent = k_percent.rolling(window=d_period).mean()\n        \n        # Return last valid values\n        k_val = k_percent.iloc[-1] if not k_percent.empty and not pd.isna(k_percent.iloc[-1]) else 0\n        d_val = d_percent.iloc[-1] if not d_percent.empty and not pd.isna(d_percent.iloc[-1]) else 0\n        \n        return k_val, d_val\n    except Exception as e:\n        return 0, 0\n\ndef calculate_stochastic_series(data, k_period=14, d_period=3):\n    \"\"\"Calculate Stochastic Oscillator - full series\"\"\"\n    try:\n        low_k = data['Low'].rolling(window=k_period).min()\n        high_k = data['High'].rolling(window=k_period).max()\n        \n        # Handle division by zero\n        denominator = high_k - low_k\n        k_percent = 100 * ((data['Close'] - low_k) / denominator.replace(0, 1))\n        d_percent = k_percent.rolling(window=d_period).mean()\n        \n        return k_percent.fillna(0), d_percent.fillna(0)\n    except Exception as e:\n        empty_series = pd.Series([0] * len(data), index=data.index)\n        return empty_series, empty_series\n\n# Legacy function for compatibility\ndef calculate_rsi(prices, window=14):\n    \"\"\"Calculate Relative Strength Index - legacy function\"\"\"\n    return calculate_rsi_wilder(prices, window)\n\ndef calculate_bollinger_bands(prices, window=20, std_dev=2):\n    \"\"\"Calculate Bollinger Bands - legacy function for compatibility\"\"\"\n    upper_val, middle_val, lower_val = calculate_bollinger_bands_values(prices, window, std_dev)\n    return upper_val, lower_val\n\ndef calculate_williams_r(data, period=14):\n    \"\"\"Calculate Williams %R - single value\"\"\"\n    try:\n        highest_high = data['High'].rolling(window=period).max()\n        lowest_low = data['Low'].rolling(window=period).min()\n        \n        # Williams %R formula: %R = (Highest High - Close) / (Highest High - Lowest Low) √ó -100\n        denominator = highest_high - lowest_low\n        williams_r = -100 * ((highest_high - data['Close']) / denominator.replace(0, 1))\n        \n        # Return last valid value\n        return williams_r.iloc[-1] if not williams_r.empty and not pd.isna(williams_r.iloc[-1]) else -50\n    except Exception as e:\n        return -50\n\ndef calculate_williams_r_series(data, period=14):\n    \"\"\"Calculate Williams %R - full series\"\"\"\n    try:\n        highest_high = data['High'].rolling(window=period).max()\n        lowest_low = data['Low'].rolling(window=period).min()\n        \n        # Williams %R formula: %R = (Highest High - Close) / (Highest High - Lowest Low) √ó -100\n        denominator = highest_high - lowest_low\n        williams_r = -100 * ((highest_high - data['Close']) / denominator.replace(0, 1))\n        \n        return williams_r.fillna(-50)\n    except Exception as e:\n        return pd.Series([-50] * len(data), index=data.index)\n\ndef calculate_ema_13(prices):\n    \"\"\"Calculate 13-period Exponential Moving Average\"\"\"\n    try:\n        ema_13 = prices.ewm(span=13, adjust=False).mean()\n        return ema_13.fillna(method='bfill')\n    except Exception as e:\n        return pd.Series([0] * len(prices), index=prices.index)","size_bytes":31208},"modules/database.py":{"content":"import os\nimport psycopg2\nimport psycopg2.extras\nimport json\nfrom datetime import datetime, date\nfrom typing import Dict, List, Optional, Any\nimport streamlit as st\n\nclass DatabaseManager:\n    \"\"\"Database manager for user profile system with auto-save functionality\"\"\"\n    \n    def __init__(self):\n        self.connection = None\n        self.database_url = os.getenv('DATABASE_URL')\n        \n    def get_connection(self):\n        \"\"\"Get database connection\"\"\"\n        if self.connection is None or self.connection.closed:\n            try:\n                self.connection = psycopg2.connect(self.database_url)\n                self.connection.autocommit = True\n            except Exception as e:\n                st.error(f\"Database connection error: {str(e)}\")\n                return None\n        return self.connection\n    \n    def close_connection(self):\n        \"\"\"Close database connection\"\"\"\n        if self.connection and not self.connection.closed:\n            self.connection.close()\n    \n    def execute_query(self, query: str, params: tuple = None) -> Optional[List[Dict]]:\n        \"\"\"Execute a query and return results\"\"\"\n        try:\n            conn = self.get_connection()\n            if conn is None:\n                return None\n                \n            with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:\n                cursor.execute(query, params)\n                if cursor.description:\n                    return [dict(row) for row in cursor.fetchall()]\n                return []\n        except Exception as e:\n            st.error(f\"Database query error: {str(e)}\")\n            return None\n    \n    def execute_single(self, query: str, params: tuple = None) -> Optional[Dict]:\n        \"\"\"Execute a query and return single result\"\"\"\n        results = self.execute_query(query, params)\n        return results[0] if results else None\n    \n    # User Management\n    def create_user(self, username: str) -> Optional[Dict]:\n        \"\"\"Create a new user\"\"\"\n        query = \"\"\"\n        INSERT INTO users (username) \n        VALUES (%s) \n        ON CONFLICT (username) DO NOTHING\n        RETURNING id, username, created_at\n        \"\"\"\n        return self.execute_single(query, (username,))\n    \n    def get_user(self, username: str) -> Optional[Dict]:\n        \"\"\"Get user by username\"\"\"\n        query = \"SELECT * FROM users WHERE username = %s AND is_active = TRUE\"\n        return self.execute_single(query, (username,))\n    \n    def update_last_login(self, user_id: int):\n        \"\"\"Update user's last login timestamp\"\"\"\n        query = \"UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = %s\"\n        self.execute_query(query, (user_id,))\n    \n    # Portfolio Management\n    def save_portfolio_position(self, user_id: int, symbol: str, shares: float, \n                              purchase_price: float, purchase_date: date) -> bool:\n        \"\"\"Save or update a portfolio position\"\"\"\n        try:\n            query = \"\"\"\n            INSERT INTO user_portfolios (user_id, symbol, shares, purchase_price, purchase_date)\n            VALUES (%s, %s, %s, %s, %s)\n            \"\"\"\n            self.execute_query(query, (user_id, symbol.upper(), shares, purchase_price, purchase_date))\n            return True\n        except Exception as e:\n            st.error(f\"Error saving portfolio position: {str(e)}\")\n            return False\n    \n    def get_user_portfolio(self, user_id: int) -> List[Dict]:\n        \"\"\"Get all portfolio positions for a user\"\"\"\n        query = \"\"\"\n        SELECT * FROM user_portfolios \n        WHERE user_id = %s \n        ORDER BY created_at DESC\n        \"\"\"\n        results = self.execute_query(query, (user_id,))\n        return results or []\n    \n    def remove_portfolio_position(self, user_id: int, position_id: int) -> bool:\n        \"\"\"Remove a portfolio position\"\"\"\n        try:\n            query = \"DELETE FROM user_portfolios WHERE id = %s AND user_id = %s\"\n            self.execute_query(query, (position_id, user_id))\n            return True\n        except Exception as e:\n            st.error(f\"Error removing portfolio position: {str(e)}\")\n            return False\n    \n    def clear_user_portfolio(self, user_id: int) -> bool:\n        \"\"\"Clear all portfolio positions for a user\"\"\"\n        try:\n            query = \"DELETE FROM user_portfolios WHERE user_id = %s\"\n            self.execute_query(query, (user_id,))\n            return True\n        except Exception as e:\n            st.error(f\"Error clearing portfolio: {str(e)}\")\n            return False\n    \n    # Alert Management\n    def save_alert(self, user_id: int, alert_data: Dict) -> bool:\n        \"\"\"Save an alert\"\"\"\n        try:\n            query = \"\"\"\n            INSERT INTO user_alerts (\n                user_id, alert_type, symbol, alert_name, condition_type,\n                target_price, lower_price, upper_price, target_volume,\n                notification_methods, status\n            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)\n            \"\"\"\n            params = (\n                user_id,\n                alert_data.get('alert_type'),\n                alert_data.get('symbol', '').upper(),\n                alert_data.get('alert_name'),\n                alert_data.get('condition'),\n                alert_data.get('target_price'),\n                alert_data.get('lower_price'),\n                alert_data.get('upper_price'),\n                alert_data.get('target_volume'),\n                json.dumps(alert_data.get('notification_method', [])),\n                alert_data.get('status', 'Active')\n            )\n            self.execute_query(query, params)\n            return True\n        except Exception as e:\n            st.error(f\"Error saving alert: {str(e)}\")\n            return False\n    \n    def get_user_alerts(self, user_id: int, status: str = None) -> List[Dict]:\n        \"\"\"Get all alerts for a user\"\"\"\n        if status:\n            query = \"SELECT * FROM user_alerts WHERE user_id = %s AND status = %s ORDER BY created_at DESC\"\n            params = (user_id, status)\n        else:\n            query = \"SELECT * FROM user_alerts WHERE user_id = %s ORDER BY created_at DESC\"\n            params = (user_id,)\n        \n        results = self.execute_query(query, params)\n        \n        # Parse JSON fields\n        if results:\n            for alert in results:\n                if alert.get('notification_methods'):\n                    try:\n                        alert['notification_methods'] = json.loads(alert['notification_methods'])\n                    except:\n                        alert['notification_methods'] = []\n        \n        return results or []\n    \n    def update_alert_status(self, user_id: int, alert_id: int, status: str) -> bool:\n        \"\"\"Update alert status\"\"\"\n        try:\n            query = \"UPDATE user_alerts SET status = %s, updated_at = CURRENT_TIMESTAMP WHERE id = %s AND user_id = %s\"\n            self.execute_query(query, (status, alert_id, user_id))\n            return True\n        except Exception as e:\n            st.error(f\"Error updating alert status: {str(e)}\")\n            return False\n    \n    def remove_alert(self, user_id: int, alert_id: int) -> bool:\n        \"\"\"Remove an alert\"\"\"\n        try:\n            query = \"DELETE FROM user_alerts WHERE id = %s AND user_id = %s\"\n            self.execute_query(query, (alert_id, user_id))\n            return True\n        except Exception as e:\n            st.error(f\"Error removing alert: {str(e)}\")\n            return False\n    \n    def clear_user_alerts(self, user_id: int) -> bool:\n        \"\"\"Clear all alerts for a user\"\"\"\n        try:\n            query = \"DELETE FROM user_alerts WHERE user_id = %s\"\n            self.execute_query(query, (user_id,))\n            return True\n        except Exception as e:\n            st.error(f\"Error clearing alerts: {str(e)}\")\n            return False\n    \n    # Watchlist Management\n    def add_to_watchlist(self, user_id: int, symbol: str) -> bool:\n        \"\"\"Add symbol to user's watchlist\"\"\"\n        try:\n            query = \"\"\"\n            INSERT INTO user_watchlists (user_id, symbol)\n            VALUES (%s, %s)\n            ON CONFLICT (user_id, symbol) DO NOTHING\n            \"\"\"\n            self.execute_query(query, (user_id, symbol.upper()))\n            return True\n        except Exception as e:\n            st.error(f\"Error adding to watchlist: {str(e)}\")\n            return False\n    \n    def remove_from_watchlist(self, user_id: int, symbol: str) -> bool:\n        \"\"\"Remove symbol from user's watchlist\"\"\"\n        try:\n            query = \"DELETE FROM user_watchlists WHERE user_id = %s AND symbol = %s\"\n            self.execute_query(query, (user_id, symbol.upper()))\n            return True\n        except Exception as e:\n            st.error(f\"Error removing from watchlist: {str(e)}\")\n            return False\n    \n    def get_user_watchlist(self, user_id: int) -> List[str]:\n        \"\"\"Get user's watchlist symbols\"\"\"\n        query = \"SELECT symbol FROM user_watchlists WHERE user_id = %s ORDER BY added_at DESC\"\n        results = self.execute_query(query, (user_id,))\n        return [row['symbol'] for row in results] if results else []\n    \n    def save_watchlist(self, user_id: int, symbols: List[str]) -> bool:\n        \"\"\"Save entire watchlist (replace existing)\"\"\"\n        try:\n            # Clear existing watchlist\n            self.execute_query(\"DELETE FROM user_watchlists WHERE user_id = %s\", (user_id,))\n            \n            # Add new symbols\n            for symbol in symbols:\n                if symbol.strip():\n                    self.add_to_watchlist(user_id, symbol.strip())\n            return True\n        except Exception as e:\n            st.error(f\"Error saving watchlist: {str(e)}\")\n            return False\n    \n    # Preferences Management\n    def save_preference(self, user_id: int, preference_type: str, \n                       preference_key: str, preference_value: Any) -> bool:\n        \"\"\"Save a user preference\"\"\"\n        try:\n            query = \"\"\"\n            INSERT INTO user_preferences (user_id, preference_type, preference_key, preference_value)\n            VALUES (%s, %s, %s, %s)\n            ON CONFLICT (user_id, preference_type, preference_key) \n            DO UPDATE SET preference_value = EXCLUDED.preference_value, updated_at = CURRENT_TIMESTAMP\n            \"\"\"\n            self.execute_query(query, (user_id, preference_type, preference_key, json.dumps(preference_value)))\n            return True\n        except Exception as e:\n            st.error(f\"Error saving preference: {str(e)}\")\n            return False\n    \n    def get_preference(self, user_id: int, preference_type: str, preference_key: str) -> Any:\n        \"\"\"Get a specific user preference\"\"\"\n        query = \"\"\"\n        SELECT preference_value FROM user_preferences \n        WHERE user_id = %s AND preference_type = %s AND preference_key = %s\n        \"\"\"\n        result = self.execute_single(query, (user_id, preference_type, preference_key))\n        if result and result.get('preference_value'):\n            try:\n                return json.loads(result['preference_value'])\n            except:\n                return result['preference_value']\n        return None\n    \n    def get_user_preferences(self, user_id: int, preference_type: str = None) -> Dict:\n        \"\"\"Get all preferences for a user of a specific type\"\"\"\n        if preference_type:\n            query = \"\"\"\n            SELECT preference_key, preference_value FROM user_preferences \n            WHERE user_id = %s AND preference_type = %s\n            \"\"\"\n            params = (user_id, preference_type)\n        else:\n            query = \"\"\"\n            SELECT preference_type, preference_key, preference_value FROM user_preferences \n            WHERE user_id = %s\n            \"\"\"\n            params = (user_id,)\n        \n        results = self.execute_query(query, params)\n        preferences = {}\n        \n        if results:\n            for row in results:\n                try:\n                    value = json.loads(row['preference_value'])\n                except:\n                    value = row['preference_value']\n                \n                if preference_type:\n                    preferences[row['preference_key']] = value\n                else:\n                    pref_type = row['preference_type']\n                    if pref_type not in preferences:\n                        preferences[pref_type] = {}\n                    preferences[pref_type][row['preference_key']] = value\n        \n        return preferences\n    \n    def remove_preference(self, user_id: int, preference_type: str, preference_key: str) -> bool:\n        \"\"\"Remove a specific preference\"\"\"\n        try:\n            query = \"\"\"\n            DELETE FROM user_preferences \n            WHERE user_id = %s AND preference_type = %s AND preference_key = %s\n            \"\"\"\n            self.execute_query(query, (user_id, preference_type, preference_key))\n            return True\n        except Exception as e:\n            st.error(f\"Error removing preference: {str(e)}\")\n            return False\n\n# Global database manager instance\ndb_manager = DatabaseManager()","size_bytes":13131},"modules/economic_calendar.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\nimport requests\n\ndef display_calendar():\n    \"\"\"Display economic calendar section\"\"\"\n    \n    st.subheader(\"üìÖ Economic Calendar\")\n    \n    # Date range selector\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        start_date = st.date_input(\n            \"Start Date\", \n            value=datetime.now().date(),\n            max_value=datetime.now().date() + timedelta(days=30)\n        )\n    \n    with col2:\n        end_date = st.date_input(\n            \"End Date\", \n            value=datetime.now().date() + timedelta(days=7),\n            max_value=datetime.now().date() + timedelta(days=30)\n        )\n    \n    # Importance filter\n    importance_filter = st.selectbox(\n        \"Event Importance\",\n        [\"All\", \"High\", \"Medium\", \"Low\"]\n    )\n    \n    # Since we can't access real economic calendar APIs without keys,\n    # we'll display a structured calendar with typical events\n    st.info(\"üìä Economic events are displayed based on typical market calendar patterns\")\n    \n    # Generate sample economic events\n    events = generate_economic_events(start_date, end_date, importance_filter)\n    \n    if events:\n        # Display events in a structured format\n        df = pd.DataFrame(events)\n        \n        # Color coding based on importance\n        def color_importance(val):\n            if val == \"High\":\n                return \"background-color: #ff6b6b; color: white\"\n            elif val == \"Medium\":\n                return \"background-color: #ffa726; color: white\"\n            else:\n                return \"background-color: #66bb6a; color: white\"\n        \n        # Style the dataframe\n        styled_df = df.style.applymap(color_importance, subset=['Importance'])\n        st.dataframe(styled_df, use_container_width=True)\n        \n        # Event details\n        st.subheader(\"üìã Event Details & Impact\")\n        \n        # Group events by importance\n        high_impact = [e for e in events if e['Importance'] == 'High']\n        medium_impact = [e for e in events if e['Importance'] == 'Medium']\n        \n        if high_impact:\n            st.markdown(\"### üî¥ High Impact Events\")\n            for event in high_impact:\n                with st.expander(f\"{event['Date']} - {event['Event']}\"):\n                    st.markdown(f\"**Time:** {event['Time']}\")\n                    st.markdown(f\"**Currency:** {event['Currency']}\")\n                    st.markdown(f\"**Previous:** {event['Previous']}\")\n                    st.markdown(f\"**Forecast:** {event['Forecast']}\")\n                    st.markdown(f\"**Description:** {get_event_description(event['Event'])}\")\n        \n        if medium_impact:\n            st.markdown(\"### üü° Medium Impact Events\")\n            for event in medium_impact[:3]:  # Show first 3\n                with st.expander(f\"{event['Date']} - {event['Event']}\"):\n                    st.markdown(f\"**Time:** {event['Time']}\")\n                    st.markdown(f\"**Currency:** {event['Currency']}\")\n                    st.markdown(f\"**Previous:** {event['Previous']}\")\n                    st.markdown(f\"**Forecast:** {event['Forecast']}\")\n        \n        # Market impact analysis\n        st.subheader(\"üìä Potential Market Impact\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.markdown(\"**USD Impact Events**\")\n            usd_events = len([e for e in events if e['Currency'] == 'USD'])\n            st.metric(\"USD Events\", usd_events)\n            \n            if usd_events > 5:\n                st.warning(\"‚ö†Ô∏è High USD volatility expected\")\n            elif usd_events > 2:\n                st.info(\"üìä Moderate USD activity\")\n            else:\n                st.success(\"‚úÖ Low USD volatility\")\n        \n        with col2:\n            st.markdown(\"**EUR Impact Events**\")\n            eur_events = len([e for e in events if e['Currency'] == 'EUR'])\n            st.metric(\"EUR Events\", eur_events)\n            \n            if eur_events > 3:\n                st.warning(\"‚ö†Ô∏è EUR volatility expected\")\n            else:\n                st.info(\"üìä Normal EUR activity\")\n        \n        with col3:\n            st.markdown(\"**High Impact Count**\")\n            high_count = len([e for e in events if e['Importance'] == 'High'])\n            st.metric(\"High Impact\", high_count)\n            \n            if high_count > 3:\n                st.error(\"üö® Major market events ahead\")\n            elif high_count > 1:\n                st.warning(\"‚ö†Ô∏è Important events scheduled\")\n            else:\n                st.success(\"‚úÖ Calm period expected\")\n    \n    else:\n        st.info(\"No economic events found for the selected period.\")\n    \n    # Market hours information\n    st.subheader(\"üïê Global Market Hours\")\n    \n    display_market_hours()\n    \n    # Central bank schedules\n    st.subheader(\"üèõÔ∏è Central Bank Calendar\")\n    \n    display_central_bank_schedule()\n\ndef generate_economic_events(start_date, end_date, importance_filter):\n    \"\"\"Generate sample economic events based on typical calendar patterns\"\"\"\n    events = []\n    current_date = start_date\n    \n    # Typical economic events with patterns\n    event_patterns = [\n        {\n            \"event\": \"Non-Farm Payrolls\",\n            \"currency\": \"USD\",\n            \"importance\": \"High\",\n            \"time\": \"08:30\",\n            \"frequency\": \"monthly\",\n            \"day\": \"first_friday\"\n        },\n        {\n            \"event\": \"Consumer Price Index (CPI)\",\n            \"currency\": \"USD\",\n            \"importance\": \"High\",\n            \"time\": \"08:30\",\n            \"frequency\": \"monthly\",\n            \"day\": \"mid_month\"\n        },\n        {\n            \"event\": \"Federal Reserve Interest Rate Decision\",\n            \"currency\": \"USD\",\n            \"importance\": \"High\",\n            \"time\": \"14:00\",\n            \"frequency\": \"every_6_weeks\",\n            \"day\": \"wednesday\"\n        },\n        {\n            \"event\": \"GDP Growth Rate\",\n            \"currency\": \"USD\",\n            \"importance\": \"High\",\n            \"time\": \"08:30\",\n            \"frequency\": \"quarterly\",\n            \"day\": \"end_quarter\"\n        },\n        {\n            \"event\": \"Unemployment Rate\",\n            \"currency\": \"USD\",\n            \"importance\": \"Medium\",\n            \"time\": \"08:30\",\n            \"frequency\": \"monthly\",\n            \"day\": \"first_friday\"\n        },\n        {\n            \"event\": \"ECB Interest Rate Decision\",\n            \"currency\": \"EUR\",\n            \"importance\": \"High\",\n            \"time\": \"12:45\",\n            \"frequency\": \"every_6_weeks\",\n            \"day\": \"thursday\"\n        },\n        {\n            \"event\": \"Manufacturing PMI\",\n            \"currency\": \"USD\",\n            \"importance\": \"Medium\",\n            \"time\": \"09:45\",\n            \"frequency\": \"monthly\",\n            \"day\": \"first_business_day\"\n        },\n        {\n            \"event\": \"Initial Jobless Claims\",\n            \"currency\": \"USD\",\n            \"importance\": \"Medium\",\n            \"time\": \"08:30\",\n            \"frequency\": \"weekly\",\n            \"day\": \"thursday\"\n        },\n        {\n            \"event\": \"Consumer Confidence\",\n            \"currency\": \"USD\",\n            \"importance\": \"Medium\",\n            \"time\": \"10:00\",\n            \"frequency\": \"monthly\",\n            \"day\": \"last_tuesday\"\n        },\n        {\n            \"event\": \"Retail Sales\",\n            \"currency\": \"USD\",\n            \"importance\": \"Medium\",\n            \"time\": \"08:30\",\n            \"frequency\": \"monthly\",\n            \"day\": \"mid_month\"\n        }\n    ]\n    \n    # Generate events for the date range\n    while current_date <= end_date:\n        day_of_week = current_date.weekday()  # 0 = Monday, 6 = Sunday\n        \n        # Add events based on patterns\n        if day_of_week == 4:  # Friday - NFP typically first Friday\n            if importance_filter in [\"All\", \"High\"]:\n                events.append({\n                    \"Date\": current_date.strftime(\"%Y-%m-%d\"),\n                    \"Time\": \"08:30\",\n                    \"Event\": \"Non-Farm Payrolls\",\n                    \"Currency\": \"USD\",\n                    \"Importance\": \"High\",\n                    \"Previous\": \"150K\",\n                    \"Forecast\": \"160K\"\n                })\n        \n        if day_of_week == 3:  # Thursday - Jobless Claims\n            if importance_filter in [\"All\", \"Medium\"]:\n                events.append({\n                    \"Date\": current_date.strftime(\"%Y-%m-%d\"),\n                    \"Time\": \"08:30\",\n                    \"Event\": \"Initial Jobless Claims\",\n                    \"Currency\": \"USD\",\n                    \"Importance\": \"Medium\",\n                    \"Previous\": \"220K\",\n                    \"Forecast\": \"215K\"\n                })\n        \n        if day_of_week == 1 and current_date.day <= 7:  # Tuesday, first week\n            if importance_filter in [\"All\", \"Medium\"]:\n                events.append({\n                    \"Date\": current_date.strftime(\"%Y-%m-%d\"),\n                    \"Time\": \"10:00\",\n                    \"Event\": \"Consumer Confidence\",\n                    \"Currency\": \"USD\",\n                    \"Importance\": \"Medium\",\n                    \"Previous\": \"102.5\",\n                    \"Forecast\": \"103.0\"\n                })\n        \n        if current_date.day == 15:  # Mid-month events\n            if importance_filter in [\"All\", \"High\"]:\n                events.append({\n                    \"Date\": current_date.strftime(\"%Y-%m-%d\"),\n                    \"Time\": \"08:30\",\n                    \"Event\": \"Consumer Price Index (CPI)\",\n                    \"Currency\": \"USD\",\n                    \"Importance\": \"High\",\n                    \"Previous\": \"3.2%\",\n                    \"Forecast\": \"3.1%\"\n                })\n        \n        # Add some EUR events\n        if day_of_week == 3 and current_date.day <= 14:  # ECB meeting pattern\n            if importance_filter in [\"All\", \"High\"]:\n                events.append({\n                    \"Date\": current_date.strftime(\"%Y-%m-%d\"),\n                    \"Time\": \"12:45\",\n                    \"Event\": \"ECB Interest Rate Decision\",\n                    \"Currency\": \"EUR\",\n                    \"Importance\": \"High\",\n                    \"Previous\": \"4.50%\",\n                    \"Forecast\": \"4.50%\"\n                })\n        \n        current_date += timedelta(days=1)\n    \n    return events\n\ndef get_event_description(event_name):\n    \"\"\"Get description for economic events\"\"\"\n    descriptions = {\n        \"Non-Farm Payrolls\": \"Monthly report on employment changes in the US economy, excluding farm workers, government employees, and non-profit organizations. Major market mover.\",\n        \"Consumer Price Index (CPI)\": \"Measures the average change in prices paid by consumers for goods and services. Key inflation indicator.\",\n        \"Federal Reserve Interest Rate Decision\": \"FOMC decision on the federal funds rate. Significant impact on USD and global markets.\",\n        \"GDP Growth Rate\": \"Measures the economic growth of the country. Released quarterly with significant market impact.\",\n        \"Unemployment Rate\": \"Percentage of unemployed workers in the total labor force. Key economic health indicator.\",\n        \"ECB Interest Rate Decision\": \"European Central Bank's decision on interest rates. Major impact on EUR and European markets.\",\n        \"Manufacturing PMI\": \"Purchasing Managers' Index for manufacturing sector. Above 50 indicates expansion.\",\n        \"Initial Jobless Claims\": \"Weekly report of unemployment benefit claims. Leading indicator of employment trends.\",\n        \"Consumer Confidence\": \"Measures consumer optimism about economic conditions. Impacts spending and market sentiment.\",\n        \"Retail Sales\": \"Monthly report on consumer spending at retail level. Key indicator of economic health.\"\n    }\n    \n    return descriptions.get(event_name, \"Important economic indicator with potential market impact.\")\n\ndef display_market_hours():\n    \"\"\"Display global market trading hours\"\"\"\n    \n    # Get current time in different markets\n    from datetime import datetime\n    import pytz\n    \n    try:\n        current_utc = datetime.utcnow()\n        \n        # Market hours (in their local time)\n        markets = {\n            \"New York (NYSE)\": {\n                \"timezone\": \"America/New_York\",\n                \"open\": \"09:30\",\n                \"close\": \"16:00\",\n                \"status\": \"Closed\"\n            },\n            \"London (LSE)\": {\n                \"timezone\": \"Europe/London\", \n                \"open\": \"08:00\",\n                \"close\": \"16:30\",\n                \"status\": \"Closed\"\n            },\n            \"Tokyo (TSE)\": {\n                \"timezone\": \"Asia/Tokyo\",\n                \"open\": \"09:00\", \n                \"close\": \"15:00\",\n                \"status\": \"Closed\"\n            },\n            \"Hong Kong (HKEX)\": {\n                \"timezone\": \"Asia/Hong_Kong\",\n                \"open\": \"09:30\",\n                \"close\": \"16:00\", \n                \"status\": \"Closed\"\n            }\n        }\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            for i, (market, info) in enumerate(list(markets.items())[:2]):\n                # Simple status display (would need proper timezone handling for real status)\n                st.markdown(f\"**{market}**\")\n                st.markdown(f\"Hours: {info['open']} - {info['close']}\")\n                st.markdown(f\"Status: {'üü¢ Open' if i % 2 == 0 else 'üî¥ Closed'}\")\n                st.markdown(\"---\")\n        \n        with col2:\n            for i, (market, info) in enumerate(list(markets.items())[2:]):\n                st.markdown(f\"**{market}**\")\n                st.markdown(f\"Hours: {info['open']} - {info['close']}\")\n                st.markdown(f\"Status: {'üü¢ Open' if i % 2 == 1 else 'üî¥ Closed'}\")\n                st.markdown(\"---\")\n                \n    except Exception as e:\n        st.info(\"Market hours information temporarily unavailable\")\n\ndef display_central_bank_schedule():\n    \"\"\"Display central bank meeting schedules\"\"\"\n    \n    cb_schedule = [\n        {\n            \"Bank\": \"Federal Reserve (Fed)\",\n            \"Next Meeting\": \"2024-01-30/31\",\n            \"Frequency\": \"8 times per year\",\n            \"Last Rate\": \"5.25-5.50%\"\n        },\n        {\n            \"Bank\": \"European Central Bank (ECB)\",\n            \"Next Meeting\": \"2024-01-25\",\n            \"Frequency\": \"8 times per year\",\n            \"Last Rate\": \"4.50%\"\n        },\n        {\n            \"Bank\": \"Bank of England (BoE)\",\n            \"Next Meeting\": \"2024-02-01\",\n            \"Frequency\": \"8 times per year\", \n            \"Last Rate\": \"5.25%\"\n        },\n        {\n            \"Bank\": \"Bank of Japan (BoJ)\",\n            \"Next Meeting\": \"2024-01-22/23\",\n            \"Frequency\": \"8 times per year\",\n            \"Last Rate\": \"-0.10%\"\n        }\n    ]\n    \n    df = pd.DataFrame(cb_schedule)\n    st.dataframe(df, use_container_width=True)\n    \n    st.info(\"üí° Central bank decisions are among the most important market-moving events. Monitor these dates closely for potential volatility.\")\n","size_bytes":15026},"modules/market_data.py":{"content":"import yfinance as yf\nimport pandas as pd\nimport streamlit as st\nfrom datetime import datetime, timedelta\nfrom modules.data_service import get_data_service, format_data_quality_indicator, get_data_quality_color\n\ndef get_index_data(symbol, show_quality_indicator=True):\n    \"\"\"Get real-time data for major indices with quality indicators\"\"\"\n    try:\n        data_service = get_data_service()\n        data = data_service.get_index_data(symbol)\n        \n        if data:\n            result = {\n                'price': data.get('price'),\n                'change': data.get('change'),\n                'change_percent': data.get('change_percent'),\n                'volume': data.get('volume', 0),\n                'data_quality': data.get('data_quality'),\n                'source': data.get('source'),\n                'timestamp': data.get('timestamp'),\n                'cache_age': data.get('cache_age', 0)\n            }\n            \n            if show_quality_indicator:\n                quality_indicator = format_data_quality_indicator(\n                    data.get('data_quality'), data.get('cache_age', 0)\n                )\n                result['quality_indicator'] = quality_indicator\n                result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n            \n            return result\n    except Exception as e:\n        st.error(f\"Error fetching data for {symbol}: {str(e)}\")\n    return None\n\ndef get_currency_data(symbol, show_quality_indicator=True):\n    \"\"\"Get real-time currency data with quality indicators\"\"\"\n    try:\n        data_service = get_data_service()\n        data = data_service.get_currency_data(symbol)\n        \n        if data:\n            result = {\n                'price': data.get('price'),\n                'change': data.get('change'),\n                'change_percent': data.get('change_percent', 0),\n                'data_quality': data.get('data_quality'),\n                'source': data.get('source'),\n                'timestamp': data.get('timestamp'),\n                'cache_age': data.get('cache_age', 0)\n            }\n            \n            if show_quality_indicator:\n                quality_indicator = format_data_quality_indicator(\n                    data.get('data_quality'), data.get('cache_age', 0)\n                )\n                result['quality_indicator'] = quality_indicator\n                result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n            \n            return result\n    except Exception as e:\n        st.error(f\"Error fetching currency data for {symbol}: {str(e)}\")\n    return None\n\ndef get_commodity_data(symbol, show_quality_indicator=True):\n    \"\"\"Get real-time commodity data with quality indicators\"\"\"\n    try:\n        data_service = get_data_service()\n        data = data_service.get_commodity_data(symbol)\n        \n        if data:\n            result = {\n                'price': data.get('price'),\n                'change': data.get('change'),\n                'change_percent': data.get('change_percent', 0),\n                'data_quality': data.get('data_quality'),\n                'source': data.get('source'),\n                'timestamp': data.get('timestamp'),\n                'cache_age': data.get('cache_age', 0)\n            }\n            \n            if show_quality_indicator:\n                quality_indicator = format_data_quality_indicator(\n                    data.get('data_quality'), data.get('cache_age', 0)\n                )\n                result['quality_indicator'] = quality_indicator\n                result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n            \n            return result\n    except Exception as e:\n        st.error(f\"Error fetching commodity data for {symbol}: {str(e)}\")\n    return None\n\ndef get_crypto_data(symbol, show_quality_indicator=True):\n    \"\"\"Get real-time cryptocurrency data with quality indicators\"\"\"\n    try:\n        data_service = get_data_service()\n        data = data_service.get_crypto_data(symbol)\n        \n        if data:\n            result = {\n                'price': data.get('price'),\n                'change': data.get('change'),\n                'change_percent': data.get('change_percent', 0),\n                'data_quality': data.get('data_quality'),\n                'source': data.get('source'),\n                'timestamp': data.get('timestamp'),\n                'cache_age': data.get('cache_age', 0)\n            }\n            \n            if show_quality_indicator:\n                quality_indicator = format_data_quality_indicator(\n                    data.get('data_quality'), data.get('cache_age', 0)\n                )\n                result['quality_indicator'] = quality_indicator\n                result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n            \n            return result\n    except Exception as e:\n        st.error(f\"Error fetching crypto data for {symbol}: {str(e)}\")\n    return None\n\n@st.cache_data(ttl=300)  # Cache for 5 minutes for historical data\ndef get_stock_data(symbol, period=\"1y\"):\n    \"\"\"Get historical stock data with company info\"\"\"\n    try:\n        data_service = get_data_service()\n        \n        # Get historical data\n        hist = data_service.get_historical_data(symbol, period=period)\n        \n        # Get company info (cached separately for longer)\n        info = data_service.get_company_info(symbol)\n        \n        if hist is not None:\n            result = {\n                'history': hist,\n                'info': info or {},\n                'data_quality': 'historical',\n                'source': 'yfinance',\n                'timestamp': datetime.now().isoformat()\n            }\n            return result\n    except Exception as e:\n        st.error(f\"Error fetching stock data for {symbol}: {str(e)}\")\n    return None\n\ndef get_real_time_quote(symbol, force_refresh=False, show_quality_indicator=True):\n    \"\"\"Get real-time quote for a symbol with enhanced capabilities\"\"\"\n    try:\n        data_service = get_data_service()\n        data = data_service.get_stock_quote(symbol, force_refresh=force_refresh)\n        \n        if data:\n            result = {\n                'symbol': symbol,\n                'price': data.get('price'),\n                'change': data.get('change'),\n                'change_percent': data.get('change_percent'),\n                'volume': data.get('volume', 0),\n                'timestamp': data.get('timestamp'),\n                'data_quality': data.get('data_quality'),\n                'source': data.get('source'),\n                'cache_age': data.get('cache_age', 0)\n            }\n            \n            if show_quality_indicator:\n                quality_indicator = format_data_quality_indicator(\n                    data.get('data_quality'), data.get('cache_age', 0)\n                )\n                result['quality_indicator'] = quality_indicator\n                result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n            \n            return result\n    except Exception as e:\n        st.error(f\"Error fetching real-time quote for {symbol}: {str(e)}\")\n    return None\n\ndef get_multiple_quotes(symbols, force_refresh=False, show_quality_indicator=True):\n    \"\"\"Get multiple real-time quotes efficiently\"\"\"\n    try:\n        data_service = get_data_service()\n        quotes = data_service.get_multiple_quotes(symbols, force_refresh=force_refresh)\n        \n        results = {}\n        for symbol, data in quotes.items():\n            if data:\n                result = {\n                    'symbol': symbol,\n                    'price': data.get('price'),\n                    'change': data.get('change'),\n                    'change_percent': data.get('change_percent'),\n                    'volume': data.get('volume', 0),\n                    'timestamp': data.get('timestamp'),\n                    'data_quality': data.get('data_quality'),\n                    'source': data.get('source'),\n                    'cache_age': data.get('cache_age', 0)\n                }\n                \n                if show_quality_indicator:\n                    quality_indicator = format_data_quality_indicator(\n                        data.get('data_quality'), data.get('cache_age', 0)\n                    )\n                    result['quality_indicator'] = quality_indicator\n                    result['quality_color'] = get_data_quality_color(data.get('data_quality'))\n                \n                results[symbol] = result\n        \n        return results\n    except Exception as e:\n        st.error(f\"Error fetching multiple quotes: {str(e)}\")\n    return {}\n\ndef display_data_quality_indicator(data, label=\"Data Quality\"):\n    \"\"\"Display data quality indicator in Streamlit\"\"\"\n    if data and 'quality_indicator' in data:\n        quality_color = data.get('quality_color', 'gray')\n        st.markdown(\n            f\"**{label}:** <span style='color: {quality_color}'>{data['quality_indicator']}</span>\",\n            unsafe_allow_html=True\n        )\n        \n        # Show additional info on hover/expand\n        if data.get('source'):\n            st.caption(f\"Source: {data['source']}\")\n        if data.get('timestamp'):\n            try:\n                from datetime import datetime\n                timestamp = datetime.fromisoformat(data['timestamp'].replace('Z', '+00:00'))\n                st.caption(f\"Last updated: {timestamp.strftime('%H:%M:%S')}\")\n            except:\n                pass\n\ndef display_auto_refresh_controls():\n    \"\"\"Display auto-refresh controls for real-time data\"\"\"\n    st.markdown(\"### üîÑ Real-Time Data Controls\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        auto_refresh = st.checkbox(\"Auto Refresh\", value=False, help=\"Automatically refresh data every 5 seconds\")\n    \n    with col2:\n        if st.button(\"üîÑ Refresh Now\", help=\"Force refresh all data\"):\n            # Clear relevant caches to force refresh\n            data_service = get_data_service()\n            data_service.clear_cache('stock_quote')\n            data_service.clear_cache('index_data')\n            st.success(\"Data refreshed!\")\n            st.rerun()\n    \n    with col3:\n        market_hours = is_market_hours()\n        market_status = \"üü¢ OPEN\" if market_hours else \"üî¥ CLOSED\"\n        st.markdown(f\"**Market:** {market_status}\")\n    \n    # Auto-refresh implementation\n    if auto_refresh:\n        import time\n        time.sleep(5)\n        st.rerun()\n    \n    return auto_refresh\n\ndef is_market_hours():\n    \"\"\"Check if it's currently market hours\"\"\"\n    try:\n        data_service = get_data_service()\n        return data_service.is_market_hours()\n    except:\n        return False\n\ndef get_cache_statistics():\n    \"\"\"Get and display cache statistics\"\"\"\n    try:\n        data_service = get_data_service()\n        stats = data_service.get_cache_stats()\n        \n        st.markdown(\"### üìä Cache Statistics\")\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\"Total Entries\", stats['total_entries'])\n        \n        with col2:\n            size_mb = stats['total_size_bytes'] / (1024 * 1024)\n            st.metric(\"Cache Size\", f\"{size_mb:.2f} MB\")\n        \n        with col3:\n            if st.button(\"üóëÔ∏è Clear Cache\"):\n                data_service.clear_cache()\n                st.success(\"Cache cleared!\")\n                st.rerun()\n        \n        # Show cache breakdown by type\n        if stats['type_counts']:\n            st.markdown(\"**Cache Breakdown:**\")\n            for data_type, count in stats['type_counts'].items():\n                st.write(f\"- {data_type}: {count} entries\")\n                \n    except Exception as e:\n        st.error(f\"Error getting cache statistics: {str(e)}\")\n\n# Backward compatibility functions\ndef get_stock_quote_simple(symbol):\n    \"\"\"Simple stock quote function for backward compatibility\"\"\"\n    data = get_real_time_quote(symbol, show_quality_indicator=False)\n    if data:\n        return {\n            'price': data.get('price'),\n            'change': data.get('change'),\n            'change_percent': data.get('change_percent'),\n            'volume': data.get('volume', 0)\n        }\n    return None\n\ndef format_price_display(price, change, change_percent):\n    \"\"\"Format price display with color coding\"\"\"\n    if change is None or change_percent is None:\n        return f\"${price:.2f}\"\n    \n    color = \"green\" if change >= 0 else \"red\"\n    sign = \"+\" if change >= 0 else \"\"\n    \n    return f\"${price:.2f} <span style='color: {color}'>{sign}{change:.2f} ({sign}{change_percent:.2f}%)</span>\"\n","size_bytes":12572},"modules/news.py":{"content":"import streamlit as st\nimport feedparser\nimport requests\nfrom datetime import datetime, timedelta, timezone\nimport pandas as pd\nfrom bs4 import BeautifulSoup\nimport json\nimport re\nfrom textblob import TextBlob\nfrom typing import Dict, List, Optional, Any\nimport time\nimport urllib.parse\nfrom modules.user_auth import user_auth\nfrom modules.database import db_manager\nimport yfinance as yf\n\n# Enhanced news sources with better RSS feeds and fallback options\nNEWS_SOURCES = {\n    \"Yahoo Finance\": {\n        \"rss\": \"https://feeds.finance.yahoo.com/rss/2.0/headline\",\n        \"fallback\": [\n            \"https://finance.yahoo.com/rss/topstories\",\n            \"https://feeds.yahoo.com/finance/news\"\n        ],\n        \"category\": \"General\"\n    },\n    \"MarketWatch\": {\n        \"rss\": \"https://feeds.marketwatch.com/marketwatch/topstories/\",\n        \"fallback\": [\n            \"https://feeds.marketwatch.com/marketwatch/realtimeheadlines/\"\n        ],\n        \"category\": \"General\"\n    },\n    \"Reuters Business\": {\n        \"rss\": \"https://feeds.reuters.com/reuters/businessNews\",\n        \"fallback\": [\n            \"https://www.reutersagency.com/feed/?best-topics=business-finance&post_type=best\"\n        ],\n        \"category\": \"General\"\n    },\n    \"Bloomberg\": {\n        \"rss\": \"https://feeds.bloomberg.com/markets/news.rss\",\n        \"fallback\": [\n            \"https://feeds.bloomberg.com/technology/news.rss\"\n        ],\n        \"category\": \"General\"\n    },\n    \"Financial Times\": {\n        \"rss\": \"https://www.ft.com/news-feed\",\n        \"fallback\": [\n            \"https://www.ft.com/rss/home/uk\"\n        ],\n        \"category\": \"General\"\n    },\n    \"CNBC\": {\n        \"rss\": \"https://www.cnbc.com/id/100003114/device/rss/rss.html\",\n        \"fallback\": [\n            \"https://www.cnbc.com/id/10001147/device/rss/rss.html\"\n        ],\n        \"category\": \"General\"\n    },\n    \"Seeking Alpha\": {\n        \"rss\": \"https://seekingalpha.com/feed.xml\",\n        \"fallback\": [],\n        \"category\": \"Analysis\"\n    },\n    \"Earnings Feed\": {\n        \"rss\": \"https://feeds.finance.yahoo.com/rss/2.0/headline\",\n        \"fallback\": [],\n        \"category\": \"Earnings\"\n    }\n}\n\n# News categories for filtering\nNEWS_CATEGORIES = {\n    \"All\": \"all\",\n    \"Breaking News\": \"breaking\",\n    \"Earnings\": \"earnings\", \n    \"Mergers\": \"merger\",\n    \"Market Analysis\": \"analysis\",\n    \"Crypto\": \"crypto\",\n    \"Commodities\": \"commodity\"\n}\n\n# Keywords for different categories\nCATEGORY_KEYWORDS = {\n    \"breaking\": [\"breaking\", \"urgent\", \"alert\", \"developing\", \"just in\"],\n    \"earnings\": [\"earnings\", \"quarterly\", \"q1\", \"q2\", \"q3\", \"q4\", \"eps\", \"revenue\", \"profit\"],\n    \"merger\": [\"merger\", \"acquisition\", \"deal\", \"takeover\", \"buyout\", \"m&a\"],\n    \"analysis\": [\"analysis\", \"outlook\", \"forecast\", \"target\", \"rating\", \"upgrade\", \"downgrade\"],\n    \"crypto\": [\"bitcoin\", \"crypto\", \"blockchain\", \"ethereum\", \"btc\", \"eth\", \"defi\"],\n    \"commodity\": [\"oil\", \"gold\", \"silver\", \"copper\", \"energy\", \"commodity\", \"crude\"]\n}\n\ndef display_news():\n    \"\"\"Enhanced financial news section with comprehensive features\"\"\"\n    \n    st.subheader(\"üì∞ Financial News & Market Intelligence\")\n    \n    # Load user preferences\n    user_id = user_auth.get_current_user_id()\n    preferred_sources = user_auth.get_user_preference(\"news\", \"preferred_sources\", list(NEWS_SOURCES.keys())[:3])\n    show_sentiment = user_auth.get_user_preference(\"news\", \"show_sentiment\", True)\n    auto_refresh = user_auth.get_user_preference(\"news\", \"auto_refresh\", False)\n    \n    # News controls and filters\n    col1, col2, col3 = st.columns([2, 1, 1])\n    \n    with col1:\n        selected_sources = st.multiselect(\n            \"Select News Sources\", \n            list(NEWS_SOURCES.keys()),\n            default=preferred_sources if preferred_sources else list(NEWS_SOURCES.keys())[:3],\n            help=\"Choose your preferred news sources\"\n        )\n        \n        # Save preference\n        if selected_sources != preferred_sources:\n            user_auth.auto_save_preference(\"news\", \"preferred_sources\", selected_sources)\n    \n    with col2:\n        category_filter = st.selectbox(\"Category Filter\", list(NEWS_CATEGORIES.keys()))\n    \n    with col3:\n        auto_refresh_enabled = st.checkbox(\"Auto Refresh (2 min)\", value=auto_refresh)\n        if auto_refresh_enabled != auto_refresh:\n            user_auth.auto_save_preference(\"news\", \"auto_refresh\", auto_refresh_enabled)\n    \n    # Advanced filters\n    with st.expander(\"üîç Advanced Filters\"):\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            symbol_filter = st.text_input(\"Stock Symbol Filter\", placeholder=\"e.g., AAPL, TSLA\")\n            \n        with col2:\n            keyword_filter = st.text_input(\"Keyword Filter\", placeholder=\"e.g., AI, merger, earnings\")\n            \n        with col3:\n            sentiment_filter = st.selectbox(\"Sentiment Filter\", [\"All\", \"Positive\", \"Negative\", \"Neutral\"])\n    \n    # News search functionality\n    with st.expander(\"üìÖ News Search\"):\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            search_keywords = st.text_input(\"Search Keywords\", placeholder=\"Search news...\")\n        \n        with col2:\n            date_from = st.date_input(\"From Date\", value=datetime.now().date() - timedelta(days=7))\n            \n        with col3:\n            date_to = st.date_input(\"To Date\", value=datetime.now().date())\n        \n        if st.button(\"üîç Search News\"):\n            if search_keywords:\n                search_results = search_news_by_criteria(search_keywords, date_from, date_to, selected_sources)\n                if search_results:\n                    display_news_items(search_results, show_sentiment)\n                else:\n                    st.info(\"No news found matching your search criteria.\")\n    \n    # Fetch and display news\n    if selected_sources:\n        try:\n            # Get news from selected sources\n            all_news = []\n            \n            for source in selected_sources:\n                try:\n                    news_items = fetch_enhanced_news(source)\n                    if news_items:\n                        for item in news_items:\n                            item['source'] = source\n                            all_news.append(item)\n                except Exception as e:\n                    st.warning(f\"Could not fetch news from {source}: {str(e)}\")\n            \n            if all_news:\n                # Apply filters\n                filtered_news = filter_news_items(\n                    all_news, \n                    category_filter, \n                    symbol_filter, \n                    keyword_filter, \n                    sentiment_filter\n                )\n                \n                if filtered_news:\n                    # Sort by published date\n                    filtered_news.sort(key=lambda x: x.get('published_parsed', datetime.min), reverse=True)\n                    \n                    # Display news\n                    display_news_items(filtered_news, show_sentiment)\n                else:\n                    st.info(\"No news matches your current filters.\")\n            else:\n                st.error(\"Unable to fetch news from any selected sources.\")\n                display_fallback_news()\n                \n        except Exception as e:\n            st.error(f\"Error fetching news: {str(e)}\")\n            display_fallback_news()\n    else:\n        st.warning(\"Please select at least one news source.\")\n    \n    # News alerts section\n    display_news_alerts()\n    \n    # Enhanced market sentiment analysis\n    display_enhanced_market_sentiment()\n\n@st.cache_data(ttl=120)  # Cache for 2 minutes\ndef fetch_enhanced_news(source: str) -> List[Dict]:\n    \"\"\"Enhanced news fetcher with fallback mechanisms and better error handling\"\"\"\n    \n    if source not in NEWS_SOURCES:\n        return []\n    \n    source_config = NEWS_SOURCES[source]\n    urls_to_try = [source_config['rss']] + source_config.get('fallback', [])\n    \n    for url in urls_to_try:\n        try:\n            # Add timeout and user agent to prevent blocking\n            headers = {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n            }\n            \n            # Try to fetch with requests first for better error handling\n            try:\n                response = requests.get(url, headers=headers, timeout=10)\n                response.raise_for_status()\n                feed = feedparser.parse(response.content)\n            except:\n                # Fallback to direct feedparser\n                feed = feedparser.parse(url)\n            \n            if not hasattr(feed, 'entries') or not feed.entries:\n                continue\n                \n            news_items = []\n            \n            for entry in feed.entries[:20]:  # Limit to 20 items per source\n                try:\n                    # Enhanced data extraction\n                    item = {\n                        'title': clean_text(entry.get('title', '')),\n                        'summary': clean_text(entry.get('summary', entry.get('description', ''))),\n                        'link': entry.get('link', ''),\n                        'published': entry.get('published', ''),\n                        'published_parsed': parse_date(entry.get('published_parsed', entry.get('published', ''))),\n                        'category': determine_category(entry.get('title', '') + ' ' + entry.get('summary', '')),\n                        'sentiment': analyze_sentiment(entry.get('title', '') + ' ' + entry.get('summary', '')),\n                        'summary_generated': False\n                    }\n                    \n                    # Generate summary for long articles\n                    if len(item['summary']) > 500:\n                        item['summary'] = generate_summary(item['summary'])\n                        item['summary_generated'] = True\n                    \n                    news_items.append(item)\n                    \n                except Exception as e:\n                    continue  # Skip problematic entries\n            \n            if news_items:\n                return news_items\n                \n        except Exception as e:\n            continue  # Try next URL\n    \n    return []\n\ndef clean_text(text: str) -> str:\n    \"\"\"Clean and normalize text content\"\"\"\n    if not text:\n        return \"\"\n    \n    # Remove HTML tags\n    soup = BeautifulSoup(text, 'html.parser')\n    text = soup.get_text()\n    \n    # Remove extra whitespace\n    text = ' '.join(text.split())\n    \n    return text.strip()\n\ndef parse_date(date_input) -> datetime:\n    \"\"\"Parse various date formats to datetime object\"\"\"\n    if not date_input:\n        return datetime.min\n    \n    if isinstance(date_input, tuple):\n        try:\n            return datetime(*date_input[:6])\n        except:\n            return datetime.min\n    \n    if isinstance(date_input, str):\n        try:\n            from dateutil import parser\n            return parser.parse(date_input)\n        except:\n            return datetime.min\n    \n    if isinstance(date_input, datetime):\n        return date_input\n    \n    return datetime.min\n\ndef analyze_sentiment(text: str) -> Dict:\n    \"\"\"Analyze sentiment of news text using TextBlob\"\"\"\n    try:\n        if not text:\n            return {\"polarity\": 0, \"label\": \"Neutral\", \"confidence\": 0}\n        \n        blob = TextBlob(text)\n        polarity = blob.sentiment.polarity\n        \n        if polarity > 0.1:\n            label = \"Positive\"\n        elif polarity < -0.1:\n            label = \"Negative\"\n        else:\n            label = \"Neutral\"\n        \n        confidence = abs(polarity)\n        \n        return {\n            \"polarity\": polarity,\n            \"label\": label,\n            \"confidence\": confidence\n        }\n    except:\n        return {\"polarity\": 0, \"label\": \"Neutral\", \"confidence\": 0}\n\ndef determine_category(text: str) -> str:\n    \"\"\"Determine news category based on keywords\"\"\"\n    text_lower = text.lower()\n    \n    for category, keywords in CATEGORY_KEYWORDS.items():\n        if any(keyword in text_lower for keyword in keywords):\n            return category\n    \n    return \"general\"\n\ndef generate_summary(text: str, max_sentences: int = 3) -> str:\n    \"\"\"Generate a summary of long text\"\"\"\n    try:\n        sentences = text.split('.')\n        if len(sentences) <= max_sentences:\n            return text\n        \n        # Simple extractive summarization - take first few sentences\n        summary_sentences = sentences[:max_sentences]\n        summary = '. '.join(summary_sentences) + '.'\n        \n        # Ensure summary isn't too long\n        if len(summary) > 300:\n            summary = summary[:297] + \"...\"\n        \n        return summary\n    except:\n        return text[:300] + \"...\" if len(text) > 300 else text\n\ndef filter_news_items(news_items: List[Dict], category_filter: str, symbol_filter: str, \n                     keyword_filter: str, sentiment_filter: str) -> List[Dict]:\n    \"\"\"Filter news items based on various criteria\"\"\"\n    \n    filtered = news_items\n    \n    # Category filter\n    if category_filter != \"All\":\n        category_key = NEWS_CATEGORIES.get(category_filter, \"all\")\n        if category_key != \"all\":\n            filtered = [item for item in filtered if item.get('category') == category_key]\n    \n    # Symbol filter\n    if symbol_filter:\n        symbols = [s.strip().upper() for s in symbol_filter.split(',')]\n        filtered = [item for item in filtered if any(\n            symbol in (item.get('title', '') + ' ' + item.get('summary', '')).upper() \n            for symbol in symbols\n        )]\n    \n    # Keyword filter\n    if keyword_filter:\n        keywords = [k.strip().lower() for k in keyword_filter.split(',')]\n        filtered = [item for item in filtered if any(\n            keyword in (item.get('title', '') + ' ' + item.get('summary', '')).lower()\n            for keyword in keywords\n        )]\n    \n    # Sentiment filter\n    if sentiment_filter != \"All\":\n        filtered = [item for item in filtered \n                   if item.get('sentiment', {}).get('label', 'Neutral') == sentiment_filter]\n    \n    return filtered\n\ndef search_news_by_criteria(keywords: str, date_from: datetime.date, \n                           date_to: datetime.date, sources: List[str]) -> List[Dict]:\n    \"\"\"Search news by specific criteria\"\"\"\n    \n    all_news = []\n    \n    for source in sources:\n        try:\n            news_items = fetch_enhanced_news(source)\n            for item in news_items:\n                item['source'] = source\n                \n                # Date filtering\n                item_date = item.get('published_parsed', datetime.min).date()\n                if date_from <= item_date <= date_to:\n                    \n                    # Keyword filtering\n                    text_content = (item.get('title', '') + ' ' + item.get('summary', '')).lower()\n                    if any(keyword.lower() in text_content for keyword in keywords.split()):\n                        all_news.append(item)\n        except:\n            continue\n    \n    return all_news\n\ndef display_news_items(news_items: List[Dict], show_sentiment: bool = True):\n    \"\"\"Display formatted news items with enhanced features\"\"\"\n    \n    st.subheader(f\"üì∞ Latest News ({len(news_items)} articles)\")\n    \n    for i, item in enumerate(news_items[:30]):  # Limit to 30 items for performance\n        with st.container():\n            # Create expandable news item\n            with st.expander(f\"**{item.get('title', 'No Title')}**\", expanded=(i < 5)):\n                \n                col1, col2 = st.columns([3, 1])\n                \n                with col1:\n                    # News content\n                    if item.get('summary'):\n                        summary_text = item['summary']\n                        if item.get('summary_generated'):\n                            st.markdown(f\"*üìù Auto-generated summary:*\")\n                        st.markdown(f\"*{summary_text}*\")\n                    \n                    # Read more link\n                    if item.get('link'):\n                        st.markdown(f\"[üîó Read full article]({item['link']})\")\n                    \n                    # Show category and source\n                    col_cat, col_src = st.columns(2)\n                    with col_cat:\n                        category = item.get('category', 'general').title()\n                        st.markdown(f\"**Category:** {category}\")\n                    with col_src:\n                        st.markdown(f\"**Source:** {item.get('source', 'Unknown')}\")\n                \n                with col2:\n                    # Timestamp\n                    if item.get('published_parsed'):\n                        time_diff = get_relative_time(item['published_parsed'])\n                        st.markdown(f\"**üìÖ {time_diff}**\")\n                    \n                    # Sentiment analysis\n                    if show_sentiment and item.get('sentiment'):\n                        sentiment = item['sentiment']\n                        sentiment_emoji = {\n                            'Positive': 'üòä',\n                            'Negative': 'üòî',\n                            'Neutral': 'üòê'\n                        }\n                        \n                        emoji = sentiment_emoji.get(sentiment['label'], 'üòê')\n                        confidence_pct = sentiment['confidence'] * 100\n                        \n                        st.markdown(f\"**Sentiment:** {emoji} {sentiment['label']}\")\n                        st.progress(confidence_pct / 100)\n                        st.caption(f\"Confidence: {confidence_pct:.1f}%\")\n\ndef get_relative_time(published_date: datetime) -> str:\n    \"\"\"Get relative time string (e.g., '2 hours ago')\"\"\"\n    try:\n        now = datetime.now()\n        if published_date.tzinfo is None:\n            published_date = published_date.replace(tzinfo=timezone.utc)\n        if now.tzinfo is None:\n            now = now.replace(tzinfo=timezone.utc)\n        \n        diff = now - published_date\n        \n        if diff.days > 1:\n            return f\"{diff.days} days ago\"\n        elif diff.days == 1:\n            return \"1 day ago\"\n        elif diff.seconds > 3600:\n            hours = diff.seconds // 3600\n            return f\"{hours} hour{'s' if hours != 1 else ''} ago\"\n        elif diff.seconds > 60:\n            minutes = diff.seconds // 60\n            return f\"{minutes} minute{'s' if minutes != 1 else ''} ago\"\n        else:\n            return \"Just now\"\n    except:\n        return \"Unknown\"\n\ndef display_news_alerts():\n    \"\"\"Display and manage news alerts system\"\"\"\n    \n    st.subheader(\"üö® News Alerts & Notifications\")\n    \n    if not user_auth.is_logged_in():\n        st.info(\"Please login to set up news alerts.\")\n        return\n    \n    user_id = user_auth.get_current_user_id()\n    \n    # Get existing news alerts\n    news_alerts = user_auth.get_user_preference(\"news\", \"alerts\", [])\n    \n    with st.expander(\"üì¢ Configure News Alerts\"):\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            alert_type = st.selectbox(\"Alert Type\", [\n                \"Breaking News\", \n                \"Stock Symbol Mentions\", \n                \"Earnings Announcements\",\n                \"Merger & Acquisitions\",\n                \"Market Moving Events\"\n            ])\n            \n            alert_keywords = st.text_input(\n                \"Keywords/Symbols\", \n                placeholder=\"e.g., AAPL, Tesla, Federal Reserve\"\n            )\n        \n        with col2:\n            notification_methods = st.multiselect(\"Notification Methods\", [\n                \"In-App Notification\",\n                \"Browser Alert\",\n                \"Email (Future)\"\n            ], default=[\"In-App Notification\"])\n            \n            alert_frequency = st.selectbox(\"Check Frequency\", [\n                \"Real-time\", \"Every 5 minutes\", \"Every 15 minutes\", \"Hourly\"\n            ])\n        \n        if st.button(\"‚ûï Add News Alert\"):\n            if alert_keywords:\n                new_alert = {\n                    \"id\": len(news_alerts) + 1,\n                    \"type\": alert_type,\n                    \"keywords\": alert_keywords,\n                    \"methods\": notification_methods,\n                    \"frequency\": alert_frequency,\n                    \"created\": datetime.now().isoformat(),\n                    \"active\": True,\n                    \"last_triggered\": None\n                }\n                \n                news_alerts.append(new_alert)\n                user_auth.auto_save_preference(\"news\", \"alerts\", news_alerts)\n                st.success(\"News alert added successfully!\")\n                st.rerun()\n    \n    # Display existing alerts\n    if news_alerts:\n        st.subheader(\"Active News Alerts\")\n        \n        for alert in news_alerts:\n            if alert.get('active', True):\n                with st.container():\n                    col1, col2, col3 = st.columns([3, 1, 1])\n                    \n                    with col1:\n                        st.markdown(f\"**{alert['type']}** - Keywords: _{alert['keywords']}_\")\n                        st.caption(f\"Created: {alert.get('created', 'Unknown')} | Frequency: {alert.get('frequency', 'Unknown')}\")\n                    \n                    with col2:\n                        status = \"üü¢ Active\" if alert.get('active') else \"üî¥ Inactive\"\n                        st.markdown(status)\n                    \n                    with col3:\n                        if st.button(f\"üóëÔ∏è Remove\", key=f\"remove_alert_{alert['id']}\"):\n                            news_alerts = [a for a in news_alerts if a['id'] != alert['id']]\n                            user_auth.auto_save_preference(\"news\", \"alerts\", news_alerts)\n                            st.success(\"Alert removed!\")\n                            st.rerun()\n                    \n                    st.markdown(\"---\")\n    \n    # Check for triggered alerts (simplified implementation)\n    check_news_alerts(news_alerts)\n\ndef check_news_alerts(alerts: List[Dict]):\n    \"\"\"Check if any news alerts should be triggered\"\"\"\n    \n    if not alerts:\n        return\n    \n    # This is a simplified implementation\n    # In a production system, this would run in the background\n    try:\n        recent_news = []\n        for source in list(NEWS_SOURCES.keys())[:3]:  # Check top 3 sources\n            try:\n                news_items = fetch_enhanced_news(source)\n                if news_items:\n                    recent_news.extend(news_items[:5])  # Get recent 5 from each\n            except:\n                continue\n        \n        for alert in alerts:\n            if not alert.get('active'):\n                continue\n            \n            keywords = [k.strip().lower() for k in alert.get('keywords', '').split(',')]\n            \n            for news_item in recent_news:\n                news_text = (news_item.get('title', '') + ' ' + news_item.get('summary', '')).lower()\n                \n                if any(keyword in news_text for keyword in keywords):\n                    # Show notification\n                    st.info(f\"üö® **News Alert Triggered**: {alert['type']}\")\n                    st.markdown(f\"**{news_item.get('title', 'News Item')}**\")\n                    st.markdown(f\"_{news_item.get('summary', '')[:150]}..._\")\n                    break\n    \n    except Exception as e:\n        # Silently handle alert checking errors\n        pass\n\ndef display_enhanced_market_sentiment():\n    \"\"\"Enhanced market sentiment analysis with multiple indicators\"\"\"\n    \n    st.subheader(\"üìä Enhanced Market Sentiment Analysis\")\n    \n    # Traditional sentiment indicators\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        # VIX Fear & Greed (enhanced)\n        try:\n            vix = yf.Ticker(\"^VIX\")\n            vix_data = vix.history(period=\"5d\")\n            \n            if not vix_data.empty:\n                vix_value = vix_data['Close'].iloc[-1]\n                vix_change = vix_data['Close'].iloc[-1] - vix_data['Close'].iloc[-5]\n                \n                if vix_value > 30:\n                    sentiment = \"üò± Extreme Fear\"\n                    color = \"#FF0000\"\n                elif vix_value > 20:\n                    sentiment = \"üò® High Fear\"\n                    color = \"#FF6600\"\n                elif vix_value > 15:\n                    sentiment = \"üòê Moderate Fear\"\n                    color = \"#FFAA00\"\n                else:\n                    sentiment = \"üòé Low Fear (Greed)\"\n                    color = \"#00FF00\"\n                \n                st.metric(\"VIX (Fear Index)\", f\"{vix_value:.2f}\", f\"{vix_change:+.2f}\")\n                st.markdown(f\"<div style='color: {color}'>{sentiment}</div>\", unsafe_allow_html=True)\n        except:\n            st.metric(\"VIX (Fear Index)\", \"N/A\")\n    \n    with col2:\n        # Crypto sentiment\n        try:\n            btc = yf.Ticker(\"BTC-USD\")\n            btc_data = btc.history(period=\"5d\")\n            \n            if not btc_data.empty:\n                btc_change = ((btc_data['Close'].iloc[-1] - btc_data['Close'].iloc[-5]) / btc_data['Close'].iloc[-5]) * 100\n                \n                if btc_change > 5:\n                    crypto_sentiment = \"üöÄ Crypto Bullish\"\n                elif btc_change < -5:\n                    crypto_sentiment = \"üìâ Crypto Bearish\"\n                else:\n                    crypto_sentiment = \"‚û°Ô∏è Crypto Neutral\"\n                \n                st.metric(\"Crypto Sentiment\", f\"${btc_data['Close'].iloc[-1]:,.0f}\", f\"{btc_change:+.1f}%\")\n                st.markdown(crypto_sentiment)\n        except:\n            st.metric(\"Crypto Sentiment\", \"N/A\")\n    \n    with col3:\n        # Commodity sentiment (Gold)\n        try:\n            gold = yf.Ticker(\"GC=F\")\n            gold_data = gold.history(period=\"5d\")\n            \n            if not gold_data.empty:\n                gold_change = ((gold_data['Close'].iloc[-1] - gold_data['Close'].iloc[-5]) / gold_data['Close'].iloc[-5]) * 100\n                \n                if gold_change > 2:\n                    commodity_sentiment = \"ü•á Safe Haven Demand\"\n                elif gold_change < -2:\n                    commodity_sentiment = \"üìâ Risk-On Mode\"\n                else:\n                    commodity_sentiment = \"‚û°Ô∏è Stable Commodities\"\n                \n                st.metric(\"Gold Sentiment\", f\"${gold_data['Close'].iloc[-1]:,.0f}\", f\"{gold_change:+.1f}%\")\n                st.markdown(commodity_sentiment)\n        except:\n            st.metric(\"Gold Sentiment\", \"N/A\")\n    \n    with col4:\n        # Dollar strength\n        try:\n            dxy = yf.Ticker(\"DX-Y.NYB\")\n            dxy_data = dxy.history(period=\"5d\")\n            \n            if not dxy_data.empty:\n                dxy_change = ((dxy_data['Close'].iloc[-1] - dxy_data['Close'].iloc[-5]) / dxy_data['Close'].iloc[-5]) * 100\n                \n                if dxy_change > 1:\n                    dollar_sentiment = \"üí™ Strong Dollar\"\n                elif dxy_change < -1:\n                    dollar_sentiment = \"üìâ Weak Dollar\"\n                else:\n                    dollar_sentiment = \"‚û°Ô∏è Stable Dollar\"\n                \n                st.metric(\"Dollar Index\", f\"{dxy_data['Close'].iloc[-1]:.2f}\", f\"{dxy_change:+.2f}%\")\n                st.markdown(dollar_sentiment)\n        except:\n            st.metric(\"Dollar Index\", \"N/A\")\n    \n    # Market heat map visualization\n    display_market_heatmap()\n\ndef display_market_heatmap():\n    \"\"\"Display market heat map visualization\"\"\"\n    \n    st.subheader(\"üó∫Ô∏è Market Heat Map\")\n    \n    try:\n        # Get data for major indices and sectors\n        symbols = [\"^GSPC\", \"^IXIC\", \"^DJI\", \"^RUT\", \"XLK\", \"XLF\", \"XLE\", \"XLV\", \"XLI\", \"XLC\"]\n        names = [\"S&P 500\", \"NASDAQ\", \"DOW\", \"Russell 2000\", \"Technology\", \"Financial\", \"Energy\", \"Healthcare\", \"Industrial\", \"Communication\"]\n        \n        heatmap_data = []\n        \n        for symbol, name in zip(symbols, names):\n            try:\n                ticker = yf.Ticker(symbol)\n                data = ticker.history(period=\"1d\")\n                if not data.empty:\n                    change_pct = ((data['Close'].iloc[-1] - data['Close'].iloc[0]) / data['Close'].iloc[0]) * 100\n                    heatmap_data.append({\n                        'Symbol': symbol,\n                        'Name': name,\n                        'Change %': change_pct,\n                        'Color': 'green' if change_pct >= 0 else 'red'\n                    })\n            except:\n                continue\n        \n        if heatmap_data:\n            df = pd.DataFrame(heatmap_data)\n            \n            # Create color-coded metrics\n            cols = st.columns(min(5, len(heatmap_data)))\n            for i, row in df.iterrows():\n                col_idx = i % 5\n                with cols[col_idx]:\n                    color = \"#00AA00\" if row['Change %'] >= 0 else \"#AA0000\"\n                    st.markdown(f\"**{row['Name']}**\")\n                    st.markdown(f\"<div style='color: {color}; font-weight: bold'>{row['Change %']:+.2f}%</div>\", \n                               unsafe_allow_html=True)\n    except:\n        st.info(\"Market heat map temporarily unavailable\")\n\ndef display_fallback_news():\n    \"\"\"Enhanced fallback news when RSS feeds fail\"\"\"\n    st.info(\"üì∞ Live news feeds are temporarily unavailable. Here are key market areas to monitor:\")\n    \n    fallback_topics = [\n        \"üìà **Federal Reserve Policy** - FOMC meetings and interest rate decisions affect all markets\",\n        \"üìä **Earnings Season** - Quarterly reports from major corporations drive individual stock performance\", \n        \"üåç **Geopolitical Events** - Global tensions, trade wars, and political developments impact market volatility\",\n        \"üí± **Currency Markets** - USD strength affects international trade, emerging markets, and commodity prices\",\n        \"üõ¢Ô∏è **Energy & Commodities** - Oil prices, gold movements, and agricultural commodity trends affect inflation\",\n        \"üè¢ **Economic Data** - GDP growth, employment numbers, inflation reports drive market sentiment\",\n        \"üíª **Technology Sector** - AI developments, regulatory changes, and innovation cycles affect growth stocks\",\n        \"üè¶ **Financial System** - Banking sector health, credit conditions, and regulatory changes\",\n        \"üè† **Real Estate** - Housing market data affects REITs, construction, and consumer spending patterns\",\n        \"üå± **ESG & Climate** - Environmental regulations and sustainability trends increasingly impact valuations\",\n        \"‚Çø **Cryptocurrency** - Digital asset adoption, regulation, and institutional investment trends\",\n        \"üî¨ **Biotech & Healthcare** - Drug approvals, clinical trials, and healthcare policy developments\"\n    ]\n    \n    for topic in fallback_topics:\n        st.markdown(topic)\n        st.markdown(\"\")\n    \n    # Add market monitoring tips\n    st.subheader(\"üí° Market Monitoring Tips\")\n    st.markdown(\"\"\"\n    **Key Times to Watch:**\n    - üìÖ **Pre-market (4:00-9:30 AM ET)** - Overnight developments and earnings releases\n    - üîî **Market Open (9:30 AM ET)** - Initial reaction to news and overnight events  \n    - üìä **2:00 PM ET** - FOMC announcements and economic data releases\n    - üåÖ **After Hours (4:00-8:00 PM ET)** - Earnings calls and corporate announcements\n    - üåè **Overnight** - Asian and European market movements affect US pre-market\n    \n    **Reliable News Sources:**\n    - Bloomberg Terminal, Reuters, MarketWatch for breaking financial news\n    - Company investor relations pages for official announcements\n    - Federal Reserve and Treasury websites for policy updates\n    - SEC filings (10-K, 10-Q, 8-K) for detailed company information\n    \"\"\")\n\n# Mark task as completed and move to next one","size_bytes":31902},"modules/options.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nfrom scipy.stats import norm\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\n\ndef display_options():\n    \"\"\"Display options chain and derivatives pricing section\"\"\"\n    \n    st.subheader(\"üìä Options Chain & Derivatives Pricing\")\n    \n    # Symbol input\n    col1, col2, col3 = st.columns([2, 1, 1])\n    \n    with col1:\n        symbol = st.text_input(\"Stock Symbol for Options\", value=\"AAPL\", placeholder=\"e.g., AAPL, TSLA, SPY\")\n    \n    with col2:\n        option_type = st.selectbox(\"Option Type\", [\"calls\", \"puts\", \"both\"])\n    \n    with col3:\n        refresh_data = st.button(\"üîÑ Refresh Options Data\")\n    \n    if symbol:\n        try:\n            # Get ticker object\n            ticker = yf.Ticker(symbol.upper())\n            \n            # Get current stock price (try fast_info first for more recent data)\n            try:\n                current_price = ticker.fast_info.get('lastPrice')\n                if current_price is None or current_price <= 0:\n                    raise ValueError(\"No fast_info price available\")\n                price_source = \"Near real-time\"\n            except:\n                # Fallback to historical data\n                hist = ticker.history(period=\"1d\")\n                if not hist.empty:\n                    current_price = hist['Close'].iloc[-1]\n                    price_source = \"Previous close (delayed)\"\n                else:\n                    current_price = 100  # fallback\n                    price_source = \"Estimate\"\n            \n            st.metric(f\"{symbol.upper()} Current Price\", f\"${current_price:.2f}\", help=f\"Source: {price_source}\")\n            \n            # Get options expiration dates\n            try:\n                expirations = ticker.options\n                if expirations:\n                    selected_exp = st.selectbox(\"Select Expiration Date\", expirations)\n                    \n                    # Get options chain for selected expiration\n                    options_chain = ticker.option_chain(selected_exp)\n                    \n                    if option_type in [\"calls\", \"both\"]:\n                        st.subheader(\"üìà Call Options\")\n                        display_options_table(options_chain.calls, \"calls\", current_price, selected_exp)\n                    \n                    if option_type in [\"puts\", \"both\"]:\n                        st.subheader(\"üìâ Put Options\")\n                        display_options_table(options_chain.puts, \"puts\", current_price, selected_exp)\n                    \n                    # Options analytics section\n                    st.subheader(\"üßÆ Options Analytics & Pricing Models\")\n                    \n                    # Black-Scholes calculator\n                    display_black_scholes_calculator(current_price, selected_exp)\n                    \n                    # Options Greeks analysis\n                    if option_type in [\"calls\", \"both\"] and not options_chain.calls.empty:\n                        display_greeks_analysis(options_chain.calls, \"calls\", current_price, selected_exp)\n                    \n                    if option_type in [\"puts\", \"both\"] and not options_chain.puts.empty:\n                        display_greeks_analysis(options_chain.puts, \"puts\", current_price, selected_exp)\n                    \n                    # Volatility analysis\n                    display_volatility_analysis(symbol.upper(), current_price)\n                    \n                else:\n                    st.warning(f\"No options data available for {symbol.upper()}. This could be because:\")\n                    st.write(\"‚Ä¢ The stock doesn't have listed options\")\n                    st.write(\"‚Ä¢ The symbol is incorrect\")\n                    st.write(\"‚Ä¢ Options data is not available through the current data provider\")\n                    \n                    # Show Black-Scholes calculator anyway\n                    st.subheader(\"üßÆ Black-Scholes Options Pricing Calculator\")\n                    display_black_scholes_calculator(current_price, None)\n                    \n            except Exception as e:\n                st.error(f\"Error fetching options data: {str(e)}\")\n                st.info(\"Showing Black-Scholes calculator with manual inputs\")\n                display_black_scholes_calculator(current_price, None)\n                \n        except Exception as e:\n            st.error(f\"Error fetching data for {symbol}: {str(e)}\")\n\ndef display_options_table(options_df, option_type, current_price, expiration):\n    \"\"\"Display options data in a formatted table\"\"\"\n    \n    if options_df.empty:\n        st.warning(f\"No {option_type} options available for this expiration\")\n        return\n    \n    # Calculate additional metrics\n    options_df = options_df.copy()\n    \n    # Calculate moneyness\n    if option_type == \"calls\":\n        options_df['Moneyness'] = current_price / options_df['strike']\n        options_df['Intrinsic Value'] = np.maximum(current_price - options_df['strike'], 0)\n    else:\n        options_df['Moneyness'] = options_df['strike'] / current_price\n        options_df['Intrinsic Value'] = np.maximum(options_df['strike'] - current_price, 0)\n    \n    # Calculate time value\n    options_df['Time Value'] = options_df['lastPrice'] - options_df['Intrinsic Value']\n    \n    # Format columns for display\n    display_df = options_df[['strike', 'lastPrice', 'bid', 'ask', 'volume', 'openInterest', \n                           'impliedVolatility', 'Intrinsic Value', 'Time Value', 'Moneyness']].copy()\n    \n    # Round numeric columns\n    numeric_columns = ['lastPrice', 'bid', 'ask', 'impliedVolatility', 'Intrinsic Value', 'Time Value', 'Moneyness']\n    for col in numeric_columns:\n        if col in display_df.columns:\n            display_df[col] = display_df[col].round(4)\n    \n    # Style the dataframe\n    def highlight_itm(row):\n        \"\"\"Highlight in-the-money options\"\"\"\n        if option_type == \"calls\" and row['strike'] < current_price:\n            return ['background-color: rgba(0, 255, 0, 0.1)'] * len(row)\n        elif option_type == \"puts\" and row['strike'] > current_price:\n            return ['background-color: rgba(0, 255, 0, 0.1)'] * len(row)\n        return [''] * len(row)\n    \n    styled_df = display_df.style.apply(highlight_itm, axis=1)\n    \n    st.dataframe(styled_df, use_container_width=True)\n    \n    # Options chain visualization\n    if len(options_df) > 0:\n        st.subheader(f\"üìä {option_type.title()} Options Visualization\")\n        \n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=(\n                'Volume by Strike', 'Open Interest by Strike',\n                'Implied Volatility by Strike', 'Time Value by Strike'\n            ),\n            specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n                   [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n        )\n        \n        # Volume\n        fig.add_trace(\n            go.Bar(x=options_df['strike'], y=options_df['volume'], \n                   name='Volume', marker_color='blue'),\n            row=1, col=1\n        )\n        \n        # Open Interest\n        fig.add_trace(\n            go.Bar(x=options_df['strike'], y=options_df['openInterest'], \n                   name='Open Interest', marker_color='orange'),\n            row=1, col=2\n        )\n        \n        # Implied Volatility\n        fig.add_trace(\n            go.Scatter(x=options_df['strike'], y=options_df['impliedVolatility'], \n                      mode='lines+markers', name='IV', line=dict(color='red')),\n            row=2, col=1\n        )\n        \n        # Time Value\n        fig.add_trace(\n            go.Scatter(x=options_df['strike'], y=options_df['Time Value'], \n                      mode='lines+markers', name='Time Value', line=dict(color='green')),\n            row=2, col=2\n        )\n        \n        # Add vertical line for current price\n        fig.add_vline(x=current_price, line_dash=\"dash\", line_color=\"black\", \n                     annotation_text=f\"Current: ${current_price:.2f}\")\n        \n        fig.update_layout(\n            title=f\"{option_type.title()} Options Analysis\",\n            template=\"plotly_dark\",\n            height=600,\n            showlegend=False\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n\ndef display_black_scholes_calculator(current_price, expiration):\n    \"\"\"Display Black-Scholes options pricing calculator\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"**Option Parameters:**\")\n        \n        # Calculate days to expiration if expiration date is provided\n        if expiration:\n            exp_date = datetime.strptime(expiration, \"%Y-%m-%d\")\n            days_to_exp = (exp_date - datetime.now()).days\n            default_time = max(days_to_exp / 365.0, 0.01)  # Convert to years\n        else:\n            default_time = 0.25  # 3 months default\n        \n        spot_price = st.number_input(\"Current Stock Price ($)\", value=float(current_price), min_value=0.01)\n        strike_price = st.number_input(\"Strike Price ($)\", value=float(current_price), min_value=0.01)\n        time_to_exp = st.number_input(\"Time to Expiration (Years)\", value=default_time, min_value=0.001, max_value=10.0)\n        volatility = st.number_input(\"Implied Volatility (%)\", value=25.0, min_value=0.1, max_value=200.0) / 100\n        risk_free_rate = st.number_input(\"Risk-Free Rate (%)\", value=5.0, min_value=0.0, max_value=20.0) / 100\n        dividend_yield = st.number_input(\"Dividend Yield (%)\", value=0.0, min_value=0.0, max_value=20.0) / 100\n    \n    with col2:\n        st.markdown(\"**Calculated Prices & Greeks:**\")\n        \n        # Calculate Black-Scholes prices\n        call_price, put_price = black_scholes_price(spot_price, strike_price, time_to_exp, \n                                                   risk_free_rate, volatility, dividend_yield)\n        \n        # Calculate Greeks\n        greeks = calculate_greeks(spot_price, strike_price, time_to_exp, \n                                risk_free_rate, volatility, dividend_yield)\n        \n        # Display results\n        col2a, col2b = st.columns(2)\n        \n        with col2a:\n            st.metric(\"Call Price\", f\"${call_price:.4f}\")\n            st.metric(\"Delta (Call)\", f\"{greeks['call_delta']:.4f}\")\n            st.metric(\"Gamma\", f\"{greeks['gamma']:.4f}\")\n            st.metric(\"Vega\", f\"{greeks['vega']:.4f}\")\n        \n        with col2b:\n            st.metric(\"Put Price\", f\"${put_price:.4f}\")\n            st.metric(\"Delta (Put)\", f\"{greeks['put_delta']:.4f}\")\n            st.metric(\"Theta (Put)\", f\"{greeks['put_theta']:.4f}\")\n            st.metric(\"Rho (Put)\", f\"{greeks['put_rho']:.4f}\")\n    \n    # Payoff and P&L diagrams\n    st.subheader(\"üìà Option Payoff & P&L Diagrams\")\n    \n    # Create payoff diagram\n    spot_range = np.linspace(spot_price * 0.7, spot_price * 1.3, 100)\n    \n    call_payoffs = np.maximum(spot_range - strike_price, 0)\n    put_payoffs = np.maximum(strike_price - spot_range, 0)\n    \n    # P&L including premium (cost of option)\n    call_pnl = call_payoffs - call_price\n    put_pnl = put_payoffs - put_price\n    \n    # Current option values across price range\n    call_values = []\n    put_values = []\n    \n    for s in spot_range:\n        c, p = black_scholes_price(s, strike_price, time_to_exp, risk_free_rate, volatility, dividend_yield)\n        call_values.append(c)\n        put_values.append(p)\n    \n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=('Call Option Payoff', 'Put Option Payoff', 'Call P&L (incl. Premium)', 'Put P&L (incl. Premium)')\n    )\n    \n    # Call option payoff\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=call_payoffs, mode='lines', \n                  name='Expiration Payoff', line=dict(color='blue', dash='dash')),\n        row=1, col=1\n    )\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=call_values, mode='lines', \n                  name='Current Value', line=dict(color='red')),\n        row=1, col=1\n    )\n    \n    # Put option payoff\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=put_payoffs, mode='lines', \n                  name='Expiration Payoff', line=dict(color='blue', dash='dash'), showlegend=False),\n        row=1, col=2\n    )\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=put_values, mode='lines', \n                  name='Current Value', line=dict(color='red'), showlegend=False),\n        row=1, col=2\n    )\n    \n    # Call P&L with premium\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=call_pnl, mode='lines', \n                  name='P&L at Expiration', line=dict(color='green')),\n        row=2, col=1\n    )\n    \n    # Put P&L with premium\n    fig.add_trace(\n        go.Scatter(x=spot_range, y=put_pnl, mode='lines', \n                  name='P&L at Expiration', line=dict(color='green'), showlegend=False),\n        row=2, col=2\n    )\n    \n    # Add breakeven lines\n    call_breakeven = strike_price + call_price\n    put_breakeven = strike_price - put_price\n    \n    # Add vertical lines for current price, strike, and breakeven\n    for row in [1, 2]:\n        for col in [1, 2]:\n            fig.add_vline(x=spot_price, line_dash=\"dot\", line_color=\"gray\", \n                         annotation_text=f\"Current: ${spot_price:.2f}\", row=row, col=col)\n            fig.add_vline(x=strike_price, line_dash=\"dot\", line_color=\"orange\", \n                         annotation_text=f\"Strike: ${strike_price:.2f}\", row=row, col=col)\n    \n    # Add breakeven lines to P&L charts\n    fig.add_vline(x=call_breakeven, line_dash=\"dot\", line_color=\"purple\", \n                 annotation_text=f\"BE: ${call_breakeven:.2f}\", row=2, col=1)\n    fig.add_vline(x=put_breakeven, line_dash=\"dot\", line_color=\"purple\", \n                 annotation_text=f\"BE: ${put_breakeven:.2f}\", row=2, col=2)\n    \n    # Add horizontal zero line for P&L charts\n    fig.add_hline(y=0, line_dash=\"solid\", line_color=\"white\", row=2, col=1)\n    fig.add_hline(y=0, line_dash=\"solid\", line_color=\"white\", row=2, col=2)\n    \n    fig.update_layout(\n        title=\"Option Payoff & P&L Analysis\",\n        template=\"plotly_dark\",\n        height=600,\n        showlegend=True\n    )\n    \n    fig.update_xaxes(title_text=\"Stock Price ($)\")\n    fig.update_yaxes(title_text=\"Option Value ($)\", row=1)\n    fig.update_yaxes(title_text=\"P&L ($)\", row=2)\n    \n    st.plotly_chart(fig, use_container_width=True)\n    \n    # Display breakeven analysis\n    col1, col2 = st.columns(2)\n    with col1:\n        st.metric(\"Call Breakeven\", f\"${call_breakeven:.2f}\", f\"{((call_breakeven/spot_price - 1)*100):+.2f}%\")\n    with col2:\n        st.metric(\"Put Breakeven\", f\"${put_breakeven:.2f}\", f\"{((put_breakeven/spot_price - 1)*100):+.2f}%\")\n\ndef display_greeks_analysis(options_df, option_type, current_price, expiration):\n    \"\"\"Display Greeks analysis for options\"\"\"\n    \n    if options_df.empty:\n        return\n    \n    st.subheader(f\"üî¢ Greeks Analysis - {option_type.title()}\")\n    \n    # Calculate Greeks for each option (simplified)\n    exp_date = datetime.strptime(expiration, \"%Y-%m-%d\")\n    time_to_exp = max((exp_date - datetime.now()).days / 365.0, 0.001)\n    \n    greeks_data = []\n    \n    for _, option in options_df.iterrows():\n        if pd.notna(option['impliedVolatility']) and option['impliedVolatility'] > 0:\n            greeks = calculate_greeks(\n                current_price, option['strike'], time_to_exp,\n                0.05, option['impliedVolatility'], 0.0  # Simplified assumptions\n            )\n            \n            greeks_data.append({\n                'Strike': option['strike'],\n                'Delta': greeks['call_delta'] if option_type == \"calls\" else greeks['put_delta'],\n                'Gamma': greeks['gamma'],\n                'Theta': greeks['call_theta'] if option_type == \"calls\" else greeks['put_theta'],\n                'Vega': greeks['vega'],\n                'Volume': option['volume'],\n                'Open Interest': option['openInterest']\n            })\n    \n    if greeks_data:\n        greeks_df = pd.DataFrame(greeks_data)\n        \n        # Create Greeks visualization\n        fig = make_subplots(\n            rows=2, cols=2,\n            subplot_titles=('Delta by Strike', 'Gamma by Strike', 'Theta by Strike', 'Vega by Strike')\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=greeks_df['Strike'], y=greeks_df['Delta'], \n                      mode='lines+markers', name='Delta', line=dict(color='blue')),\n            row=1, col=1\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=greeks_df['Strike'], y=greeks_df['Gamma'], \n                      mode='lines+markers', name='Gamma', line=dict(color='red')),\n            row=1, col=2\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=greeks_df['Strike'], y=greeks_df['Theta'], \n                      mode='lines+markers', name='Theta', line=dict(color='green')),\n            row=2, col=1\n        )\n        \n        fig.add_trace(\n            go.Scatter(x=greeks_df['Strike'], y=greeks_df['Vega'], \n                      mode='lines+markers', name='Vega', line=dict(color='purple')),\n            row=2, col=2\n        )\n        \n        fig.add_vline(x=current_price, line_dash=\"dash\", line_color=\"black\")\n        \n        fig.update_layout(\n            title=f\"{option_type.title()} Greeks Analysis\",\n            template=\"plotly_dark\",\n            height=600,\n            showlegend=False\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n        \n        # Display Greeks table\n        st.dataframe(greeks_df.round(4), use_container_width=True)\n\ndef display_volatility_analysis(symbol, current_price):\n    \"\"\"Display volatility analysis\"\"\"\n    \n    st.subheader(\"üìä Volatility Analysis\")\n    \n    try:\n        # Get historical data for volatility calculation\n        ticker = yf.Ticker(symbol)\n        hist_data = ticker.history(period=\"1y\")\n        \n        if not hist_data.empty:\n            # Calculate historical volatility\n            returns = hist_data['Close'].pct_change().dropna()\n            hist_vol = returns.std() * np.sqrt(252)  # Annualized volatility\n            \n            # Calculate different period volatilities\n            vol_30d = returns.tail(30).std() * np.sqrt(252) if len(returns) >= 30 else hist_vol\n            vol_60d = returns.tail(60).std() * np.sqrt(252) if len(returns) >= 60 else hist_vol\n            vol_90d = returns.tail(90).std() * np.sqrt(252) if len(returns) >= 90 else hist_vol\n            \n            col1, col2, col3, col4 = st.columns(4)\n            \n            with col1:\n                st.metric(\"30-Day Volatility\", f\"{vol_30d*100:.2f}%\")\n            with col2:\n                st.metric(\"60-Day Volatility\", f\"{vol_60d*100:.2f}%\")\n            with col3:\n                st.metric(\"90-Day Volatility\", f\"{vol_90d*100:.2f}%\")\n            with col4:\n                st.metric(\"1-Year Volatility\", f\"{hist_vol*100:.2f}%\")\n            \n            # Volatility chart\n            rolling_vol = returns.rolling(window=30).std() * np.sqrt(252)\n            \n            fig = go.Figure()\n            fig.add_trace(\n                go.Scatter(\n                    x=rolling_vol.index,\n                    y=rolling_vol * 100,\n                    mode='lines',\n                    name='30-Day Rolling Volatility',\n                    line=dict(color='orange')\n                )\n            )\n            \n            fig.update_layout(\n                title=\"Historical Volatility (30-Day Rolling)\",\n                template=\"plotly_dark\",\n                height=300,\n                xaxis_title=\"Date\",\n                yaxis_title=\"Volatility (%)\"\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n        \n        else:\n            st.warning(\"Could not fetch historical data for volatility analysis\")\n            \n    except Exception as e:\n        st.error(f\"Error in volatility analysis: {str(e)}\")\n\ndef black_scholes_price(S, K, T, r, sigma, q=0):\n    \"\"\"\n    Calculate Black-Scholes option prices\n    \n    S: Current stock price\n    K: Strike price\n    T: Time to expiration (years)\n    r: Risk-free rate\n    sigma: Volatility\n    q: Dividend yield\n    \"\"\"\n    try:\n        d1 = (np.log(S/K) + (r - q + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n        d2 = d1 - sigma*np.sqrt(T)\n        \n        call_price = S*np.exp(-q*T)*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)\n        put_price = K*np.exp(-r*T)*norm.cdf(-d2) - S*np.exp(-q*T)*norm.cdf(-d1)\n        \n        return call_price, put_price\n    except Exception as e:\n        return 0, 0\n\ndef calculate_greeks(S, K, T, r, sigma, q=0):\n    \"\"\"\n    Calculate option Greeks\n    \"\"\"\n    try:\n        d1 = (np.log(S/K) + (r - q + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))\n        d2 = d1 - sigma*np.sqrt(T)\n        \n        # Delta\n        call_delta = np.exp(-q*T) * norm.cdf(d1)\n        put_delta = -np.exp(-q*T) * norm.cdf(-d1)\n        \n        # Gamma\n        gamma = np.exp(-q*T) * norm.pdf(d1) / (S * sigma * np.sqrt(T))\n        \n        # Theta (per day) - separate formulas for calls and puts\n        call_theta = (-S*np.exp(-q*T)*norm.pdf(d1)*sigma/(2*np.sqrt(T)) \n                     - r*K*np.exp(-r*T)*norm.cdf(d2) \n                     + q*S*np.exp(-q*T)*norm.cdf(d1)) / 365\n        \n        put_theta = (-S*np.exp(-q*T)*norm.pdf(d1)*sigma/(2*np.sqrt(T)) \n                    + r*K*np.exp(-r*T)*norm.cdf(-d2) \n                    - q*S*np.exp(-q*T)*norm.cdf(-d1)) / 365\n        \n        # Vega (per 1% change in volatility)\n        vega = S * np.exp(-q*T) * norm.pdf(d1) * np.sqrt(T) / 100\n        \n        # Rho (per 1% change in interest rate)\n        call_rho = K * T * np.exp(-r*T) * norm.cdf(d2) / 100\n        put_rho = -K * T * np.exp(-r*T) * norm.cdf(-d2) / 100\n        \n        return {\n            'call_delta': call_delta,\n            'put_delta': put_delta,\n            'gamma': gamma,\n            'call_theta': call_theta,\n            'put_theta': put_theta,\n            'vega': vega,\n            'call_rho': call_rho,\n            'put_rho': put_rho\n        }\n    except Exception as e:\n        return {\n            'call_delta': 0, 'put_delta': 0, 'gamma': 0, 'call_theta': 0, 'put_theta': 0,\n            'vega': 0, 'call_rho': 0, 'put_rho': 0\n        }","size_bytes":22381},"modules/portfolio.py":{"content":"import streamlit as st\nimport pandas as pd\nimport yfinance as yf\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nfrom modules.user_auth import user_auth\n\ndef display_portfolio():\n    \"\"\"Display portfolio management section\"\"\"\n    \n    # Portfolio input section\n    st.subheader(\"‚ûï Add Position\")\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        symbol = st.text_input(\"Symbol\", placeholder=\"e.g., AAPL\")\n    \n    with col2:\n        shares = st.number_input(\"Shares\", min_value=0.0, step=0.1)\n    \n    with col3:\n        purchase_price = st.number_input(\"Purchase Price ($)\", min_value=0.0, step=0.01)\n    \n    with col4:\n        purchase_date = st.date_input(\"Purchase Date\", value=datetime.now().date())\n    \n    if st.button(\"Add Position\"):\n        if symbol and shares > 0 and purchase_price > 0:\n            new_position = {\n                'symbol': symbol.upper(),\n                'shares': shares,\n                'purchase_price': purchase_price,\n                'purchase_date': purchase_date,\n                'purchase_value': shares * purchase_price\n            }\n            \n            # Auto-save to database\n            if user_auth.auto_save_portfolio_position(symbol.upper(), shares, purchase_price, purchase_date):\n                st.session_state.portfolio.append(new_position)\n                st.success(f\"Added {shares} shares of {symbol.upper()} to portfolio\")\n                st.rerun()\n            else:\n                st.error(\"Failed to save position to database\")\n        else:\n            st.error(\"Please fill in all fields with valid values\")\n    \n    # Display current portfolio\n    if st.session_state.portfolio:\n        st.subheader(\"üíº Current Portfolio\")\n        \n        # Calculate portfolio metrics\n        portfolio_data = []\n        total_invested = 0\n        total_current_value = 0\n        \n        for position in st.session_state.portfolio:\n            try:\n                # Get current price\n                ticker = yf.Ticker(position['symbol'])\n                current_data = ticker.history(period=\"1d\")\n                \n                if not current_data.empty:\n                    current_price = current_data['Close'].iloc[-1]\n                    current_value = position['shares'] * current_price\n                    gain_loss = current_value - position['purchase_value']\n                    gain_loss_percent = (gain_loss / position['purchase_value']) * 100\n                    \n                    portfolio_data.append({\n                        'Symbol': position['symbol'],\n                        'Shares': position['shares'],\n                        'Purchase Price': f\"${position['purchase_price']:.2f}\",\n                        'Current Price': f\"${current_price:.2f}\",\n                        'Purchase Value': f\"${position['purchase_value']:.2f}\",\n                        'Current Value': f\"${current_value:.2f}\",\n                        'Gain/Loss': f\"${gain_loss:.2f}\",\n                        'Gain/Loss %': f\"{gain_loss_percent:.2f}%\",\n                        'Purchase Date': position['purchase_date'].strftime(\"%Y-%m-%d\")\n                    })\n                    \n                    total_invested += position['purchase_value']\n                    total_current_value += current_value\n                    \n            except Exception as e:\n                st.error(f\"Error fetching data for {position['symbol']}: {str(e)}\")\n        \n        if portfolio_data:\n            # Portfolio summary metrics\n            total_gain_loss = total_current_value - total_invested\n            total_gain_loss_percent = (total_gain_loss / total_invested) * 100 if total_invested > 0 else 0\n            \n            col1, col2, col3, col4 = st.columns(4)\n            \n            with col1:\n                st.metric(\"Total Invested\", f\"${total_invested:.2f}\")\n            \n            with col2:\n                st.metric(\"Current Value\", f\"${total_current_value:.2f}\")\n            \n            with col3:\n                st.metric(\n                    \"Total Gain/Loss\", \n                    f\"${total_gain_loss:.2f}\",\n                    delta=f\"{total_gain_loss_percent:.2f}%\"\n                )\n            \n            with col4:\n                performance = \"üìà Positive\" if total_gain_loss >= 0 else \"üìâ Negative\"\n                st.metric(\"Performance\", performance)\n            \n            # Portfolio allocation pie chart\n            if len(portfolio_data) > 1:\n                st.subheader(\"üìä Portfolio Allocation\")\n                \n                # Create allocation data\n                allocation_data = []\n                for item in portfolio_data:\n                    allocation_data.append({\n                        'Symbol': item['Symbol'],\n                        'Value': float(item['Current Value'].replace('$', '').replace(',', ''))\n                    })\n                \n                df_allocation = pd.DataFrame(allocation_data)\n                \n                fig = px.pie(\n                    df_allocation, \n                    values='Value', \n                    names='Symbol',\n                    title=\"Portfolio Allocation by Current Value\"\n                )\n                fig.update_layout(template=\"plotly_dark\")\n                st.plotly_chart(fig, use_container_width=True)\n            \n            # Portfolio performance chart\n            st.subheader(\"üìà Portfolio Performance\")\n            \n            # Create performance data for chart\n            performance_data = []\n            for item in portfolio_data:\n                symbol = item['Symbol']\n                gain_loss_str = item['Gain/Loss %'].replace('%', '')\n                gain_loss_percent = float(gain_loss_str)\n                \n                performance_data.append({\n                    'Symbol': symbol,\n                    'Performance': gain_loss_percent\n                })\n            \n            df_performance = pd.DataFrame(performance_data)\n            \n            # Color coding for performance\n            colors = ['green' if x >= 0 else 'red' for x in df_performance['Performance']]\n            \n            fig = go.Figure(data=[\n                go.Bar(\n                    x=df_performance['Symbol'],\n                    y=df_performance['Performance'],\n                    marker_color=colors,\n                    text=[f\"{x:.1f}%\" for x in df_performance['Performance']],\n                    textposition='auto'\n                )\n            ])\n            \n            fig.update_layout(\n                title=\"Individual Stock Performance (%)\",\n                xaxis_title=\"Symbol\",\n                yaxis_title=\"Performance (%)\",\n                template=\"plotly_dark\"\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n            \n            # Portfolio table\n            st.subheader(\"üìã Position Details\")\n            df = pd.DataFrame(portfolio_data)\n            st.dataframe(df, use_container_width=True)\n            \n            # Remove position functionality\n            st.subheader(\"üóëÔ∏è Remove Positions\")\n            col1, col2 = st.columns([3, 1])\n            \n            with col1:\n                symbols_to_remove = [pos['symbol'] for pos in st.session_state.portfolio]\n                symbol_to_remove = st.selectbox(\"Select position to remove\", symbols_to_remove)\n            \n            with col2:\n                if st.button(\"Remove Position\"):\n                    if symbol_to_remove:\n                        # Find and remove the position\n                        for i, position in enumerate(st.session_state.portfolio):\n                            if position['symbol'] == symbol_to_remove:\n                                # Try to remove from database first\n                                from modules.database import db_manager\n                                user_id = user_auth.get_current_user_id()\n                                \n                                if user_id and position.get('id'):\n                                    # Remove from database using position ID\n                                    if db_manager.remove_portfolio_position(user_id, position['id']):\n                                        removed_position = st.session_state.portfolio.pop(i)\n                                        st.success(f\"Removed {removed_position['shares']} shares of {symbol_to_remove}\")\n                                        st.rerun()\n                                        break\n                                    else:\n                                        st.error(\"Failed to remove position from database\")\n                                else:\n                                    # Fallback for positions without ID (legacy)\n                                    removed_position = st.session_state.portfolio.pop(i)\n                                    st.success(f\"Removed {removed_position['shares']} shares of {symbol_to_remove}\")\n                                    st.rerun()\n                                    break\n        \n        # Export portfolio functionality\n        if st.button(\"üìä Export Portfolio Data\"):\n            if portfolio_data:\n                df = pd.DataFrame(portfolio_data)\n                csv = df.to_csv(index=False)\n                st.download_button(\n                    label=\"Download Portfolio CSV\",\n                    data=csv,\n                    file_name=f\"portfolio_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n    else:\n        st.info(\"Your portfolio is empty. Add some positions to get started!\")\n        \n        # Sample portfolio suggestions\n        st.subheader(\"üí° Sample Portfolio Ideas\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.markdown(\"\"\"\n            **Technology Portfolio:**\n            - AAPL (Apple)\n            - GOOGL (Alphabet)\n            - MSFT (Microsoft)\n            - NVDA (NVIDIA)\n            - TSLA (Tesla)\n            \"\"\")\n        \n        with col2:\n            st.markdown(\"\"\"\n            **Diversified Portfolio:**\n            - SPY (S&P 500 ETF)\n            - VTI (Total Stock Market)\n            - BND (Bond ETF)\n            - GLD (Gold ETF)\n            - VEA (International ETF)\n            \"\"\")\n\ndef calculate_portfolio_beta(portfolio_data, benchmark_symbol=\"SPY\"):\n    \"\"\"Calculate portfolio beta relative to benchmark\"\"\"\n    try:\n        # This would require more complex calculations\n        # For now, return a placeholder\n        return 1.0\n    except:\n        return None\n","size_bytes":10650},"modules/profile_manager.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom modules.database import db_manager\nfrom modules.user_auth import user_auth\n\ndef display_profile_management():\n    \"\"\"Display user profile management interface\"\"\"\n    \n    user = user_auth.get_current_user()\n    user_id = user_auth.get_current_user_id()\n    \n    if not user or not user_id:\n        st.error(\"Please login to access profile management\")\n        return\n    \n    st.header(f\"üë§ Profile Management - {user['username']}\")\n    \n    # Profile overview\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        # Portfolio count\n        portfolio_count = len(st.session_state.get('portfolio', []))\n        st.metric(\"Portfolio Positions\", portfolio_count)\n    \n    with col2:\n        # Active alerts count\n        active_alerts = len([a for a in st.session_state.get('alerts', []) if a.get('status') == 'Active'])\n        st.metric(\"Active Alerts\", active_alerts)\n    \n    with col3:\n        # Watchlist size\n        watchlist_size = len(st.session_state.get('watchlist', []))\n        st.metric(\"Watchlist Symbols\", watchlist_size)\n    \n    with col4:\n        # Member since\n        created_date = user['created_at'].strftime('%Y-%m-%d') if user['created_at'] else 'Unknown'\n        st.metric(\"Member Since\", created_date)\n    \n    # Tabs for different profile management sections\n    tab1, tab2, tab3, tab4, tab5 = st.tabs([\n        \"üìä Data Overview\", \n        \"‚öôÔ∏è Preferences\", \n        \"üíæ Data Export\", \n        \"üóëÔ∏è Data Management\", \n        \"üîß Account Settings\"\n    ])\n    \n    with tab1:\n        display_data_overview(user_id)\n    \n    with tab2:\n        display_preferences_management(user_id)\n    \n    with tab3:\n        display_data_export(user_id)\n    \n    with tab4:\n        display_data_management(user_id)\n    \n    with tab5:\n        display_account_settings(user_id, user)\n\ndef display_data_overview(user_id: int):\n    \"\"\"Display overview of user's data\"\"\"\n    \n    st.subheader(\"üìä Your Data Overview\")\n    \n    # Portfolio overview\n    st.markdown(\"### üíº Portfolio Data\")\n    portfolio_data = db_manager.get_user_portfolio(user_id)\n    \n    if portfolio_data:\n        portfolio_df = pd.DataFrame(portfolio_data)\n        portfolio_df['purchase_date'] = pd.to_datetime(portfolio_df['purchase_date'])\n        portfolio_df = portfolio_df.sort_values('created_at', ascending=False)\n        \n        st.dataframe(\n            portfolio_df[['symbol', 'shares', 'purchase_price', 'purchase_value', 'purchase_date']],\n            use_container_width=True\n        )\n    else:\n        st.info(\"No portfolio positions found\")\n    \n    # Alerts overview\n    st.markdown(\"### üö® Alerts Data\")\n    alerts_data = db_manager.get_user_alerts(user_id)\n    \n    if alerts_data:\n        alerts_df = pd.DataFrame(alerts_data)\n        alerts_df['created_at'] = pd.to_datetime(alerts_df['created_at'])\n        \n        # Summary by status\n        status_counts = alerts_df['status'].value_counts()\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\"Active Alerts\", status_counts.get('Active', 0))\n        with col2:\n            st.metric(\"Triggered Alerts\", status_counts.get('Triggered', 0))\n        with col3:\n            st.metric(\"Cancelled Alerts\", status_counts.get('Cancelled', 0))\n        \n        # Recent alerts\n        st.markdown(\"**Recent Alerts:**\")\n        recent_alerts = alerts_df.sort_values('created_at', ascending=False).head(10)\n        st.dataframe(\n            recent_alerts[['alert_name', 'symbol', 'alert_type', 'status', 'created_at']],\n            use_container_width=True\n        )\n    else:\n        st.info(\"No alerts found\")\n    \n    # Watchlist overview\n    st.markdown(\"### üëÅÔ∏è Watchlist Data\")\n    watchlist = db_manager.get_user_watchlist(user_id)\n    \n    if watchlist:\n        st.success(f\"You have {len(watchlist)} symbols in your watchlist:\")\n        watchlist_str = \", \".join(watchlist)\n        st.code(watchlist_str)\n    else:\n        st.info(\"No watchlist symbols found\")\n    \n    # Preferences overview\n    st.markdown(\"### ‚öôÔ∏è Preferences Data\")\n    preferences = db_manager.get_user_preferences(user_id)\n    \n    if preferences:\n        pref_count = sum(len(prefs) for prefs in preferences.values())\n        st.success(f\"You have {pref_count} preferences saved across {len(preferences)} categories\")\n        \n        for pref_type, prefs in preferences.items():\n            with st.expander(f\"{pref_type.title()} Preferences ({len(prefs)} items)\"):\n                for key, value in prefs.items():\n                    st.write(f\"**{key}:** {value}\")\n    else:\n        st.info(\"No preferences found\")\n\ndef display_preferences_management(user_id: int):\n    \"\"\"Display preferences management interface\"\"\"\n    \n    st.subheader(\"‚öôÔ∏è Preferences Management\")\n    \n    # Auto-save settings\n    st.markdown(\"### üíæ Auto-Save Settings\")\n    \n    current_auto_save = st.session_state.get('auto_save_enabled', True)\n    new_auto_save = st.checkbox(\n        \"Enable Auto-Save\", \n        value=current_auto_save,\n        help=\"Automatically save portfolio, alerts, watchlist, and preferences\"\n    )\n    \n    if new_auto_save != current_auto_save:\n        st.session_state.auto_save_enabled = new_auto_save\n        user_auth.auto_save_preference('system', 'auto_save_enabled', new_auto_save)\n        st.success(f\"Auto-save {'enabled' if new_auto_save else 'disabled'}\")\n    \n    # Chart preferences\n    st.markdown(\"### üìà Chart Preferences\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        default_chart_type = user_auth.get_user_preference('charts', 'default_type', 'Candlestick')\n        chart_type = st.selectbox(\n            \"Default Chart Type\",\n            [\"Candlestick\", \"Line\", \"OHLC\"],\n            index=[\"Candlestick\", \"Line\", \"OHLC\"].index(default_chart_type)\n        )\n        \n        if chart_type != default_chart_type:\n            user_auth.auto_save_preference('charts', 'default_type', chart_type)\n            st.success(\"Chart type preference saved\")\n    \n    with col2:\n        default_period = user_auth.get_user_preference('charts', 'default_period', '1y')\n        period = st.selectbox(\n            \"Default Time Period\",\n            [\"1d\", \"5d\", \"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\", \"5y\"],\n            index=[\"1d\", \"5d\", \"1mo\", \"3mo\", \"6mo\", \"1y\", \"2y\", \"5y\"].index(default_period)\n        )\n        \n        if period != default_period:\n            user_auth.auto_save_preference('charts', 'default_period', period)\n            st.success(\"Time period preference saved\")\n    \n    # Technical indicators preferences\n    st.markdown(\"### üîç Technical Indicators\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        show_ma = st.checkbox(\n            \"Show Moving Averages by default\",\n            value=user_auth.get_user_preference('indicators', 'default_ma', True)\n        )\n        user_auth.auto_save_preference('indicators', 'default_ma', show_ma)\n    \n    with col2:\n        show_bb = st.checkbox(\n            \"Show Bollinger Bands by default\",\n            value=user_auth.get_user_preference('indicators', 'default_bb', False)\n        )\n        user_auth.auto_save_preference('indicators', 'default_bb', show_bb)\n    \n    with col3:\n        show_rsi = st.checkbox(\n            \"Show RSI by default\",\n            value=user_auth.get_user_preference('indicators', 'default_rsi', False)\n        )\n        user_auth.auto_save_preference('indicators', 'default_rsi', show_rsi)\n    \n    # Notification preferences\n    st.markdown(\"### üîî Notification Preferences\")\n    \n    default_notifications = user_auth.get_user_preference('notifications', 'default_methods', ['Browser Notification'])\n    notification_methods = st.multiselect(\n        \"Default Notification Methods\",\n        [\"Browser Notification\", \"Email\", \"SMS\"],\n        default=default_notifications\n    )\n    \n    if notification_methods != default_notifications:\n        user_auth.auto_save_preference('notifications', 'default_methods', notification_methods)\n        st.success(\"Notification preferences saved\")\n\ndef display_data_export(user_id: int):\n    \"\"\"Display data export functionality\"\"\"\n    \n    st.subheader(\"üíæ Data Export\")\n    \n    st.markdown(\"Export your data for backup or analysis purposes:\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"üìä Export Portfolio Data\", use_container_width=True):\n            portfolio_data = db_manager.get_user_portfolio(user_id)\n            if portfolio_data:\n                df = pd.DataFrame(portfolio_data)\n                csv = df.to_csv(index=False)\n                st.download_button(\n                    label=\"Download Portfolio CSV\",\n                    data=csv,\n                    file_name=f\"portfolio_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n            else:\n                st.warning(\"No portfolio data to export\")\n    \n    with col2:\n        if st.button(\"üö® Export Alerts Data\", use_container_width=True):\n            alerts_data = db_manager.get_user_alerts(user_id)\n            if alerts_data:\n                # Convert to DataFrame and handle JSON fields\n                df = pd.DataFrame(alerts_data)\n                df['notification_methods'] = df['notification_methods'].apply(\n                    lambda x: ', '.join(x) if isinstance(x, list) else str(x)\n                )\n                csv = df.to_csv(index=False)\n                st.download_button(\n                    label=\"Download Alerts CSV\",\n                    data=csv,\n                    file_name=f\"alerts_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n            else:\n                st.warning(\"No alerts data to export\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"üëÅÔ∏è Export Watchlist\", use_container_width=True):\n            watchlist = db_manager.get_user_watchlist(user_id)\n            if watchlist:\n                watchlist_text = '\\n'.join(watchlist)\n                st.download_button(\n                    label=\"Download Watchlist TXT\",\n                    data=watchlist_text,\n                    file_name=f\"watchlist_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt\",\n                    mime=\"text/plain\"\n                )\n            else:\n                st.warning(\"No watchlist data to export\")\n    \n    with col2:\n        if st.button(\"‚öôÔ∏è Export Preferences\", use_container_width=True):\n            preferences = db_manager.get_user_preferences(user_id)\n            if preferences:\n                import json\n                prefs_json = json.dumps(preferences, indent=2, default=str)\n                st.download_button(\n                    label=\"Download Preferences JSON\",\n                    data=prefs_json,\n                    file_name=f\"preferences_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\",\n                    mime=\"application/json\"\n                )\n            else:\n                st.warning(\"No preferences data to export\")\n\ndef display_data_management(user_id: int):\n    \"\"\"Display data management functionality\"\"\"\n    \n    st.subheader(\"üóëÔ∏è Data Management\")\n    \n    st.warning(\"‚ö†Ô∏è **Warning:** These actions cannot be undone. Please export your data first if needed.\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"### Clear Individual Data Types\")\n        \n        if st.button(\"üóëÔ∏è Clear Portfolio\", use_container_width=True):\n            if st.session_state.get('confirm_clear_portfolio'):\n                if db_manager.clear_user_portfolio(user_id):\n                    st.session_state.portfolio = []\n                    st.success(\"Portfolio cleared successfully\")\n                    st.session_state.confirm_clear_portfolio = False\n                    st.rerun()\n            else:\n                st.session_state.confirm_clear_portfolio = True\n                st.warning(\"Click again to confirm clearing portfolio\")\n        \n        if st.button(\"üóëÔ∏è Clear Alerts\", use_container_width=True):\n            if st.session_state.get('confirm_clear_alerts'):\n                if db_manager.clear_user_alerts(user_id):\n                    st.session_state.alerts = []\n                    st.session_state.alert_history = []\n                    st.success(\"Alerts cleared successfully\")\n                    st.session_state.confirm_clear_alerts = False\n                    st.rerun()\n            else:\n                st.session_state.confirm_clear_alerts = True\n                st.warning(\"Click again to confirm clearing alerts\")\n    \n    with col2:\n        st.markdown(\"### Manual Data Sync\")\n        \n        if st.button(\"üîÑ Reload Data from Database\", use_container_width=True):\n            user_auth.load_user_data()\n            st.success(\"Data reloaded from database\")\n            st.rerun()\n        \n        if st.button(\"üíæ Force Save Current State\", use_container_width=True):\n            user_auth.save_current_state()\n            st.success(\"Current state saved to database\")\n\ndef display_account_settings(user_id: int, user: dict):\n    \"\"\"Display account settings\"\"\"\n    \n    st.subheader(\"üîß Account Settings\")\n    \n    # Account information\n    st.markdown(\"### üë§ Account Information\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.text_input(\"Username\", value=user['username'], disabled=True)\n        st.text_input(\"User ID\", value=str(user['id']), disabled=True)\n    \n    with col2:\n        created_at = user['created_at'].strftime('%Y-%m-%d %H:%M:%S') if user['created_at'] else 'Unknown'\n        st.text_input(\"Account Created\", value=created_at, disabled=True)\n        \n        last_login = user['last_login'].strftime('%Y-%m-%d %H:%M:%S') if user.get('last_login') else 'Never'\n        st.text_input(\"Last Login\", value=last_login, disabled=True)\n    \n    # Account actions\n    st.markdown(\"### ‚öôÔ∏è Account Actions\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"üîÑ Refresh Account Data\", use_container_width=True):\n            # Reload user data\n            fresh_user = db_manager.get_user(user['username'])\n            if fresh_user:\n                st.session_state.user_data = fresh_user\n                st.success(\"Account data refreshed\")\n                st.rerun()\n    \n    with col2:\n        if st.button(\"üö™ Logout\", use_container_width=True):\n            user_auth.logout_user()\n    \n    # Data storage information\n    st.markdown(\"### üìä Data Storage Statistics\")\n    \n    # Get storage stats\n    portfolio_count = len(db_manager.get_user_portfolio(user_id))\n    alerts_count = len(db_manager.get_user_alerts(user_id))\n    watchlist_count = len(db_manager.get_user_watchlist(user_id))\n    preferences = db_manager.get_user_preferences(user_id)\n    preferences_count = sum(len(prefs) for prefs in preferences.values())\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Portfolio Positions\", portfolio_count)\n    with col2:\n        st.metric(\"Total Alerts\", alerts_count)\n    with col3:\n        st.metric(\"Watchlist Symbols\", watchlist_count)\n    with col4:\n        st.metric(\"Saved Preferences\", preferences_count)","size_bytes":15360},"modules/risk_management.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nfrom datetime import datetime, timedelta\nfrom scipy import stats\nfrom scipy.optimize import minimize\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndef display_risk_management():\n    \"\"\"Display risk management tools and analytics\"\"\"\n    \n    st.subheader(\"‚ö†Ô∏è Risk Management & Portfolio Analytics\")\n    \n    # Portfolio input section\n    st.markdown(\"### üìä Portfolio Configuration\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        portfolio_input = st.text_area(\n            \"Enter Portfolio Holdings (Symbol:Weight, one per line)\",\n            value=\"AAPL:0.3\\nMSFT:0.25\\nGOOGL:0.2\\nTSLA:0.15\\nNVDA:0.1\",\n            help=\"Format: SYMBOL:WEIGHT (weights should sum to 1.0)\"\n        )\n        \n        # Parse portfolio\n        portfolio = parse_portfolio_input(portfolio_input)\n        \n        if portfolio:\n            st.success(f\"Portfolio loaded: {len(portfolio)} assets, Total weight: {sum(portfolio.values()):.2%}\")\n            \n            # Display portfolio composition\n            portfolio_df = pd.DataFrame(list(portfolio.items()), columns=['Symbol', 'Weight'])\n            portfolio_df['Weight'] = portfolio_df['Weight'].apply(lambda x: f\"{x:.1%}\")\n            st.dataframe(portfolio_df, use_container_width=True)\n        else:\n            st.error(\"Invalid portfolio format. Please check your input.\")\n            return\n    \n    with col2:\n        portfolio_value = st.number_input(\"Portfolio Value ($)\", value=100000, min_value=1000, step=1000)\n        confidence_level = st.selectbox(\"Confidence Level\", [0.90, 0.95, 0.99], index=1)\n        time_horizon = st.selectbox(\"Time Horizon (Days)\", [1, 5, 10, 22], index=0)\n        \n        lookback_period = st.selectbox(\"Historical Data Period\", \n                                     [\"1y\", \"2y\", \"3y\", \"5y\"], index=1)\n        \n        # Risk-free rate for calculations\n        risk_free_rate = st.number_input(\"Risk-Free Rate (%)\", value=5.0, min_value=0.0, max_value=20.0) / 100\n    \n    # Fetch data and calculate metrics\n    if st.button(\"üîÑ Calculate Risk Metrics\", type=\"primary\"):\n        with st.spinner(\"Fetching data and calculating risk metrics...\"):\n            data = fetch_portfolio_data(list(portfolio.keys()), lookback_period)\n            \n            if data is not None and not data.empty:\n                # Calculate portfolio returns\n                portfolio_returns = calculate_portfolio_returns(data, portfolio)\n                \n                # Display risk metrics\n                display_var_analysis(portfolio_returns, portfolio_value, confidence_level, time_horizon)\n                \n                # Display correlation analysis\n                display_correlation_analysis(data, portfolio)\n                \n                # Display stress testing\n                display_stress_testing(portfolio_returns, portfolio_value, data, portfolio)\n                \n                # Display portfolio optimization\n                display_portfolio_optimization(data, portfolio, risk_free_rate)\n                \n                # Display risk decomposition\n                display_risk_decomposition(data, portfolio)\n                \n            else:\n                st.error(\"Could not fetch data for the specified portfolio. Please check the symbols.\")\n\ndef parse_portfolio_input(portfolio_input):\n    \"\"\"Parse portfolio input string into dictionary\"\"\"\n    \n    try:\n        portfolio = {}\n        lines = portfolio_input.strip().split('\\n')\n        \n        for line in lines:\n            if ':' in line:\n                symbol, weight = line.strip().split(':')\n                portfolio[symbol.strip().upper()] = float(weight.strip())\n        \n        # Validate weights\n        total_weight = sum(portfolio.values())\n        if abs(total_weight - 1.0) > 0.01:  # Allow small rounding errors\n            st.warning(f\"Portfolio weights sum to {total_weight:.2%}, consider adjusting to 100%\")\n        \n        return portfolio\n        \n    except Exception as e:\n        return None\n\ndef fetch_portfolio_data(symbols, period):\n    \"\"\"Fetch historical data for portfolio symbols\"\"\"\n    \n    try:\n        data = {}\n        for symbol in symbols:\n            ticker = yf.Ticker(symbol)\n            hist = ticker.history(period=period)\n            \n            if not hist.empty:\n                # Use Adjusted Close for accurate returns\n                data[symbol] = hist['Adj Close']\n            else:\n                st.warning(f\"No data found for {symbol}\")\n        \n        if data:\n            # Combine into DataFrame and forward fill missing values\n            df = pd.DataFrame(data)\n            df = df.fillna(method='ffill').dropna()\n            return df\n        \n        return None\n        \n    except Exception as e:\n        st.error(f\"Error fetching data: {str(e)}\")\n        return None\n\ndef calculate_portfolio_returns(data, portfolio):\n    \"\"\"Calculate portfolio returns based on weights\"\"\"\n    \n    # Calculate daily returns\n    returns = data.pct_change().dropna()\n    \n    # Calculate weighted portfolio returns\n    portfolio_returns = pd.Series(0, index=returns.index)\n    \n    for symbol, weight in portfolio.items():\n        if symbol in returns.columns:\n            portfolio_returns += returns[symbol] * weight\n    \n    return portfolio_returns\n\ndef display_var_analysis(portfolio_returns, portfolio_value, confidence_level, time_horizon):\n    \"\"\"Display Value at Risk analysis\"\"\"\n    \n    st.subheader(\"üìâ Value at Risk (VaR) Analysis\")\n    \n    # Calculate different VaR methods\n    historical_var = calculate_historical_var(portfolio_returns, confidence_level, time_horizon)\n    parametric_var = calculate_parametric_var(portfolio_returns, confidence_level, time_horizon)\n    \n    # Convert to dollar amounts\n    historical_var_dollar = historical_var * portfolio_value\n    parametric_var_dollar = parametric_var * portfolio_value\n    \n    # Expected Shortfall (Conditional VaR)\n    expected_shortfall = calculate_expected_shortfall(portfolio_returns, confidence_level, time_horizon)\n    expected_shortfall_dollar = expected_shortfall * portfolio_value\n    \n    # Display metrics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\n            f\"Historical VaR ({confidence_level:.0%})\", \n            f\"${historical_var_dollar:,.0f}\",\n            f\"{historical_var:.2%}\"\n        )\n    \n    with col2:\n        st.metric(\n            f\"Parametric VaR ({confidence_level:.0%})\", \n            f\"${parametric_var_dollar:,.0f}\",\n            f\"{parametric_var:.2%}\"\n        )\n    \n    with col3:\n        st.metric(\n            f\"Expected Shortfall ({confidence_level:.0%})\", \n            f\"${expected_shortfall_dollar:,.0f}\",\n            f\"{expected_shortfall:.2%}\"\n        )\n    \n    with col4:\n        volatility = portfolio_returns.std() * np.sqrt(252)\n        st.metric(\"Annual Volatility\", f\"{volatility:.2%}\")\n    \n    # VaR visualization\n    fig = make_subplots(\n        rows=2, cols=2,\n        subplot_titles=('Portfolio Returns Distribution', 'Historical VaR', 'Rolling VaR (30-day)', 'Risk Metrics Timeline'),\n        specs=[[{\"secondary_y\": False}, {\"secondary_y\": False}],\n               [{\"secondary_y\": False}, {\"secondary_y\": False}]]\n    )\n    \n    # Returns distribution\n    fig.add_trace(\n        go.Histogram(\n            x=portfolio_returns * 100,\n            nbinsx=50,\n            name='Daily Returns',\n            marker_color='lightblue',\n            opacity=0.7\n        ),\n        row=1, col=1\n    )\n    \n    # Add VaR lines to distribution\n    fig.add_vline(\n        x=historical_var * 100,\n        line_dash=\"dash\",\n        line_color=\"red\",\n        annotation_text=f\"Historical VaR: {historical_var:.2%}\",\n        row=1, col=1\n    )\n    \n    # Historical VaR timeline\n    returns_sorted = portfolio_returns.sort_values()\n    var_index = int((1 - confidence_level) * len(returns_sorted))\n    \n    fig.add_trace(\n        go.Scatter(\n            x=list(range(len(returns_sorted))),\n            y=returns_sorted * 100,\n            mode='lines',\n            name='Sorted Returns',\n            line=dict(color='blue')\n        ),\n        row=1, col=2\n    )\n    \n    fig.add_hline(\n        y=historical_var * 100,\n        line_dash=\"dash\",\n        line_color=\"red\",\n        annotation_text=f\"VaR Threshold\",\n        row=1, col=2\n    )\n    \n    # Rolling VaR\n    rolling_var = portfolio_returns.rolling(window=30).quantile(1 - confidence_level) * 100\n    \n    fig.add_trace(\n        go.Scatter(\n            x=rolling_var.index,\n            y=rolling_var,\n            mode='lines',\n            name='Rolling VaR',\n            line=dict(color='red')\n        ),\n        row=2, col=1\n    )\n    \n    # Risk metrics timeline\n    rolling_vol = portfolio_returns.rolling(window=30).std() * np.sqrt(252) * 100\n    \n    fig.add_trace(\n        go.Scatter(\n            x=rolling_vol.index,\n            y=rolling_vol,\n            mode='lines',\n            name='Rolling Volatility',\n            line=dict(color='orange')\n        ),\n        row=2, col=2\n    )\n    \n    fig.update_layout(\n        title=\"Value at Risk Analysis\",\n        template=\"plotly_dark\",\n        height=600,\n        showlegend=True\n    )\n    \n    fig.update_xaxes(title_text=\"Returns (%)\", row=1, col=1)\n    fig.update_xaxes(title_text=\"Percentile\", row=1, col=2)\n    fig.update_xaxes(title_text=\"Date\", row=2, col=1)\n    fig.update_xaxes(title_text=\"Date\", row=2, col=2)\n    \n    fig.update_yaxes(title_text=\"Frequency\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Returns (%)\", row=1, col=2)\n    fig.update_yaxes(title_text=\"VaR (%)\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Volatility (%)\", row=2, col=2)\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef calculate_historical_var(returns, confidence_level, time_horizon):\n    \"\"\"Calculate historical Value at Risk\"\"\"\n    \n    # Scale returns for time horizon\n    scaled_returns = returns * np.sqrt(time_horizon)\n    \n    # Calculate VaR as the quantile\n    var = scaled_returns.quantile(1 - confidence_level)\n    \n    return abs(var)  # Return as positive value\n\ndef calculate_parametric_var(returns, confidence_level, time_horizon):\n    \"\"\"Calculate parametric (normal distribution) Value at Risk\"\"\"\n    \n    # Calculate mean and standard deviation\n    mean = returns.mean()\n    std = returns.std()\n    \n    # Scale for time horizon\n    mean_scaled = mean * time_horizon\n    std_scaled = std * np.sqrt(time_horizon)\n    \n    # Calculate VaR using normal distribution\n    z_score = stats.norm.ppf(1 - confidence_level)\n    var = -(mean_scaled + z_score * std_scaled)\n    \n    return max(var, 0)  # Ensure positive\n\ndef calculate_expected_shortfall(returns, confidence_level, time_horizon):\n    \"\"\"Calculate Expected Shortfall (Conditional VaR)\"\"\"\n    \n    # Scale returns for time horizon\n    scaled_returns = returns * np.sqrt(time_horizon)\n    \n    # Calculate VaR threshold\n    var_threshold = scaled_returns.quantile(1 - confidence_level)\n    \n    # Calculate expected shortfall (average of losses beyond VaR)\n    tail_losses = scaled_returns[scaled_returns <= var_threshold]\n    \n    if len(tail_losses) > 0:\n        expected_shortfall = abs(tail_losses.mean())\n    else:\n        expected_shortfall = abs(var_threshold)\n    \n    return expected_shortfall\n\ndef display_correlation_analysis(data, portfolio):\n    \"\"\"Display correlation analysis and heatmap\"\"\"\n    \n    st.subheader(\"üîó Correlation Analysis\")\n    \n    # Calculate correlation matrix\n    returns = data.pct_change().dropna()\n    correlation_matrix = returns.corr()\n    \n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        # Correlation heatmap\n        fig = px.imshow(\n            correlation_matrix,\n            title=\"Portfolio Correlation Matrix\",\n            color_continuous_scale=\"RdBu\",\n            aspect=\"auto\",\n            text_auto=True\n        )\n        \n        fig.update_layout(\n            template=\"plotly_dark\",\n            height=400\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n    \n    with col2:\n        # Correlation statistics\n        st.markdown(\"**Correlation Statistics:**\")\n        \n        # Average correlation\n        avg_correlation = correlation_matrix.values[np.triu_indices_from(correlation_matrix.values, k=1)].mean()\n        st.metric(\"Average Correlation\", f\"{avg_correlation:.3f}\")\n        \n        # Highest and lowest correlations\n        corr_values = correlation_matrix.values[np.triu_indices_from(correlation_matrix.values, k=1)]\n        highest_corr = corr_values.max()\n        lowest_corr = corr_values.min()\n        \n        st.metric(\"Highest Correlation\", f\"{highest_corr:.3f}\")\n        st.metric(\"Lowest Correlation\", f\"{lowest_corr:.3f}\")\n        \n        # Most correlated pairs\n        st.markdown(\"**Most Correlated Pairs:**\")\n        \n        # Find most correlated pairs\n        corr_pairs = []\n        symbols = list(correlation_matrix.columns)\n        \n        for i in range(len(symbols)):\n            for j in range(i+1, len(symbols)):\n                corr_pairs.append({\n                    'Pair': f\"{symbols[i]}-{symbols[j]}\",\n                    'Correlation': correlation_matrix.iloc[i, j]\n                })\n        \n        corr_df = pd.DataFrame(corr_pairs).sort_values('Correlation', ascending=False)\n        st.dataframe(corr_df.head(5), use_container_width=True)\n\ndef display_stress_testing(portfolio_returns, portfolio_value, data, portfolio):\n    \"\"\"Display stress testing and scenario analysis\"\"\"\n    \n    st.subheader(\"üö® Stress Testing & Scenario Analysis\")\n    \n    # Historical stress periods\n    stress_scenarios = {\n        \"2008 Financial Crisis\": (\"2008-09-01\", \"2009-03-01\"),\n        \"COVID-19 Crash\": (\"2020-02-01\", \"2020-04-01\"),\n        \"Dot-com Bubble\": (\"2000-03-01\", \"2001-03-01\"),\n        \"European Debt Crisis\": (\"2011-07-01\", \"2011-12-01\")\n    }\n    \n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        st.markdown(\"**Historical Stress Scenarios:**\")\n        \n        stress_results = []\n        returns = data.pct_change().dropna()\n        \n        for scenario_name, (start_date, end_date) in stress_scenarios.items():\n            try:\n                # Filter data for stress period\n                mask = (returns.index >= start_date) & (returns.index <= end_date)\n                period_returns = returns[mask]\n                \n                if not period_returns.empty:\n                    # Calculate portfolio returns for this period\n                    portfolio_period_returns = pd.Series(0, index=period_returns.index)\n                    \n                    for symbol, weight in portfolio.items():\n                        if symbol in period_returns.columns:\n                            portfolio_period_returns += period_returns[symbol] * weight\n                    \n                    # Calculate cumulative return and max drawdown\n                    cumulative_return = (1 + portfolio_period_returns).cumprod() - 1\n                    max_drawdown = calculate_max_drawdown(cumulative_return)\n                    total_return = cumulative_return.iloc[-1]\n                    \n                    stress_results.append({\n                        'Scenario': scenario_name,\n                        'Total Return': f\"{total_return:.2%}\",\n                        'Max Drawdown': f\"{max_drawdown:.2%}\",\n                        'Dollar Impact': f\"${total_return * portfolio_value:,.0f}\"\n                    })\n                \n            except Exception as e:\n                continue\n        \n        if stress_results:\n            stress_df = pd.DataFrame(stress_results)\n            st.dataframe(stress_df, use_container_width=True)\n        else:\n            st.info(\"Historical stress scenarios not available for current data range\")\n    \n    with col2:\n        st.markdown(\"**Monte Carlo Stress Testing:**\")\n        \n        # Monte Carlo simulation\n        n_simulations = st.selectbox(\"Number of Simulations\", [100, 500, 1000], index=1)\n        simulation_days = st.selectbox(\"Simulation Period (Days)\", [22, 63, 252], index=1)\n        \n        if st.button(\"üé≤ Run Monte Carlo Simulation\"):\n            with st.spinner(\"Running simulations...\"):\n                mc_results = run_monte_carlo_simulation(\n                    portfolio_returns, n_simulations, simulation_days, portfolio_value\n                )\n                \n                # Display simulation results\n                var_95 = np.percentile(mc_results, 5)\n                var_99 = np.percentile(mc_results, 1)\n                expected_value = np.mean(mc_results)\n                \n                st.metric(\"Expected Portfolio Value\", f\"${expected_value:,.0f}\")\n                st.metric(\"VaR 95% (MC)\", f\"${portfolio_value - var_95:,.0f}\")\n                st.metric(\"VaR 99% (MC)\", f\"${portfolio_value - var_99:,.0f}\")\n                \n                # Simulation distribution\n                fig = go.Figure()\n                \n                fig.add_trace(\n                    go.Histogram(\n                        x=mc_results,\n                        nbinsx=50,\n                        name='Simulation Results',\n                        marker_color='lightgreen',\n                        opacity=0.7\n                    )\n                )\n                \n                fig.add_vline(x=var_95, line_dash=\"dash\", line_color=\"orange\", \n                             annotation_text=\"VaR 95%\")\n                fig.add_vline(x=var_99, line_dash=\"dash\", line_color=\"red\", \n                             annotation_text=\"VaR 99%\")\n                \n                fig.update_layout(\n                    title=\"Monte Carlo Simulation Results\",\n                    template=\"plotly_dark\",\n                    height=300,\n                    xaxis_title=\"Portfolio Value ($)\",\n                    yaxis_title=\"Frequency\"\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n\ndef calculate_max_drawdown(cumulative_returns):\n    \"\"\"Calculate maximum drawdown from cumulative returns\"\"\"\n    \n    # Calculate running maximum\n    running_max = cumulative_returns.cummax()\n    \n    # Calculate drawdown\n    drawdown = (cumulative_returns - running_max) / (1 + running_max)\n    \n    # Return maximum drawdown (most negative value)\n    return drawdown.min()\n\ndef run_monte_carlo_simulation(portfolio_returns, n_simulations, simulation_days, portfolio_value):\n    \"\"\"Run Monte Carlo simulation for portfolio\"\"\"\n    \n    # Calculate return statistics\n    mean_return = portfolio_returns.mean()\n    return_std = portfolio_returns.std()\n    \n    # Run simulations\n    simulation_results = []\n    \n    for _ in range(n_simulations):\n        # Generate random returns\n        random_returns = np.random.normal(mean_return, return_std, simulation_days)\n        \n        # Calculate final portfolio value\n        final_value = portfolio_value * np.prod(1 + random_returns)\n        simulation_results.append(final_value)\n    \n    return np.array(simulation_results)\n\ndef display_portfolio_optimization(data, portfolio, risk_free_rate):\n    \"\"\"Display portfolio optimization analysis\"\"\"\n    \n    st.subheader(\"‚öñÔ∏è Portfolio Optimization\")\n    \n    # Calculate expected returns and covariance matrix\n    returns = data.pct_change().dropna()\n    \n    # Annualize returns and covariance\n    expected_returns = returns.mean() * 252\n    cov_matrix = returns.cov() * 252\n    \n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        st.markdown(\"**Current Portfolio Metrics:**\")\n        \n        # Calculate current portfolio metrics\n        weights = np.array([portfolio.get(symbol, 0) for symbol in returns.columns])\n        \n        current_return = np.sum(expected_returns * weights)\n        current_vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n        current_sharpe = (current_return - risk_free_rate) / current_vol if current_vol > 0 else 0\n        \n        st.metric(\"Expected Annual Return\", f\"{current_return:.2%}\")\n        st.metric(\"Annual Volatility\", f\"{current_vol:.2%}\")\n        st.metric(\"Sharpe Ratio\", f\"{current_sharpe:.3f}\")\n        \n        # Asset allocation pie chart\n        portfolio_df = pd.DataFrame(list(portfolio.items()), columns=['Symbol', 'Weight'])\n        \n        fig_pie = px.pie(\n            portfolio_df, \n            values='Weight', \n            names='Symbol',\n            title=\"Current Asset Allocation\"\n        )\n        \n        fig_pie.update_layout(\n            template=\"plotly_dark\",\n            height=300\n        )\n        \n        st.plotly_chart(fig_pie, use_container_width=True)\n    \n    with col2:\n        st.markdown(\"**Optimization Analysis:**\")\n        \n        if st.button(\"üéØ Calculate Optimal Portfolios\"):\n            with st.spinner(\"Optimizing portfolios...\"):\n                # Calculate efficient frontier\n                optimal_portfolios = calculate_efficient_frontier(expected_returns, cov_matrix, risk_free_rate)\n                \n                if optimal_portfolios:\n                    # Display optimal portfolio metrics\n                    min_vol_portfolio = optimal_portfolios['min_vol']\n                    max_sharpe_portfolio = optimal_portfolios['max_sharpe']\n                    \n                    st.markdown(\"**Minimum Volatility Portfolio:**\")\n                    st.write(f\"Return: {min_vol_portfolio['return']:.2%}\")\n                    st.write(f\"Volatility: {min_vol_portfolio['volatility']:.2%}\")\n                    st.write(f\"Sharpe Ratio: {min_vol_portfolio['sharpe']:.3f}\")\n                    \n                    st.markdown(\"**Maximum Sharpe Portfolio:**\")\n                    st.write(f\"Return: {max_sharpe_portfolio['return']:.2%}\")\n                    st.write(f\"Volatility: {max_sharpe_portfolio['volatility']:.2%}\")\n                    st.write(f\"Sharpe Ratio: {max_sharpe_portfolio['sharpe']:.3f}\")\n                    \n                    # Efficient frontier plot\n                    fig_frontier = go.Figure()\n                    \n                    # Plot efficient frontier\n                    if 'frontier_vols' in optimal_portfolios and 'frontier_returns' in optimal_portfolios:\n                        fig_frontier.add_trace(\n                            go.Scatter(\n                                x=optimal_portfolios['frontier_vols'],\n                                y=optimal_portfolios['frontier_returns'],\n                                mode='lines',\n                                name='Efficient Frontier',\n                                line=dict(color='blue', width=2)\n                            )\n                        )\n                    \n                    # Plot current portfolio\n                    fig_frontier.add_trace(\n                        go.Scatter(\n                            x=[current_vol],\n                            y=[current_return],\n                            mode='markers',\n                            name='Current Portfolio',\n                            marker=dict(color='red', size=10, symbol='star')\n                        )\n                    )\n                    \n                    # Plot optimal portfolios\n                    fig_frontier.add_trace(\n                        go.Scatter(\n                            x=[min_vol_portfolio['volatility']],\n                            y=[min_vol_portfolio['return']],\n                            mode='markers',\n                            name='Min Volatility',\n                            marker=dict(color='green', size=10)\n                        )\n                    )\n                    \n                    fig_frontier.add_trace(\n                        go.Scatter(\n                            x=[max_sharpe_portfolio['volatility']],\n                            y=[max_sharpe_portfolio['return']],\n                            mode='markers',\n                            name='Max Sharpe',\n                            marker=dict(color='orange', size=10)\n                        )\n                    )\n                    \n                    fig_frontier.update_layout(\n                        title=\"Efficient Frontier\",\n                        template=\"plotly_dark\",\n                        height=400,\n                        xaxis_title=\"Volatility\",\n                        yaxis_title=\"Expected Return\"\n                    )\n                    \n                    st.plotly_chart(fig_frontier, use_container_width=True)\n\ndef calculate_efficient_frontier(expected_returns, cov_matrix, risk_free_rate):\n    \"\"\"Calculate efficient frontier and optimal portfolios\"\"\"\n    \n    try:\n        n_assets = len(expected_returns)\n        \n        # Constraints\n        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})\n        bounds = tuple((0, 1) for _ in range(n_assets))\n        \n        # Initial guess\n        x0 = np.array([1/n_assets] * n_assets)\n        \n        # Objective functions\n        def portfolio_volatility(weights):\n            return np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))\n        \n        def portfolio_return(weights):\n            return np.sum(expected_returns * weights)\n        \n        def negative_sharpe(weights):\n            p_return = portfolio_return(weights)\n            p_vol = portfolio_volatility(weights)\n            return -(p_return - risk_free_rate) / p_vol if p_vol > 0 else -999\n        \n        # Optimize for minimum volatility\n        min_vol_result = minimize(portfolio_volatility, x0, method='SLSQP', \n                                bounds=bounds, constraints=constraints)\n        \n        # Optimize for maximum Sharpe ratio\n        max_sharpe_result = minimize(negative_sharpe, x0, method='SLSQP',\n                                   bounds=bounds, constraints=constraints)\n        \n        if min_vol_result.success and max_sharpe_result.success:\n            min_vol_weights = min_vol_result.x\n            max_sharpe_weights = max_sharpe_result.x\n            \n            return {\n                'min_vol': {\n                    'weights': min_vol_weights,\n                    'return': portfolio_return(min_vol_weights),\n                    'volatility': portfolio_volatility(min_vol_weights),\n                    'sharpe': (portfolio_return(min_vol_weights) - risk_free_rate) / portfolio_volatility(min_vol_weights)\n                },\n                'max_sharpe': {\n                    'weights': max_sharpe_weights,\n                    'return': portfolio_return(max_sharpe_weights),\n                    'volatility': portfolio_volatility(max_sharpe_weights),\n                    'sharpe': (portfolio_return(max_sharpe_weights) - risk_free_rate) / portfolio_volatility(max_sharpe_weights)\n                }\n            }\n        \n        return None\n        \n    except Exception as e:\n        st.error(f\"Error in portfolio optimization: {str(e)}\")\n        return None\n\ndef display_risk_decomposition(data, portfolio):\n    \"\"\"Display risk decomposition and contribution analysis\"\"\"\n    \n    st.subheader(\"üìà Risk Decomposition\")\n    \n    # Calculate component contributions\n    returns = data.pct_change().dropna()\n    \n    # Calculate individual asset volatilities\n    asset_vols = returns.std() * np.sqrt(252)\n    \n    # Calculate portfolio volatility\n    portfolio_returns = calculate_portfolio_returns(data, portfolio)\n    portfolio_vol = portfolio_returns.std() * np.sqrt(252)\n    \n    # Risk contribution analysis\n    col1, col2 = st.columns([1, 1])\n    \n    with col1:\n        st.markdown(\"**Asset Risk Contributions:**\")\n        \n        risk_contributions = []\n        \n        for symbol in portfolio.keys():\n            if symbol in returns.columns:\n                weight = portfolio[symbol]\n                asset_vol = asset_vols[symbol]\n                \n                # Calculate marginal contribution to risk\n                # This is a simplified approach\n                marginal_contribution = weight * asset_vol\n                risk_contribution = marginal_contribution / portfolio_vol if portfolio_vol > 0 else 0\n                \n                risk_contributions.append({\n                    'Asset': symbol,\n                    'Weight': f\"{weight:.1%}\",\n                    'Volatility': f\"{asset_vol:.2%}\",\n                    'Risk Contribution': f\"{risk_contribution:.2%}\"\n                })\n        \n        if risk_contributions:\n            risk_df = pd.DataFrame(risk_contributions)\n            st.dataframe(risk_df, use_container_width=True)\n            \n            # Risk contribution chart\n            fig_risk = px.bar(\n                risk_df,\n                x='Asset',\n                y=[float(x.strip('%')) for x in risk_df['Risk Contribution']],\n                title=\"Risk Contribution by Asset\"\n            )\n            \n            fig_risk.update_layout(\n                template=\"plotly_dark\",\n                height=300,\n                yaxis_title=\"Risk Contribution (%)\"\n            )\n            \n            st.plotly_chart(fig_risk, use_container_width=True)\n    \n    with col2:\n        st.markdown(\"**Portfolio Risk Metrics:**\")\n        \n        # Additional risk metrics\n        skewness = portfolio_returns.skew()\n        kurtosis = portfolio_returns.kurtosis()\n        \n        # Sharpe ratio\n        annual_return = portfolio_returns.mean() * 252\n        sharpe_ratio = annual_return / portfolio_vol if portfolio_vol > 0 else 0\n        \n        # Sortino ratio (downside deviation)\n        downside_returns = portfolio_returns[portfolio_returns < 0]\n        downside_std = downside_returns.std() * np.sqrt(252) if len(downside_returns) > 0 else 0\n        sortino_ratio = annual_return / downside_std if downside_std > 0 else 0\n        \n        # Maximum drawdown\n        cumulative_returns = (1 + portfolio_returns).cumprod() - 1\n        max_dd = calculate_max_drawdown(cumulative_returns)\n        \n        # Display metrics\n        metrics_data = {\n            'Metric': ['Annual Return', 'Annual Volatility', 'Sharpe Ratio', 'Sortino Ratio', \n                      'Skewness', 'Kurtosis', 'Max Drawdown'],\n            'Value': [f\"{annual_return:.2%}\", f\"{portfolio_vol:.2%}\", f\"{sharpe_ratio:.3f}\", \n                     f\"{sortino_ratio:.3f}\", f\"{skewness:.3f}\", f\"{kurtosis:.3f}\", f\"{max_dd:.2%}\"]\n        }\n        \n        metrics_df = pd.DataFrame(metrics_data)\n        st.dataframe(metrics_df, use_container_width=True)\n        \n        # Risk-Return scatter\n        fig_scatter = go.Figure()\n        \n        for symbol in portfolio.keys():\n            if symbol in returns.columns:\n                asset_return = returns[symbol].mean() * 252\n                asset_vol = asset_vols[symbol]\n                weight = portfolio[symbol]\n                \n                fig_scatter.add_trace(\n                    go.Scatter(\n                        x=[asset_vol],\n                        y=[asset_return],\n                        mode='markers+text',\n                        name=symbol,\n                        text=[symbol],\n                        textposition=\"top center\",\n                        marker=dict(size=weight*500, opacity=0.7)  # Size proportional to weight\n                    )\n                )\n        \n        # Add portfolio point\n        fig_scatter.add_trace(\n            go.Scatter(\n                x=[portfolio_vol],\n                y=[annual_return],\n                mode='markers+text',\n                name='Portfolio',\n                text=['Portfolio'],\n                textposition=\"top center\",\n                marker=dict(color='red', size=15, symbol='star')\n            )\n        )\n        \n        fig_scatter.update_layout(\n            title=\"Risk-Return Profile\",\n            template=\"plotly_dark\",\n            height=400,\n            xaxis_title=\"Volatility\",\n            yaxis_title=\"Expected Return\",\n            showlegend=False\n        )\n        \n        st.plotly_chart(fig_scatter, use_container_width=True)","size_bytes":32108},"modules/screener.py":{"content":"import streamlit as st\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom modules.user_auth import UserAuth\n\ndef display_screener():\n    \"\"\"Display market screener section\"\"\"\n    \n    st.subheader(\"üîç Stock Screener\")\n    \n    # Screening criteria - expanded to 4 columns for volume criteria\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.markdown(\"**Price Criteria**\")\n        # Load user preferences with defaults\n        min_price = st.number_input(\n            \"Min Price ($)\", \n            min_value=0.0, \n            value=UserAuth.get_user_preference('screener', 'min_price', 0.0)\n        )\n        max_price = st.number_input(\n            \"Max Price ($)\", \n            min_value=0.0, \n            value=UserAuth.get_user_preference('screener', 'max_price', 1000.0)\n        )\n    \n    with col2:\n        st.markdown(\"**Market Cap**\")\n        market_cap_filter = st.selectbox(\n            \"Market Cap Range\",\n            [\"All\", \"Large Cap (>$10B)\", \"Mid Cap ($2B-$10B)\", \"Small Cap (<$2B)\"],\n            index=0 if not UserAuth.get_user_preference('screener', 'market_cap_filter', None) else \n            [\"All\", \"Large Cap (>$10B)\", \"Mid Cap ($2B-$10B)\", \"Small Cap (<$2B)\"].index(UserAuth.get_user_preference('screener', 'market_cap_filter', \"All\"))\n        )\n    \n    with col3:\n        st.markdown(\"**Performance**\")\n        performance_filter = st.selectbox(\n            \"Performance Filter\",\n            [\"All\", \"Top Gainers\", \"Top Losers\", \"High Volume\"],\n            index=0 if not UserAuth.get_user_preference('screener', 'performance_filter', None) else\n            [\"All\", \"Top Gainers\", \"Top Losers\", \"High Volume\"].index(UserAuth.get_user_preference('screener', 'performance_filter', \"All\"))\n        )\n    \n    with col4:\n        st.markdown(\"**Volume Criteria**\")\n        min_volume = st.number_input(\n            \"Min Volume Threshold\",\n            min_value=0,\n            value=UserAuth.get_user_preference('screener', 'min_volume', 0),\n            step=100000,\n            help=\"Minimum daily volume required\"\n        )\n        \n        volume_comparison = st.selectbox(\n            \"Volume vs Average\",\n            [\"Any\", \"Above 20-day Average\", \"Below 20-day Average\", \"Above 3-month Average\", \"Below 3-month Average\"],\n            index=0 if not UserAuth.get_user_preference('screener', 'volume_comparison', None) else\n            [\"Any\", \"Above 20-day Average\", \"Below 20-day Average\", \"Above 3-month Average\", \"Below 3-month Average\"].index(UserAuth.get_user_preference('screener', 'volume_comparison', \"Any\"))\n        )\n        \n        volume_ratio_filter = st.selectbox(\n            \"Volume Ratio Filter\",\n            [\"Any\", \"Above Ratio Threshold\", \"Below Ratio Threshold\"],\n            index=0 if not UserAuth.get_user_preference('screener', 'volume_ratio_filter', None) else\n            [\"Any\", \"Above Ratio Threshold\", \"Below Ratio Threshold\"].index(UserAuth.get_user_preference('screener', 'volume_ratio_filter', \"Any\"))\n        )\n        \n        volume_ratio_threshold = st.number_input(\n            \"Volume Ratio (x Average)\",\n            min_value=0.1,\n            max_value=10.0,\n            value=UserAuth.get_user_preference('screener', 'volume_ratio_threshold', 2.0),\n            step=0.1,\n            help=\"Multiplier vs 20-day average (e.g., 2.0 = 2x average volume)\"\n        )\n    \n    # Sector filter\n    sectors = [\n        \"All Sectors\",\n        \"Technology\",\n        \"Healthcare\", \n        \"Financial Services\",\n        \"Consumer Cyclical\",\n        \"Industrials\",\n        \"Communication Services\",\n        \"Consumer Defensive\",\n        \"Energy\",\n        \"Real Estate\",\n        \"Materials\",\n        \"Utilities\"\n    ]\n    \n    selected_sector = st.selectbox(\"Sector Filter\", sectors)\n    \n    # Auto-save user preferences when values change\n    if UserAuth.is_logged_in():\n        UserAuth.auto_save_preference('screener', 'min_price', min_price)\n        UserAuth.auto_save_preference('screener', 'max_price', max_price)\n        UserAuth.auto_save_preference('screener', 'market_cap_filter', market_cap_filter)\n        UserAuth.auto_save_preference('screener', 'performance_filter', performance_filter)\n        UserAuth.auto_save_preference('screener', 'min_volume', min_volume)\n        UserAuth.auto_save_preference('screener', 'volume_comparison', volume_comparison)\n        UserAuth.auto_save_preference('screener', 'volume_ratio_filter', volume_ratio_filter)\n        UserAuth.auto_save_preference('screener', 'volume_ratio_threshold', volume_ratio_threshold)\n    \n    # Screen button\n    if st.button(\"üîç Run Screen\"):\n        with st.spinner(\"Screening stocks...\"):\n            screened_stocks = run_stock_screen(\n                min_price, max_price, market_cap_filter, \n                performance_filter, selected_sector,\n                min_volume, volume_comparison, volume_ratio_filter, volume_ratio_threshold\n            )\n            \n            if screened_stocks:\n                st.success(f\"Found {len(screened_stocks)} stocks matching your criteria\")\n                \n                # Display results\n                df = pd.DataFrame(screened_stocks)\n                \n                # Sort by market cap or performance based on filter\n                if performance_filter == \"Top Gainers\":\n                    df = df.sort_values(\"Change %\", ascending=False)\n                elif performance_filter == \"Top Losers\":\n                    df = df.sort_values(\"Change %\", ascending=True)\n                elif performance_filter == \"High Volume\":\n                    df = df.sort_values(\"Current Volume\", ascending=False)\n                elif volume_comparison != \"Any\" or volume_ratio_filter != \"Any\":\n                    # Sort by volume ratio when volume filters are applied\n                    df = df.sort_values(\"Volume Ratio (20d)\", ascending=False)\n                else:\n                    df = df.sort_values(\"Market Cap ($B)\", ascending=False)\n                \n                st.dataframe(df, use_container_width=True)\n                \n                # Download results\n                csv = df.to_csv(index=False)\n                st.download_button(\n                    label=\"üì• Download Results\",\n                    data=csv,\n                    file_name=f\"screen_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv\",\n                    mime=\"text/csv\"\n                )\n                \n            else:\n                st.warning(\"No stocks found matching your criteria. Try adjusting the filters.\")\n    \n    # Predefined screens\n    st.subheader(\"üìã Predefined Screens\")\n    \n    # Traditional screens\n    st.markdown(\"**Traditional Screens:**\")\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        if st.button(\"üíé Value Stocks\"):\n            run_predefined_screen(\"value\")\n    \n    with col2:\n        if st.button(\"üöÄ Growth Stocks\"):\n            run_predefined_screen(\"growth\")\n    \n    with col3:\n        if st.button(\"üí∞ Dividend Stocks\"):\n            run_predefined_screen(\"dividend\")\n    \n    with col4:\n        if st.button(\"üìà Momentum Stocks\"):\n            run_predefined_screen(\"momentum\")\n    \n    # Volume-based screens\n    st.markdown(\"**Volume-Based Screens:**\")\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        if st.button(\"üî• Volume Breakouts\"):\n            run_predefined_screen(\"volume_breakouts\")\n    \n    with col2:\n        if st.button(\"üîç Low Volume Consolidation\"):\n            run_predefined_screen(\"low_volume_consolidation\")\n    \n    with col3:\n        if st.button(\"‚ö° Volume Surge Detection\"):\n            run_predefined_screen(\"volume_surge\")\n    \n    # Popular stock lists\n    st.subheader(\"üìä Popular Lists\")\n    \n    popular_lists = {\n        \"S&P 500\": get_sp500_symbols(),\n        \"NASDAQ 100\": get_nasdaq100_symbols(),\n        \"DOW 30\": get_dow30_symbols(),\n        \"Tech Giants\": [\"AAPL\", \"GOOGL\", \"MSFT\", \"AMZN\", \"TSLA\", \"NVDA\", \"META\"],\n        \"Banking\": [\"JPM\", \"BAC\", \"WFC\", \"C\", \"GS\", \"MS\"],\n        \"Energy\": [\"XOM\", \"CVX\", \"COP\", \"EOG\", \"SLB\", \"PXD\"]\n    }\n    \n    selected_list = st.selectbox(\"View Popular List\", list(popular_lists.keys()))\n    \n    if st.button(\"üìã Load List\"):\n        symbols = popular_lists[selected_list]\n        display_stock_list(symbols, selected_list)\n\ndef run_stock_screen(min_price, max_price, market_cap_filter, performance_filter, sector_filter, min_volume=0, volume_comparison=\"Any\", volume_ratio_filter=\"Any\", volume_ratio_threshold=2.0):\n    \"\"\"Run stock screening with given criteria including volume filters\"\"\"\n    try:\n        # Get a sample of popular stocks to screen\n        # In a real application, you would screen from a larger universe\n        sample_symbols = get_sample_symbols()\n        \n        screened_stocks = []\n        \n        for symbol in sample_symbols:\n            try:\n                ticker = yf.Ticker(symbol)\n                info = ticker.info\n                hist = ticker.history(period=\"2d\")\n                \n                if hist.empty or len(hist) < 2:\n                    continue\n                \n                current_price = hist['Close'].iloc[-1]\n                prev_price = hist['Close'].iloc[-2]\n                change = current_price - prev_price\n                change_percent = (change / prev_price) * 100\n                \n                # Price filter\n                if current_price < min_price or current_price > max_price:\n                    continue\n                \n                # Market cap filter\n                market_cap = info.get('marketCap', 0)\n                if market_cap_filter == \"Large Cap (>$10B)\" and market_cap < 10e9:\n                    continue\n                elif market_cap_filter == \"Mid Cap ($2B-$10B)\" and (market_cap < 2e9 or market_cap > 10e9):\n                    continue\n                elif market_cap_filter == \"Small Cap (<$2B)\" and market_cap > 2e9:\n                    continue\n                \n                # Sector filter\n                sector = info.get('sector', '')\n                if sector_filter != \"All Sectors\" and sector_filter.lower() not in sector.lower():\n                    continue\n                \n                # Performance filter\n                volume = hist['Volume'].iloc[-1]\n                if performance_filter == \"Top Gainers\" and change_percent < 2:\n                    continue\n                elif performance_filter == \"Top Losers\" and change_percent > -2:\n                    continue\n                elif performance_filter == \"High Volume\" and volume < 1000000:\n                    continue\n                \n                # Calculate volume metrics\n                volume_metrics = calculate_volume_metrics(symbol)\n                \n                # Apply volume filters\n                if not check_volume_filters(volume_metrics, min_volume, volume_comparison, volume_ratio_filter, volume_ratio_threshold):\n                    continue\n                \n                # Prepare volume display data\n                if volume_metrics:\n                    volume_display = format_volume(volume_metrics['current_volume'])\n                    avg_volume_20d_display = format_volume(volume_metrics['avg_volume_20d'])\n                    avg_volume_3m_display = format_volume(volume_metrics['avg_volume_3m'])\n                    volume_ratio_20d_display = f\"{volume_metrics['volume_ratio_20d']:.2f}x\"\n                    volume_ratio_3m_display = f\"{volume_metrics['volume_ratio_3m']:.2f}x\"\n                else:\n                    volume_display = format_volume(volume)\n                    avg_volume_20d_display = \"N/A\"\n                    avg_volume_3m_display = \"N/A\"\n                    volume_ratio_20d_display = \"N/A\"\n                    volume_ratio_3m_display = \"N/A\"\n                \n                screened_stocks.append({\n                    'Symbol': symbol,\n                    'Company': info.get('longName', symbol),\n                    'Price': f\"${current_price:.2f}\",\n                    'Change': f\"${change:.2f}\",\n                    'Change %': f\"{change_percent:.2f}%\",\n                    'Current Volume': volume_display,\n                    'Avg Volume (20d)': avg_volume_20d_display,\n                    'Avg Volume (3m)': avg_volume_3m_display,\n                    'Volume Ratio (20d)': volume_ratio_20d_display,\n                    'Volume Ratio (3m)': volume_ratio_3m_display,\n                    'Market Cap ($B)': f\"{market_cap/1e9:.2f}\" if market_cap else \"N/A\",\n                    'Sector': sector,\n                    'P/E Ratio': f\"{info.get('trailingPE', 'N/A'):.2f}\" if info.get('trailingPE') else \"N/A\"\n                })\n                \n            except Exception as e:\n                continue\n        \n        return screened_stocks\n        \n    except Exception as e:\n        st.error(f\"Error running screen: {str(e)}\")\n        return []\n\ndef run_predefined_screen(screen_type):\n    \"\"\"Run predefined screening strategies\"\"\"\n    st.info(f\"Running {screen_type.replace('_', ' ').title()} screen...\")\n    \n    if screen_type == \"value\":\n        # Value stocks - low P/E, reasonable price, decent volume\n        screened = run_stock_screen(5, 500, \"All\", \"All\", \"All Sectors\", min_volume=500000)\n        # Filter for low P/E ratios\n        value_stocks = []\n        for stock in screened:\n            try:\n                pe = float(stock['P/E Ratio'].replace('N/A', '999'))\n                if pe < 20 and pe > 0:\n                    value_stocks.append(stock)\n            except:\n                continue\n        \n        if value_stocks:\n            st.success(f\"Found {len(value_stocks)} value stocks with decent volume\")\n            df = pd.DataFrame(value_stocks)\n            df = df.sort_values(\"P/E Ratio\")\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No value stocks found in the current sample\")\n    \n    elif screen_type == \"growth\":\n        # Growth stocks - technology sector focus, above average volume\n        screened = run_stock_screen(10, 1000, \"All\", \"All\", \"Technology\", min_volume=1000000, volume_comparison=\"Above 20-day Average\")\n        if screened:\n            st.success(f\"Found {len(screened)} technology growth stocks with strong volume\")\n            df = pd.DataFrame(screened)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No growth stocks found\")\n    \n    elif screen_type == \"dividend\":\n        # Dividend stocks - typically utilities, REITs, steady volume\n        screened = run_stock_screen(5, 200, \"All\", \"All\", \"Utilities\", min_volume=250000)\n        if screened:\n            st.success(f\"Found {len(screened)} potential dividend stocks with steady volume\")\n            df = pd.DataFrame(screened)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No dividend stocks found\")\n    \n    elif screen_type == \"momentum\":\n        # Momentum stocks - top gainers with high volume\n        screened = run_stock_screen(5, 1000, \"All\", \"Top Gainers\", \"All Sectors\", min_volume=2000000, volume_comparison=\"Above 20-day Average\")\n        if screened:\n            st.success(f\"Found {len(screened)} momentum stocks with strong volume confirmation\")\n            df = pd.DataFrame(screened)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No momentum stocks found\")\n    \n    elif screen_type == \"volume_breakouts\":\n        # High volume breakouts - stocks with 3x+ average volume and positive price movement\n        screened = run_stock_screen(1, 1000, \"All\", \"Top Gainers\", \"All Sectors\", min_volume=1000000, volume_ratio_filter=\"Above Ratio Threshold\", volume_ratio_threshold=3.0)\n        if screened:\n            st.success(f\"Found {len(screened)} high volume breakout candidates\")\n            st.info(\"üìà These stocks show strong volume surges (3x+ average) with positive price movement - potential breakout patterns\")\n            df = pd.DataFrame(screened)\n            df = df.sort_values(\"Volume Ratio (20d)\", ascending=False)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No volume breakouts found in current market conditions\")\n    \n    elif screen_type == \"low_volume_consolidation\":\n        # Low volume consolidation - stocks with below average volume and minimal price movement\n        screened = run_stock_screen(5, 1000, \"All\", \"All\", \"All Sectors\", min_volume=100000, volume_comparison=\"Below 20-day Average\", volume_ratio_filter=\"Below Ratio Threshold\", volume_ratio_threshold=0.7)\n        \n        # Filter for minimal price movement (consolidation pattern)\n        consolidation_stocks = []\n        for stock in screened:\n            try:\n                change_percent = float(stock['Change %'].replace('%', ''))\n                if abs(change_percent) < 3:  # Less than 3% movement\n                    consolidation_stocks.append(stock)\n            except:\n                continue\n        \n        if consolidation_stocks:\n            st.success(f\"Found {len(consolidation_stocks)} low volume consolidation patterns\")\n            st.info(\"üîç These stocks show consolidation with low volume - potential for future moves when volume returns\")\n            df = pd.DataFrame(consolidation_stocks)\n            df = df.sort_values(\"Volume Ratio (20d)\", ascending=True)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.warning(\"No consolidation patterns found\")\n    \n    elif screen_type == \"volume_surge\":\n        # Volume surge detection - stocks with 2x+ volume but any price movement\n        screened = run_stock_screen(1, 1000, \"All\", \"All\", \"All Sectors\", min_volume=500000, volume_ratio_filter=\"Above Ratio Threshold\", volume_ratio_threshold=2.0)\n        if screened:\n            st.success(f\"Found {len(screened)} stocks with significant volume surges\")\n            st.info(\"‚ö° These stocks show 2x+ average volume - indicates institutional interest or news flow\")\n            df = pd.DataFrame(screened)\n            df = df.sort_values(\"Volume Ratio (20d)\", ascending=False)\n            st.dataframe(df, use_container_width=True)\n            \n            # Show volume surge statistics\n            try:\n                avg_ratio = df['Volume Ratio (20d)'].str.replace('x', '').astype(float).mean()\n                max_ratio = df['Volume Ratio (20d)'].str.replace('x', '').astype(float).max()\n                st.metric(\"Average Volume Ratio\", f\"{avg_ratio:.2f}x\")\n                st.metric(\"Max Volume Ratio\", f\"{max_ratio:.2f}x\")\n            except:\n                pass\n        else:\n            st.warning(\"No significant volume surges detected\")\n\ndef display_stock_list(symbols, list_name):\n    \"\"\"Display a list of stocks\"\"\"\n    st.info(f\"Loading {list_name} stocks...\")\n    \n    stock_data = []\n    for symbol in symbols[:20]:  # Limit to first 20 to avoid timeouts\n        try:\n            ticker = yf.Ticker(symbol)\n            info = ticker.info\n            hist = ticker.history(period=\"1d\")\n            \n            if not hist.empty:\n                current_price = hist['Close'].iloc[-1]\n                \n                stock_data.append({\n                    'Symbol': symbol,\n                    'Company': info.get('longName', symbol),\n                    'Price': f\"${current_price:.2f}\",\n                    'Market Cap': f\"${info.get('marketCap', 0)/1e9:.2f}B\" if info.get('marketCap') else \"N/A\",\n                    'Sector': info.get('sector', 'N/A')\n                })\n        except:\n            continue\n    \n    if stock_data:\n        df = pd.DataFrame(stock_data)\n        st.dataframe(df, use_container_width=True)\n    else:\n        st.error(\"Unable to load stock list data\")\n\ndef get_sample_symbols():\n    \"\"\"Get a sample of stock symbols for screening\"\"\"\n    return [\n        'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NVDA', 'META', 'NFLX',\n        'JPM', 'BAC', 'WFC', 'GS', 'MS', 'C', 'V', 'MA',\n        'JNJ', 'PFE', 'UNH', 'ABBV', 'BMY', 'MRK', 'CVS',\n        'XOM', 'CVX', 'COP', 'EOG', 'SLB', 'PXD',\n        'DIS', 'CMCSA', 'VZ', 'T', 'ORCL', 'CRM', 'ADBE',\n        'WMT', 'HD', 'MCD', 'NKE', 'SBUX', 'LOW', 'TGT',\n        'BA', 'CAT', 'GE', 'MMM', 'HON', 'UPS', 'FDX'\n    ]\n\ndef get_sp500_symbols():\n    \"\"\"Get S&P 500 symbol sample\"\"\"\n    return ['AAPL', 'MSFT', 'AMZN', 'GOOGL', 'TSLA', 'NVDA', 'META', 'UNH', 'JNJ', 'V']\n\ndef get_nasdaq100_symbols():\n    \"\"\"Get NASDAQ 100 symbol sample\"\"\"\n    return ['AAPL', 'MSFT', 'AMZN', 'GOOGL', 'TSLA', 'NVDA', 'META', 'NFLX', 'ADBE', 'CRM']\n\ndef get_dow30_symbols():\n    \"\"\"Get DOW 30 symbols\"\"\"\n    return ['AAPL', 'MSFT', 'BA', 'CAT', 'CVX', 'GS', 'HD', 'IBM', 'JNJ', 'JPM']\n\ndef calculate_volume_metrics(ticker_symbol):\n    \"\"\"Calculate volume metrics for a given stock\"\"\"\n    try:\n        ticker = yf.Ticker(ticker_symbol)\n        \n        # Get 3 months of historical data for volume calculations\n        hist = ticker.history(period=\"3mo\")\n        \n        if hist.empty or len(hist) < 20:\n            return None\n        \n        current_volume = hist['Volume'].iloc[-1]\n        \n        # Calculate 20-day average volume\n        if len(hist) >= 20:\n            avg_volume_20d = hist['Volume'].tail(20).mean()\n        else:\n            avg_volume_20d = hist['Volume'].mean()\n        \n        # Calculate 3-month average volume\n        avg_volume_3m = hist['Volume'].mean()\n        \n        # Calculate volume ratios\n        volume_ratio_20d = current_volume / avg_volume_20d if avg_volume_20d > 0 else 0\n        volume_ratio_3m = current_volume / avg_volume_3m if avg_volume_3m > 0 else 0\n        \n        return {\n            'current_volume': current_volume,\n            'avg_volume_20d': avg_volume_20d,\n            'avg_volume_3m': avg_volume_3m,\n            'volume_ratio_20d': volume_ratio_20d,\n            'volume_ratio_3m': volume_ratio_3m\n        }\n        \n    except Exception as e:\n        return None\n\ndef format_volume(volume):\n    \"\"\"Format volume for display\"\"\"\n    if volume >= 1e9:\n        return f\"{volume/1e9:.2f}B\"\n    elif volume >= 1e6:\n        return f\"{volume/1e6:.2f}M\"\n    elif volume >= 1e3:\n        return f\"{volume/1e3:.2f}K\"\n    else:\n        return f\"{volume:.0f}\"\n\ndef check_volume_filters(volume_metrics, min_volume, volume_comparison, volume_ratio_filter, volume_ratio_threshold):\n    \"\"\"Check if stock passes volume filters\"\"\"\n    if not volume_metrics:\n        return False\n    \n    # Check minimum volume threshold\n    if min_volume > 0 and volume_metrics['current_volume'] < min_volume:\n        return False\n    \n    # Check volume comparison\n    if volume_comparison == \"Above 20-day Average\":\n        if volume_metrics['volume_ratio_20d'] <= 1.0:\n            return False\n    elif volume_comparison == \"Below 20-day Average\":\n        if volume_metrics['volume_ratio_20d'] >= 1.0:\n            return False\n    elif volume_comparison == \"Above 3-month Average\":\n        if volume_metrics['volume_ratio_3m'] <= 1.0:\n            return False\n    elif volume_comparison == \"Below 3-month Average\":\n        if volume_metrics['volume_ratio_3m'] >= 1.0:\n            return False\n    \n    # Check volume ratio filter\n    if volume_ratio_filter == \"Above Ratio Threshold\":\n        if volume_metrics['volume_ratio_20d'] < volume_ratio_threshold:\n            return False\n    elif volume_ratio_filter == \"Below Ratio Threshold\":\n        if volume_metrics['volume_ratio_20d'] > volume_ratio_threshold:\n            return False\n    \n    return True\n","size_bytes":23576},"modules/user_auth.py":{"content":"import streamlit as st\nfrom typing import Optional, Dict\nfrom modules.database import db_manager\n\nclass UserAuth:\n    \"\"\"Simple username-based user authentication and identification system\"\"\"\n    \n    @staticmethod\n    def initialize_session():\n        \"\"\"Initialize user session state variables\"\"\"\n        if 'user_id' not in st.session_state:\n            st.session_state.user_id = None\n        if 'username' not in st.session_state:\n            st.session_state.username = None\n        if 'user_data' not in st.session_state:\n            st.session_state.user_data = None\n        if 'auto_save_enabled' not in st.session_state:\n            st.session_state.auto_save_enabled = True\n    \n    @staticmethod\n    def get_current_user() -> Optional[Dict]:\n        \"\"\"Get current logged-in user data\"\"\"\n        UserAuth.initialize_session()\n        if st.session_state.user_id and st.session_state.user_data:\n            return st.session_state.user_data\n        return None\n    \n    @staticmethod\n    def get_current_user_id() -> Optional[int]:\n        \"\"\"Get current user ID\"\"\"\n        UserAuth.initialize_session()\n        return st.session_state.user_id\n    \n    @staticmethod\n    def is_logged_in() -> bool:\n        \"\"\"Check if user is logged in\"\"\"\n        UserAuth.initialize_session()\n        return st.session_state.user_id is not None\n    \n    @staticmethod\n    def login_user(username: str) -> bool:\n        \"\"\"Login user with username (create if doesn't exist)\"\"\"\n        if not username or not username.strip():\n            st.error(\"Please enter a valid username\")\n            return False\n        \n        username = username.strip().lower()\n        \n        try:\n            # Try to get existing user\n            user = db_manager.get_user(username)\n            \n            if user:\n                # Existing user\n                st.session_state.user_id = user['id']\n                st.session_state.username = user['username']\n                st.session_state.user_data = user\n                \n                # Update last login\n                db_manager.update_last_login(user['id'])\n                \n                st.success(f\"Welcome back, {username}!\")\n            else:\n                # Create new user\n                user = db_manager.create_user(username)\n                if user:\n                    st.session_state.user_id = user['id']\n                    st.session_state.username = user['username']\n                    st.session_state.user_data = user\n                    \n                    st.success(f\"Welcome, {username}! Your profile has been created.\")\n                else:\n                    st.error(\"Failed to create user profile\")\n                    return False\n            \n            # Load user data after login\n            UserAuth.load_user_data()\n            return True\n            \n        except Exception as e:\n            st.error(f\"Login failed: {str(e)}\")\n            return False\n    \n    @staticmethod\n    def logout_user():\n        \"\"\"Logout current user\"\"\"\n        # Save current state before logout\n        if UserAuth.is_logged_in():\n            UserAuth.save_current_state()\n        \n        # Clear session state\n        st.session_state.user_id = None\n        st.session_state.username = None\n        st.session_state.user_data = None\n        \n        # Clear other session data\n        for key in ['portfolio', 'alerts', 'alert_history', 'watchlist']:\n            if key in st.session_state:\n                del st.session_state[key]\n        \n        st.success(\"Logged out successfully\")\n        st.rerun()\n    \n    @staticmethod\n    def load_user_data():\n        \"\"\"Load user data from database into session state\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id:\n            return\n        \n        try:\n            # Load portfolio\n            portfolio_data = db_manager.get_user_portfolio(user_id)\n            portfolio_list = []\n            for pos in portfolio_data:\n                portfolio_list.append({\n                    'id': pos['id'],\n                    'symbol': pos['symbol'],\n                    'shares': float(pos['shares']),\n                    'purchase_price': float(pos['purchase_price']),\n                    'purchase_date': pos['purchase_date'],\n                    'purchase_value': float(pos['purchase_value'])\n                })\n            st.session_state.portfolio = portfolio_list\n            \n            # Load alerts\n            alerts_data = db_manager.get_user_alerts(user_id, status='Active')\n            alerts_list = []\n            for alert in alerts_data:\n                alert_dict = {\n                    'id': alert['id'],\n                    'alert_type': alert['alert_type'],\n                    'symbol': alert['symbol'],\n                    'alert_name': alert['alert_name'],\n                    'condition': alert['condition_type'],\n                    'notification_method': alert.get('notification_methods', []),\n                    'status': alert['status'],\n                    'triggered_count': alert['triggered_count'],\n                    'created_at': alert['created_at'].isoformat() if alert['created_at'] else None\n                }\n                \n                # Add price/volume conditions\n                if alert['target_price']:\n                    alert_dict['target_price'] = float(alert['target_price'])\n                if alert['lower_price']:\n                    alert_dict['lower_price'] = float(alert['lower_price'])\n                if alert['upper_price']:\n                    alert_dict['upper_price'] = float(alert['upper_price'])\n                if alert['target_volume']:\n                    alert_dict['target_volume'] = alert['target_volume']\n                \n                alerts_list.append(alert_dict)\n            \n            st.session_state.alerts = alerts_list\n            \n            # Load alert history\n            alert_history = db_manager.get_user_alerts(user_id)\n            st.session_state.alert_history = alert_history\n            \n            # Load watchlist\n            watchlist = db_manager.get_user_watchlist(user_id)\n            st.session_state.watchlist = watchlist if watchlist else ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'NVDA', 'AMZN']\n            \n        except Exception as e:\n            st.error(f\"Error loading user data: {str(e)}\")\n    \n    @staticmethod\n    def save_current_state():\n        \"\"\"Save current session state to database\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id or not st.session_state.get('auto_save_enabled', True):\n            return\n        \n        try:\n            # Save watchlist\n            if 'watchlist' in st.session_state:\n                db_manager.save_watchlist(user_id, st.session_state.watchlist)\n            \n        except Exception as e:\n            st.error(f\"Error saving user data: {str(e)}\")\n    \n    @staticmethod\n    def auto_save_portfolio_position(symbol: str, shares: float, purchase_price: float, purchase_date):\n        \"\"\"Auto-save a new portfolio position\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id or not st.session_state.get('auto_save_enabled', True):\n            return False\n        \n        return db_manager.save_portfolio_position(user_id, symbol, shares, purchase_price, purchase_date)\n    \n    @staticmethod\n    def auto_save_alert(alert_data: Dict):\n        \"\"\"Auto-save a new alert\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id or not st.session_state.get('auto_save_enabled', True):\n            return False\n        \n        return db_manager.save_alert(user_id, alert_data)\n    \n    @staticmethod\n    def auto_save_watchlist_symbol(symbol: str, action: str = 'add'):\n        \"\"\"Auto-save watchlist changes\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id or not st.session_state.get('auto_save_enabled', True):\n            return False\n        \n        if action == 'add':\n            return db_manager.add_to_watchlist(user_id, symbol)\n        elif action == 'remove':\n            return db_manager.remove_from_watchlist(user_id, symbol)\n        return False\n    \n    @staticmethod\n    def auto_save_preference(preference_type: str, preference_key: str, preference_value):\n        \"\"\"Auto-save user preference\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id or not st.session_state.get('auto_save_enabled', True):\n            return False\n        \n        return db_manager.save_preference(user_id, preference_type, preference_key, preference_value)\n    \n    @staticmethod\n    def get_user_preference(preference_type: str, preference_key: str, default_value=None):\n        \"\"\"Get user preference with default value\"\"\"\n        user_id = UserAuth.get_current_user_id()\n        if not user_id:\n            return default_value\n        \n        pref_value = db_manager.get_preference(user_id, preference_type, preference_key)\n        return pref_value if pref_value is not None else default_value\n    \n    @staticmethod\n    def display_login_form():\n        \"\"\"Display login form for user authentication\"\"\"\n        st.markdown(\"### üîê User Login\")\n        \n        with st.form(\"login_form\"):\n            st.markdown(\"Enter your username to access your personalized Bloomberg Terminal:\")\n            username = st.text_input(\n                \"Username\", \n                placeholder=\"Enter your username\",\n                help=\"Create a new account by entering a new username, or login with an existing one\"\n            )\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                login_btn = st.form_submit_button(\"üöÄ Login / Create Account\", use_container_width=True)\n            with col2:\n                if st.form_submit_button(\"‚ÑπÔ∏è About Profiles\", use_container_width=True):\n                    st.info(\"\"\"\n                    **User Profiles provide:**\n                    - Persistent portfolio tracking\n                    - Saved alerts and notifications\n                    - Custom watchlists\n                    - Chart preferences and settings\n                    - Screener filters and saved searches\n                    - Auto-save functionality across all modules\n                    \"\"\")\n            \n            if login_btn and username:\n                if UserAuth.login_user(username):\n                    st.rerun()\n        \n        # Display some benefits of using profiles\n        st.markdown(\"---\")\n        st.markdown(\"### ‚ú® Benefits of User Profiles\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.markdown(\"\"\"\n            **üìä Portfolio Tracking**\n            - Persistent holdings\n            - Performance history\n            - Auto-save positions\n            \"\"\")\n        \n        with col2:\n            st.markdown(\"\"\"\n            **üö® Alert Management**\n            - Price alerts\n            - Volume alerts\n            - Technical indicators\n            \"\"\")\n        \n        with col3:\n            st.markdown(\"\"\"\n            **‚öôÔ∏è Personal Settings**\n            - Chart preferences\n            - Saved watchlists\n            - Custom screener filters\n            \"\"\")\n    \n    @staticmethod\n    def display_user_menu():\n        \"\"\"Display user menu in sidebar\"\"\"\n        if not UserAuth.is_logged_in():\n            return\n        \n        user = UserAuth.get_current_user()\n        if user:\n            st.sidebar.markdown(\"---\")\n            st.sidebar.markdown(f\"üë§ **Logged in as:** {user['username']}\")\n            st.sidebar.markdown(f\"üìÖ **Member since:** {user['created_at'].strftime('%Y-%m-%d') if user['created_at'] else 'Unknown'}\")\n            \n            # Auto-save toggle\n            st.session_state.auto_save_enabled = st.sidebar.checkbox(\n                \"üíæ Auto-save enabled\", \n                value=st.session_state.get('auto_save_enabled', True),\n                help=\"Automatically save portfolio, alerts, and preferences\"\n            )\n            \n            col1, col2 = st.sidebar.columns(2)\n            \n            with col1:\n                if st.button(\"üíæ Save Now\", help=\"Manually save current state\"):\n                    UserAuth.save_current_state()\n                    st.success(\"Data saved!\")\n            \n            with col2:\n                if st.button(\"üö™ Logout\"):\n                    UserAuth.logout_user()\n\n# Initialize auth system\nuser_auth = UserAuth()","size_bytes":12479},"modules/utils.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nimport yfinance as yf\n\ndef format_currency(value, currency=\"USD\"):\n    \"\"\"Format currency values\"\"\"\n    if currency == \"USD\":\n        return f\"${value:,.2f}\"\n    elif currency == \"EUR\":\n        return f\"‚Ç¨{value:,.2f}\"\n    elif currency == \"GBP\":\n        return f\"¬£{value:,.2f}\"\n    else:\n        return f\"{value:,.2f} {currency}\"\n\ndef format_percentage(value):\n    \"\"\"Format percentage values\"\"\"\n    return f\"{value:.2f}%\"\n\ndef format_volume(value):\n    \"\"\"Format volume values\"\"\"\n    if value >= 1e9:\n        return f\"{value/1e9:.2f}B\"\n    elif value >= 1e6:\n        return f\"{value/1e6:.2f}M\"\n    elif value >= 1e3:\n        return f\"{value/1e3:.2f}K\"\n    else:\n        return f\"{value:.0f}\"\n\ndef get_color_for_change(change):\n    \"\"\"Get color for price changes\"\"\"\n    if change > 0:\n        return \"green\"\n    elif change < 0:\n        return \"red\"\n    else:\n        return \"gray\"\n\ndef calculate_returns(prices):\n    \"\"\"Calculate returns from price series\"\"\"\n    return prices.pct_change().dropna()\n\ndef calculate_volatility(returns, periods=252):\n    \"\"\"Calculate annualized volatility\"\"\"\n    return returns.std() * np.sqrt(periods)\n\ndef calculate_sharpe_ratio(returns, risk_free_rate=0.02, periods=252):\n    \"\"\"Calculate Sharpe ratio\"\"\"\n    excess_returns = returns.mean() * periods - risk_free_rate\n    volatility = calculate_volatility(returns, periods)\n    return excess_returns / volatility if volatility != 0 else 0\n\ndef calculate_max_drawdown(prices):\n    \"\"\"Calculate maximum drawdown\"\"\"\n    peak = prices.expanding().max()\n    drawdown = (prices - peak) / peak\n    return drawdown.min()\n\ndef get_trading_days_between(start_date, end_date):\n    \"\"\"Get number of trading days between two dates\"\"\"\n    # Simple approximation - excludes weekends\n    total_days = (end_date - start_date).days\n    weeks = total_days // 7\n    remaining_days = total_days % 7\n    \n    # Rough estimate excluding weekends\n    trading_days = weeks * 5 + max(0, min(remaining_days, 5))\n    return trading_days\n\ndef validate_symbol(symbol):\n    \"\"\"Validate if a stock symbol exists\"\"\"\n    try:\n        ticker = yf.Ticker(symbol)\n        info = ticker.info\n        return 'symbol' in info or 'shortName' in info\n    except:\n        return False\n\ndef get_market_status():\n    \"\"\"Get current market status\"\"\"\n    now = datetime.now()\n    \n    # Simple market hours check (US Eastern Time approximation)\n    if now.weekday() < 5:  # Monday to Friday\n        if 9 <= now.hour < 16:  # 9 AM to 4 PM (simplified)\n            return \"üü¢ Market Open\"\n        else:\n            return \"üî¥ Market Closed\"\n    else:\n        return \"üî¥ Market Closed (Weekend)\"\n\ndef calculate_technical_indicators(data):\n    \"\"\"Calculate common technical indicators\"\"\"\n    indicators = {}\n    \n    if len(data) >= 14:\n        # RSI\n        delta = data['Close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n        rs = gain / loss\n        indicators['RSI'] = 100 - (100 / (1 + rs)).iloc[-1]\n    \n    if len(data) >= 20:\n        # Bollinger Bands\n        sma20 = data['Close'].rolling(window=20).mean()\n        std20 = data['Close'].rolling(window=20).std()\n        indicators['BB_Upper'] = (sma20 + 2 * std20).iloc[-1]\n        indicators['BB_Lower'] = (sma20 - 2 * std20).iloc[-1]\n        indicators['BB_Middle'] = sma20.iloc[-1]\n    \n    if len(data) >= 50:\n        # Moving averages\n        indicators['SMA_20'] = data['Close'].rolling(window=20).mean().iloc[-1]\n        indicators['SMA_50'] = data['Close'].rolling(window=50).mean().iloc[-1]\n    \n    return indicators\n\ndef format_market_cap(market_cap):\n    \"\"\"Format market capitalization\"\"\"\n    if market_cap >= 1e12:\n        return f\"${market_cap/1e12:.2f}T\"\n    elif market_cap >= 1e9:\n        return f\"${market_cap/1e9:.2f}B\"\n    elif market_cap >= 1e6:\n        return f\"${market_cap/1e6:.2f}M\"\n    else:\n        return f\"${market_cap:,.0f}\"\n\ndef get_sector_performance():\n    \"\"\"Get sector performance data\"\"\"\n    sector_etfs = {\n        \"Technology\": \"XLK\",\n        \"Healthcare\": \"XLV\", \n        \"Financials\": \"XLF\",\n        \"Energy\": \"XLE\",\n        \"Utilities\": \"XLU\",\n        \"Consumer Discretionary\": \"XLY\",\n        \"Consumer Staples\": \"XLP\",\n        \"Industrials\": \"XLI\",\n        \"Materials\": \"XLB\",\n        \"Real Estate\": \"XLRE\",\n        \"Communication\": \"XLC\"\n    }\n    \n    sector_data = []\n    \n    for sector, etf in sector_etfs.items():\n        try:\n            ticker = yf.Ticker(etf)\n            hist = ticker.history(period=\"2d\")\n            \n            if len(hist) >= 2:\n                current_price = hist['Close'].iloc[-1]\n                prev_price = hist['Close'].iloc[-2]\n                change_percent = ((current_price - prev_price) / prev_price) * 100\n                \n                sector_data.append({\n                    'Sector': sector,\n                    'ETF': etf,\n                    'Change %': change_percent\n                })\n        except:\n            continue\n    \n    return sorted(sector_data, key=lambda x: x['Change %'], reverse=True)\n\ndef export_data_to_csv(data, filename):\n    \"\"\"Export data to CSV format\"\"\"\n    if isinstance(data, pd.DataFrame):\n        return data.to_csv(index=False)\n    elif isinstance(data, list):\n        df = pd.DataFrame(data)\n        return df.to_csv(index=False)\n    else:\n        return str(data)\n\ndef get_risk_metrics(returns):\n    \"\"\"Calculate risk metrics for a return series\"\"\"\n    if len(returns) < 2:\n        return {}\n    \n    metrics = {\n        'Mean Return': returns.mean(),\n        'Volatility': returns.std(),\n        'Skewness': returns.skew(),\n        'Kurtosis': returns.kurtosis(),\n        'Min Return': returns.min(),\n        'Max Return': returns.max()\n    }\n    \n    return metrics\n\n@st.cache_data(ttl=3600)  # Cache for 1 hour\ndef get_currency_rates():\n    \"\"\"Get major currency exchange rates\"\"\"\n    currencies = ['EURUSD=X', 'GBPUSD=X', 'USDJPY=X', 'AUDUSD=X', 'USDCAD=X']\n    rates = {}\n    \n    for currency in currencies:\n        try:\n            ticker = yf.Ticker(currency)\n            hist = ticker.history(period=\"1d\")\n            if not hist.empty:\n                rates[currency.replace('=X', '')] = hist['Close'].iloc[-1]\n        except:\n            continue\n    \n    return rates\n\ndef display_disclaimer():\n    \"\"\"Display financial disclaimer\"\"\"\n    st.markdown(\"\"\"\n    ---\n    **‚ö†Ô∏è Important Disclaimer:**\n    \n    This application is for educational and informational purposes only. \n    The data and analysis provided should not be considered as financial advice. \n    Always consult with qualified financial professionals before making investment decisions.\n    \n    *Data sources: Yahoo Finance and other public APIs*\n    \"\"\")\n","size_bytes":6877},"modules/data_service.py":{"content":"import requests\nimport yfinance as yf\nimport pandas as pd\nimport streamlit as st\nimport json\nimport time\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom bs4 import BeautifulSoup\nimport re\nimport logging\nfrom functools import wraps\nfrom threading import Lock\nimport warnings\n\nwarnings.filterwarnings('ignore')\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass DataQuality:\n    \"\"\"Data quality indicators\"\"\"\n    LIVE = \"live\"           # Real-time data (<5 seconds old)\n    NEAR_REAL_TIME = \"near_real_time\"  # Near real-time (<60 seconds old)\n    DELAYED = \"delayed\"     # Delayed data (>60 seconds old)\n    CACHED = \"cached\"       # Cached data\n    FALLBACK = \"fallback\"   # Fallback to yfinance\n    STALE = \"stale\"        # Stale data (>15 minutes old)\n\nclass MarketDataService:\n    \"\"\"Centralized real-time market data service with fallback to yfinance\"\"\"\n    \n    def __init__(self):\n        self._cache = {}\n        self._cache_lock = Lock()\n        self._rate_limiter = {}\n        self._rate_limit_lock = Lock()\n        \n        # Rate limiting configuration (requests per minute)\n        self.rate_limits = {\n            'yahoo_finance': 30,    # Conservative limit for scraping\n            'finviz': 20,\n            'marketwatch': 20,\n            'default': 60\n        }\n        \n        # Cache TTL configuration (seconds)\n        self.cache_ttl = {\n            'stock_quote': 5,       # Stock quotes - 5 seconds\n            'index_data': 10,       # Index data - 10 seconds  \n            'currency_data': 30,    # Currency data - 30 seconds\n            'commodity_data': 30,   # Commodity data - 30 seconds\n            'crypto_data': 5,       # Crypto data - 5 seconds\n            'company_info': 3600,   # Company info - 1 hour\n            'historical_data': 300, # Historical data - 5 minutes\n            'options_data': 60,     # Options data - 1 minute\n            'futures_data': 15      # Futures data - 15 seconds\n        }\n        \n        # Data source priorities (higher number = higher priority)\n        self.data_sources = {\n            'yahoo_scrape': 3,      # Yahoo Finance scraping\n            'finviz': 2,            # Finviz scraping\n            'yfinance': 1           # yfinance fallback\n        }\n\n    def _rate_limit_check(self, source: str) -> bool:\n        \"\"\"Check if we can make a request to the source without exceeding rate limits\"\"\"\n        with self._rate_limit_lock:\n            current_time = time.time()\n            limit = self.rate_limits.get(source, self.rate_limits['default'])\n            \n            if source not in self._rate_limiter:\n                self._rate_limiter[source] = []\n            \n            # Remove requests older than 1 minute\n            self._rate_limiter[source] = [\n                req_time for req_time in self._rate_limiter[source]\n                if current_time - req_time < 60\n            ]\n            \n            # Check if we can make another request\n            if len(self._rate_limiter[source]) < limit:\n                self._rate_limiter[source].append(current_time)\n                return True\n            \n            return False\n\n    def _cache_key(self, symbol: str, data_type: str, **kwargs) -> str:\n        \"\"\"Generate cache key\"\"\"\n        key_parts = [symbol.upper(), data_type]\n        for k, v in sorted(kwargs.items()):\n            key_parts.append(f\"{k}_{v}\")\n        return \"_\".join(key_parts)\n\n    def _get_from_cache(self, key: str, ttl: int) -> Optional[Dict]:\n        \"\"\"Get data from cache if not expired\"\"\"\n        with self._cache_lock:\n            if key in self._cache:\n                data, timestamp = self._cache[key]\n                age = time.time() - timestamp\n                \n                if age < ttl:\n                    # Update data quality based on age\n                    if age < 5:\n                        data['data_quality'] = DataQuality.CACHED\n                    elif age < 60:\n                        data['data_quality'] = DataQuality.NEAR_REAL_TIME\n                    else:\n                        data['data_quality'] = DataQuality.DELAYED\n                    \n                    data['cache_age'] = age\n                    return data\n                else:\n                    # Remove expired data\n                    del self._cache[key]\n        \n        return None\n\n    def _set_cache(self, key: str, data: Dict) -> None:\n        \"\"\"Set data in cache\"\"\"\n        with self._cache_lock:\n            self._cache[key] = (data.copy(), time.time())\n\n    def _scrape_yahoo_quote(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Scrape real-time quote from Yahoo Finance\"\"\"\n        if not self._rate_limit_check('yahoo_finance'):\n            return None\n            \n        try:\n            headers = {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n                'Accept-Language': 'en-US,en;q=0.5',\n                'Accept-Encoding': 'gzip, deflate',\n                'Connection': 'keep-alive',\n            }\n            \n            url = f\"https://finance.yahoo.com/quote/{symbol}\"\n            response = requests.get(url, headers=headers, timeout=10)\n            response.raise_for_status()\n            \n            soup = BeautifulSoup(response.content, 'html.parser')\n            \n            # Extract price data\n            price_element = soup.find('fin-streamer', {'data-symbol': symbol, 'data-field': 'regularMarketPrice'})\n            change_element = soup.find('fin-streamer', {'data-symbol': symbol, 'data-field': 'regularMarketChange'})\n            change_pct_element = soup.find('fin-streamer', {'data-symbol': symbol, 'data-field': 'regularMarketChangePercent'})\n            \n            if price_element:\n                try:\n                    current_price = float(price_element.text.replace(',', ''))\n                    change = float(change_element.text.replace(',', '')) if change_element else 0\n                    change_percent_text = change_pct_element.text if change_pct_element else \"0%\"\n                    change_percent = float(re.findall(r'[-+]?\\d*\\.?\\d+', change_percent_text)[0])\n                    \n                    return {\n                        'symbol': symbol,\n                        'price': current_price,\n                        'change': change,\n                        'change_percent': change_percent,\n                        'data_quality': DataQuality.NEAR_REAL_TIME,\n                        'source': 'yahoo_scrape',\n                        'timestamp': datetime.now().isoformat(),\n                        'market_state': 'REGULAR'  # Could be enhanced to detect pre/post market\n                    }\n                except (ValueError, IndexError) as e:\n                    logger.warning(f\"Error parsing Yahoo data for {symbol}: {e}\")\n                    return None\n                    \n        except Exception as e:\n            logger.warning(f\"Yahoo scraping failed for {symbol}: {e}\")\n            return None\n\n    def _get_yfinance_fallback(self, symbol: str, data_type: str) -> Optional[Dict]:\n        \"\"\"Get data from yfinance as fallback\"\"\"\n        try:\n            ticker = yf.Ticker(symbol)\n            \n            if data_type == 'stock_quote':\n                # Try fast_info first for more recent data\n                try:\n                    fast_info = ticker.fast_info\n                    current_price = fast_info.get('lastPrice')\n                    prev_close = fast_info.get('previousClose', current_price)\n                    \n                    if current_price and current_price > 0:\n                        change = current_price - prev_close\n                        change_percent = (change / prev_close) * 100 if prev_close > 0 else 0\n                        \n                        return {\n                            'symbol': symbol,\n                            'price': current_price,\n                            'change': change,\n                            'change_percent': change_percent,\n                            'volume': fast_info.get('regularMarketVolume', 0),\n                            'data_quality': DataQuality.FALLBACK,\n                            'source': 'yfinance_fast',\n                            'timestamp': datetime.now().isoformat()\n                        }\n                except Exception:\n                    pass  # Fall through to history method\n                \n                # Fallback to history method\n                hist = ticker.history(period=\"2d\")\n                if not hist.empty and len(hist) >= 2:\n                    current_price = hist['Close'].iloc[-1]\n                    prev_price = hist['Close'].iloc[-2] if len(hist) > 1 else current_price\n                    change = current_price - prev_price\n                    change_percent = (change / prev_price) * 100 if prev_price > 0 else 0\n                    \n                    return {\n                        'symbol': symbol,\n                        'price': current_price,\n                        'change': change,\n                        'change_percent': change_percent,\n                        'volume': hist['Volume'].iloc[-1],\n                        'data_quality': DataQuality.FALLBACK,\n                        'source': 'yfinance_history',\n                        'timestamp': datetime.now().isoformat()\n                    }\n                    \n        except Exception as e:\n            logger.error(f\"yfinance fallback failed for {symbol}: {e}\")\n            \n        return None\n\n    def get_stock_quote(self, symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n        \"\"\"Get real-time stock quote with multiple data source fallback\"\"\"\n        cache_key = self._cache_key(symbol, 'stock_quote')\n        \n        # Check cache first unless force refresh\n        if not force_refresh:\n            cached_data = self._get_from_cache(cache_key, self.cache_ttl['stock_quote'])\n            if cached_data:\n                return cached_data\n        \n        # Try data sources in priority order\n        data_sources_ordered = sorted(self.data_sources.items(), key=lambda x: x[1], reverse=True)\n        \n        for source_name, priority in data_sources_ordered:\n            try:\n                if source_name == 'yahoo_scrape':\n                    data = self._scrape_yahoo_quote(symbol)\n                elif source_name == 'yfinance':\n                    data = self._get_yfinance_fallback(symbol, 'stock_quote')\n                else:\n                    continue  # Skip unknown sources\n                \n                if data:\n                    # Add metadata\n                    data['retrieved_at'] = datetime.now().isoformat()\n                    data['cache_age'] = 0\n                    \n                    # Cache the successful result\n                    self._set_cache(cache_key, data)\n                    return data\n                    \n            except Exception as e:\n                logger.warning(f\"Data source {source_name} failed for {symbol}: {e}\")\n                continue\n        \n        # If all sources fail, return None\n        logger.error(f\"All data sources failed for {symbol}\")\n        return None\n\n    def get_multiple_quotes(self, symbols: List[str], force_refresh: bool = False) -> Dict[str, Dict]:\n        \"\"\"Get multiple stock quotes efficiently\"\"\"\n        results = {}\n        \n        for symbol in symbols:\n            quote_data = self.get_stock_quote(symbol, force_refresh)\n            if quote_data:\n                results[symbol] = quote_data\n        \n        return results\n\n    def get_index_data(self, symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n        \"\"\"Get real-time index data\"\"\"\n        cache_key = self._cache_key(symbol, 'index_data')\n        \n        if not force_refresh:\n            cached_data = self._get_from_cache(cache_key, self.cache_ttl['index_data'])\n            if cached_data:\n                return cached_data\n        \n        # For indices, try Yahoo scraping first, then yfinance\n        data = self._scrape_yahoo_quote(symbol)\n        if not data:\n            data = self._get_yfinance_fallback(symbol, 'stock_quote')\n        \n        if data:\n            data['retrieved_at'] = datetime.now().isoformat()\n            data['cache_age'] = 0\n            self._set_cache(cache_key, data)\n        \n        return data\n\n    def get_currency_data(self, symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n        \"\"\"Get real-time currency data\"\"\"\n        cache_key = self._cache_key(symbol, 'currency_data')\n        \n        if not force_refresh:\n            cached_data = self._get_from_cache(cache_key, self.cache_ttl['currency_data'])\n            if cached_data:\n                return cached_data\n        \n        # Currency pairs - use yfinance as primary source for now\n        data = self._get_yfinance_fallback(symbol, 'stock_quote')\n        \n        if data:\n            data['retrieved_at'] = datetime.now().isoformat()\n            data['cache_age'] = 0\n            # Currency data is typically less frequently updated\n            data['data_quality'] = DataQuality.NEAR_REAL_TIME\n            self._set_cache(cache_key, data)\n        \n        return data\n\n    def get_commodity_data(self, symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n        \"\"\"Get real-time commodity data\"\"\"\n        cache_key = self._cache_key(symbol, 'commodity_data')\n        \n        if not force_refresh:\n            cached_data = self._get_from_cache(cache_key, self.cache_ttl['commodity_data'])\n            if cached_data:\n                return cached_data\n        \n        # Try scraping first, then yfinance\n        data = self._scrape_yahoo_quote(symbol)\n        if not data:\n            data = self._get_yfinance_fallback(symbol, 'stock_quote')\n        \n        if data:\n            data['retrieved_at'] = datetime.now().isoformat()\n            data['cache_age'] = 0\n            self._set_cache(cache_key, data)\n        \n        return data\n\n    def get_crypto_data(self, symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n        \"\"\"Get real-time cryptocurrency data\"\"\"\n        cache_key = self._cache_key(symbol, 'crypto_data')\n        \n        if not force_refresh:\n            cached_data = self._get_from_cache(cache_key, self.cache_ttl['crypto_data'])\n            if cached_data:\n                return cached_data\n        \n        # Crypto data - try scraping first for more frequent updates\n        data = self._scrape_yahoo_quote(symbol)\n        if not data:\n            data = self._get_yfinance_fallback(symbol, 'stock_quote')\n        \n        if data:\n            data['retrieved_at'] = datetime.now().isoformat()\n            data['cache_age'] = 0\n            # Crypto should have better real-time quality\n            if data['data_quality'] == DataQuality.FALLBACK:\n                data['data_quality'] = DataQuality.NEAR_REAL_TIME\n            self._set_cache(cache_key, data)\n        \n        return data\n\n    def get_historical_data(self, symbol: str, period: str = \"1y\", interval: str = \"1d\") -> Optional[pd.DataFrame]:\n        \"\"\"Get historical data (primarily from yfinance)\"\"\"\n        cache_key = self._cache_key(symbol, 'historical_data', period=period, interval=interval)\n        \n        # Check cache\n        cached_data = self._get_from_cache(cache_key, self.cache_ttl['historical_data'])\n        if cached_data and 'data' in cached_data:\n            return cached_data['data']\n        \n        try:\n            ticker = yf.Ticker(symbol)\n            hist = ticker.history(period=period, interval=interval)\n            \n            if not hist.empty:\n                # Cache the historical data\n                cache_data = {\n                    'data': hist,\n                    'symbol': symbol,\n                    'period': period,\n                    'interval': interval,\n                    'data_quality': DataQuality.FALLBACK,  # Historical data doesn't need real-time\n                    'source': 'yfinance',\n                    'retrieved_at': datetime.now().isoformat()\n                }\n                self._set_cache(cache_key, cache_data)\n                return hist\n                \n        except Exception as e:\n            logger.error(f\"Historical data fetch failed for {symbol}: {e}\")\n        \n        return None\n\n    def get_company_info(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Get company information (from yfinance)\"\"\"\n        cache_key = self._cache_key(symbol, 'company_info')\n        \n        # Check cache (company info changes infrequently)\n        cached_data = self._get_from_cache(cache_key, self.cache_ttl['company_info'])\n        if cached_data and 'info' in cached_data:\n            return cached_data['info']\n        \n        try:\n            ticker = yf.Ticker(symbol)\n            info = ticker.info\n            \n            if info:\n                cache_data = {\n                    'info': info,\n                    'symbol': symbol,\n                    'data_quality': DataQuality.FALLBACK,  # Company info doesn't need real-time\n                    'source': 'yfinance',\n                    'retrieved_at': datetime.now().isoformat()\n                }\n                self._set_cache(cache_key, cache_data)\n                return info\n                \n        except Exception as e:\n            logger.error(f\"Company info fetch failed for {symbol}: {e}\")\n        \n        return None\n\n    def get_options_data(self, symbol: str, expiration: str = None) -> Optional[Dict]:\n        \"\"\"Get options data (from yfinance)\"\"\"\n        cache_key = self._cache_key(symbol, 'options_data', expiration=expiration or 'all')\n        \n        cached_data = self._get_from_cache(cache_key, self.cache_ttl['options_data'])\n        if cached_data and 'options' in cached_data:\n            return cached_data['options']\n        \n        try:\n            ticker = yf.Ticker(symbol)\n            \n            if expiration:\n                options_chain = ticker.option_chain(expiration)\n                options_data = {\n                    'calls': options_chain.calls,\n                    'puts': options_chain.puts,\n                    'expiration': expiration\n                }\n            else:\n                # Get all expirations\n                expirations = ticker.options\n                options_data = {\n                    'expirations': expirations\n                }\n            \n            cache_data = {\n                'options': options_data,\n                'symbol': symbol,\n                'data_quality': DataQuality.FALLBACK,\n                'source': 'yfinance',\n                'retrieved_at': datetime.now().isoformat()\n            }\n            self._set_cache(cache_key, cache_data)\n            return options_data\n            \n        except Exception as e:\n            logger.error(f\"Options data fetch failed for {symbol}: {e}\")\n        \n        return None\n\n    def is_market_hours(self) -> bool:\n        \"\"\"Check if it's currently market hours (NYSE)\"\"\"\n        try:\n            import pytz\n            ny_tz = pytz.timezone('America/New_York')\n            now = datetime.now(ny_tz)\n            \n            # Check if it's a weekday (Monday=0, Sunday=6)\n            if now.weekday() >= 5:  # Weekend\n                return False\n            \n            # Market hours: 9:30 AM to 4:00 PM EST\n            market_open = now.replace(hour=9, minute=30, second=0, microsecond=0)\n            market_close = now.replace(hour=16, minute=0, second=0, microsecond=0)\n            \n            return market_open <= now <= market_close\n            \n        except Exception:\n            # Fallback: assume market hours during typical business hours\n            return 9 <= datetime.now().hour <= 16\n\n    def get_cache_stats(self) -> Dict:\n        \"\"\"Get cache statistics\"\"\"\n        with self._cache_lock:\n            total_entries = len(self._cache)\n            total_size = sum(len(str(data)) for data, _ in self._cache.values())\n            \n            # Count by data type\n            type_counts = {}\n            for key in self._cache.keys():\n                data_type = key.split('_')[1] if '_' in key else 'unknown'\n                type_counts[data_type] = type_counts.get(data_type, 0) + 1\n            \n            return {\n                'total_entries': total_entries,\n                'total_size_bytes': total_size,\n                'type_counts': type_counts,\n                'cache_keys': list(self._cache.keys())\n            }\n\n    def clear_cache(self, data_type: str = None) -> None:\n        \"\"\"Clear cache - all or specific data type\"\"\"\n        with self._cache_lock:\n            if data_type:\n                # Clear specific data type\n                keys_to_remove = [key for key in self._cache.keys() if data_type in key]\n                for key in keys_to_remove:\n                    del self._cache[key]\n            else:\n                # Clear all cache\n                self._cache.clear()\n\n# Global instance\n_data_service = None\n\ndef get_data_service() -> MarketDataService:\n    \"\"\"Get singleton instance of data service\"\"\"\n    global _data_service\n    if _data_service is None:\n        _data_service = MarketDataService()\n    return _data_service\n\n# Convenience functions for backward compatibility\ndef get_real_time_quote(symbol: str, force_refresh: bool = False) -> Optional[Dict]:\n    \"\"\"Get real-time quote for a symbol\"\"\"\n    return get_data_service().get_stock_quote(symbol, force_refresh)\n\ndef get_multiple_real_time_quotes(symbols: List[str], force_refresh: bool = False) -> Dict[str, Dict]:\n    \"\"\"Get multiple real-time quotes\"\"\"\n    return get_data_service().get_multiple_quotes(symbols, force_refresh)\n\n# Data quality indicator helper functions\ndef format_data_quality_indicator(quality: str, age: float = 0) -> str:\n    \"\"\"Format data quality indicator for display\"\"\"\n    indicators = {\n        DataQuality.LIVE: \"üü¢ LIVE\",\n        DataQuality.NEAR_REAL_TIME: \"üü° NEAR REAL-TIME\", \n        DataQuality.DELAYED: \"üü† DELAYED\",\n        DataQuality.CACHED: \"üîµ CACHED\",\n        DataQuality.FALLBACK: \"üî¥ DELAYED\",\n        DataQuality.STALE: \"‚ö´ STALE\"\n    }\n    \n    indicator = indicators.get(quality, \"‚ùì UNKNOWN\")\n    \n    if age > 0:\n        if age < 60:\n            age_str = f\" ({age:.0f}s)\"\n        elif age < 3600:\n            age_str = f\" ({age/60:.0f}m)\"\n        else:\n            age_str = f\" ({age/3600:.1f}h)\"\n        indicator += age_str\n    \n    return indicator\n\ndef get_data_quality_color(quality: str) -> str:\n    \"\"\"Get color for data quality indicator\"\"\"\n    colors = {\n        DataQuality.LIVE: \"green\",\n        DataQuality.NEAR_REAL_TIME: \"orange\", \n        DataQuality.DELAYED: \"red\",\n        DataQuality.CACHED: \"blue\",\n        DataQuality.FALLBACK: \"red\",\n        DataQuality.STALE: \"gray\"\n    }\n    return colors.get(quality, \"gray\")\n\n# Streamlit caching decorators that use the new data service\ndef cache_realtime_data(ttl: int = 5):\n    \"\"\"Decorator for caching real-time data in Streamlit\"\"\"\n    def decorator(func):\n        @wraps(func)\n        @st.cache_data(ttl=ttl, show_spinner=False)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator","size_bytes":23458},"modules/earnings_calendar.py":{"content":"import streamlit as st\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta, date\nimport yfinance as yf\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport random\nfrom typing import Dict, List, Tuple, Optional\nfrom modules.user_auth import user_auth\nfrom modules.database import db_manager\nimport json\n\ndef display_earnings_calendar():\n    \"\"\"Display comprehensive earnings calendar with predictions\"\"\"\n    \n    st.header(\"üìä Earnings Calendar & Stock Direction Predictions\")\n    \n    # Initialize session state for earnings data\n    if 'earnings_favorites' not in st.session_state:\n        st.session_state.earnings_favorites = user_auth.get_user_preference('earnings', 'favorites', [])\n    if 'earnings_alerts' not in st.session_state:\n        st.session_state.earnings_alerts = user_auth.get_user_preference('earnings', 'alerts', [])\n    \n    # Main tabs\n    tab1, tab2, tab3, tab4, tab5 = st.tabs([\n        \"üìÖ Upcoming Earnings\", \n        \"üìà Direction Predictions\", \n        \"üìä Analysis Dashboard\",\n        \"‚≠ê Favorites & Alerts\",\n        \"üìã Historical Performance\"\n    ])\n    \n    with tab1:\n        display_upcoming_earnings()\n    \n    with tab2:\n        display_direction_predictions()\n    \n    with tab3:\n        display_analysis_dashboard()\n    \n    with tab4:\n        display_favorites_and_alerts()\n    \n    with tab5:\n        display_historical_performance()\n\ndef display_upcoming_earnings():\n    \"\"\"Display upcoming earnings announcements\"\"\"\n    \n    st.subheader(\"üìÖ Upcoming Earnings (Next 30 Days)\")\n    \n    # Filter controls\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        view_mode = st.selectbox(\"View Mode\", [\"Calendar View\", \"List View\"], key=\"earnings_view\")\n    \n    with col2:\n        sector_filter = st.selectbox(\n            \"Sector Filter\", \n            [\"All Sectors\", \"Technology\", \"Healthcare\", \"Financial\", \"Consumer Discretionary\", \n             \"Communication Services\", \"Industrials\", \"Consumer Staples\", \"Energy\", \"Utilities\", \"Materials\"]\n        )\n    \n    with col3:\n        market_cap_filter = st.selectbox(\n            \"Market Cap\", \n            [\"All\", \"Large Cap (>$10B)\", \"Mid Cap ($2B-$10B)\", \"Small Cap (<$2B)\"]\n        )\n    \n    with col4:\n        announcement_time = st.selectbox(\n            \"Announcement Time\",\n            [\"All\", \"Before Market Open\", \"After Market Close\", \"During Market Hours\"]\n        )\n    \n    # Search functionality\n    search_term = st.text_input(\"üîç Search Companies\", placeholder=\"Enter company name or ticker symbol\")\n    \n    # Generate upcoming earnings data\n    earnings_data = generate_upcoming_earnings_data()\n    \n    # Apply filters\n    filtered_data = apply_earnings_filters(\n        earnings_data, sector_filter, market_cap_filter, announcement_time, search_term\n    )\n    \n    if view_mode == \"Calendar View\":\n        display_earnings_calendar_view(filtered_data)\n    else:\n        display_earnings_list_view(filtered_data)\n\ndef display_direction_predictions():\n    \"\"\"Display stock direction predictions based on historical patterns\"\"\"\n    \n    st.subheader(\"üìà Stock Direction Predictions\")\n    \n    st.info(\"üí° Predictions based on historical price patterns 5 days before and after earnings announcements\")\n    \n    # Get upcoming earnings with predictions\n    earnings_data = generate_upcoming_earnings_data()\n    \n    # Add prediction data\n    for earning in earnings_data:\n        prediction_data = calculate_stock_direction_prediction(earning['symbol'])\n        earning.update(prediction_data)\n    \n    # Sort by prediction confidence\n    earnings_data.sort(key=lambda x: x.get('confidence', 0), reverse=True)\n    \n    # Display top predictions\n    st.subheader(\"üèÜ High Confidence Predictions\")\n    \n    high_confidence = [e for e in earnings_data if e.get('confidence', 0) >= 70]\n    \n    if high_confidence:\n        for i, earning in enumerate(high_confidence[:10]):\n            with st.expander(f\"#{i+1} {earning['company']} ({earning['symbol']}) - {earning['prediction_direction']} ({earning['confidence']}% confidence)\"):\n                display_prediction_details(earning)\n    else:\n        st.info(\"No high confidence predictions available for current period\")\n    \n    # Prediction summary\n    st.subheader(\"üìä Prediction Summary\")\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        bullish_count = len([e for e in earnings_data if e.get('prediction_direction') == 'Bullish'])\n        st.metric(\"Bullish Predictions\", bullish_count)\n    \n    with col2:\n        bearish_count = len([e for e in earnings_data if e.get('prediction_direction') == 'Bearish'])\n        st.metric(\"Bearish Predictions\", bearish_count)\n    \n    with col3:\n        neutral_count = len([e for e in earnings_data if e.get('prediction_direction') == 'Neutral'])\n        st.metric(\"Neutral Predictions\", neutral_count)\n    \n    with col4:\n        avg_confidence = np.mean([e.get('confidence', 0) for e in earnings_data if e.get('confidence')])\n        st.metric(\"Avg Confidence\", f\"{avg_confidence:.1f}%\")\n    \n    # Detailed predictions table\n    st.subheader(\"üìã All Predictions\")\n    \n    predictions_df = pd.DataFrame([\n        {\n            'Symbol': e['symbol'],\n            'Company': e['company'],\n            'Date': e['date'],\n            'Prediction': e.get('prediction_direction', 'N/A'),\n            'Confidence': f\"{e.get('confidence', 0):.1f}%\",\n            'Expected Move': f\"{e.get('expected_move', 0):.1f}%\",\n            'Historical Accuracy': f\"{e.get('historical_accuracy', 0):.1f}%\"\n        }\n        for e in earnings_data\n    ])\n    \n    # Color code predictions\n    def color_prediction(val):\n        if 'Bullish' in str(val):\n            return 'background-color: #90EE90'\n        elif 'Bearish' in str(val):\n            return 'background-color: #FFB6C1'\n        else:\n            return 'background-color: #FFFFE0'\n    \n    styled_df = predictions_df.style.applymap(color_prediction, subset=['Prediction'])\n    st.dataframe(styled_df, use_container_width=True)\n\ndef display_analysis_dashboard():\n    \"\"\"Display comprehensive earnings analysis dashboard\"\"\"\n    \n    st.subheader(\"üìä Earnings Analysis Dashboard\")\n    \n    # Analysis type selector\n    analysis_type = st.selectbox(\n        \"Analysis Type\",\n        [\"Pre-Earnings Volatility\", \"Post-Earnings Reactions\", \"Sector Comparison\", \"Earnings Surprise Impact\"]\n    )\n    \n    if analysis_type == \"Pre-Earnings Volatility\":\n        display_pre_earnings_volatility()\n    elif analysis_type == \"Post-Earnings Reactions\":\n        display_post_earnings_reactions()\n    elif analysis_type == \"Sector Comparison\":\n        display_sector_comparison()\n    else:\n        display_earnings_surprise_impact()\n\ndef display_favorites_and_alerts():\n    \"\"\"Display favorites and alert management\"\"\"\n    \n    st.subheader(\"‚≠ê Favorites & Earnings Alerts\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"### üåü Favorite Earnings Stocks\")\n        \n        # Add to favorites\n        new_favorite = st.text_input(\"Add Stock to Favorites\", placeholder=\"Enter ticker symbol\")\n        if st.button(\"Add Favorite\") and new_favorite:\n            if new_favorite.upper() not in st.session_state.earnings_favorites:\n                st.session_state.earnings_favorites.append(new_favorite.upper())\n                user_auth.auto_save_preference('earnings', 'favorites', st.session_state.earnings_favorites)\n                st.success(f\"Added {new_favorite.upper()} to favorites\")\n                st.rerun()\n        \n        # Display favorites\n        if st.session_state.earnings_favorites:\n            for symbol in st.session_state.earnings_favorites:\n                col_symbol, col_remove = st.columns([3, 1])\n                with col_symbol:\n                    st.write(f\"üìà {symbol}\")\n                with col_remove:\n                    if st.button(\"‚ùå\", key=f\"remove_fav_{symbol}\"):\n                        st.session_state.earnings_favorites.remove(symbol)\n                        user_auth.auto_save_preference('earnings', 'favorites', st.session_state.earnings_favorites)\n                        st.rerun()\n        else:\n            st.info(\"No favorite stocks added yet\")\n    \n    with col2:\n        st.markdown(\"### üö® Earnings Alerts\")\n        \n        # Alert configuration\n        with st.form(\"earnings_alert_form\"):\n            alert_symbol = st.text_input(\"Stock Symbol\")\n            alert_type = st.selectbox(\"Alert Type\", [\n                \"Upcoming Earnings (1 day before)\",\n                \"High Confidence Prediction (>80%)\",\n                \"High Volatility Expected (>5%)\",\n                \"Earnings Surprise (>10% beat/miss)\"\n            ])\n            alert_enabled = st.checkbox(\"Enable Alert\", value=True)\n            \n            if st.form_submit_button(\"Create Alert\"):\n                alert_data = {\n                    'symbol': alert_symbol.upper(),\n                    'type': alert_type,\n                    'enabled': alert_enabled,\n                    'created_date': datetime.now().isoformat()\n                }\n                st.session_state.earnings_alerts.append(alert_data)\n                user_auth.auto_save_preference('earnings', 'alerts', st.session_state.earnings_alerts)\n                st.success(\"Alert created successfully!\")\n                st.rerun()\n        \n        # Display active alerts\n        if st.session_state.earnings_alerts:\n            st.markdown(\"#### Active Alerts\")\n            for i, alert in enumerate(st.session_state.earnings_alerts):\n                with st.expander(f\"{alert['symbol']} - {alert['type']}\"):\n                    col_toggle, col_delete = st.columns(2)\n                    with col_toggle:\n                        if st.button(\"üîï Disable\" if alert['enabled'] else \"üîî Enable\", key=f\"toggle_alert_{i}\"):\n                            st.session_state.earnings_alerts[i]['enabled'] = not alert['enabled']\n                            user_auth.auto_save_preference('earnings', 'alerts', st.session_state.earnings_alerts)\n                            st.rerun()\n                    with col_delete:\n                        if st.button(\"üóëÔ∏è Delete\", key=f\"delete_alert_{i}\"):\n                            st.session_state.earnings_alerts.pop(i)\n                            user_auth.auto_save_preference('earnings', 'alerts', st.session_state.earnings_alerts)\n                            st.rerun()\n        else:\n            st.info(\"No alerts configured\")\n\ndef display_historical_performance():\n    \"\"\"Display historical earnings performance analysis\"\"\"\n    \n    st.subheader(\"üìã Historical Earnings Performance\")\n    \n    # Performance metrics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Beat Rate (Last Quarter)\", \"68%\", \"+2%\")\n    \n    with col2:\n        st.metric(\"Average Surprise\", \"+2.3%\", \"-0.5%\")\n    \n    with col3:\n        st.metric(\"Positive Reactions\", \"72%\", \"+5%\")\n    \n    with col4:\n        st.metric(\"Avg Post-Earnings Move\", \"4.2%\", \"+0.8%\")\n    \n    # Historical performance chart\n    st.subheader(\"üìà Quarterly Performance Trends\")\n    \n    # Generate sample historical data\n    quarters = ['Q4 2023', 'Q1 2024', 'Q2 2024', 'Q3 2024']\n    beat_rates = [66, 70, 68, 72]\n    avg_moves = [3.8, 4.1, 3.9, 4.2]\n    \n    fig = make_subplots(\n        rows=2, cols=1,\n        subplot_titles=('Earnings Beat Rate (%)', 'Average Post-Earnings Move (%)'),\n        vertical_spacing=0.1\n    )\n    \n    fig.add_trace(\n        go.Scatter(x=quarters, y=beat_rates, mode='lines+markers', name='Beat Rate', line=dict(color='green')),\n        row=1, col=1\n    )\n    \n    fig.add_trace(\n        go.Scatter(x=quarters, y=avg_moves, mode='lines+markers', name='Avg Move', line=dict(color='blue')),\n        row=2, col=1\n    )\n    \n    fig.update_layout(height=500, showlegend=True)\n    st.plotly_chart(fig, use_container_width=True)\n    \n    # Top performers\n    st.subheader(\"üèÜ Top Earnings Performers (Last Quarter)\")\n    \n    top_performers = [\n        {'Symbol': 'NVDA', 'Company': 'NVIDIA Corporation', 'Surprise': '+15.2%', 'Move': '+8.5%'},\n        {'Symbol': 'MSFT', 'Company': 'Microsoft Corporation', 'Surprise': '+8.7%', 'Move': '+5.2%'},\n        {'Symbol': 'GOOGL', 'Company': 'Alphabet Inc.', 'Surprise': '+12.1%', 'Move': '+6.8%'},\n        {'Symbol': 'AAPL', 'Company': 'Apple Inc.', 'Surprise': '+5.3%', 'Move': '+3.1%'},\n        {'Symbol': 'TSLA', 'Company': 'Tesla Inc.', 'Surprise': '+22.4%', 'Move': '+12.3%'}\n    ]\n    \n    performers_df = pd.DataFrame(top_performers)\n    st.dataframe(performers_df, use_container_width=True)\n\ndef generate_upcoming_earnings_data():\n    \"\"\"Generate realistic upcoming earnings data for S&P 500 companies\"\"\"\n    \n    # Major S&P 500 companies with realistic data\n    companies = [\n        {\n            'symbol': 'AAPL', 'company': 'Apple Inc.', 'sector': 'Technology',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'MSFT', 'company': 'Microsoft Corporation', 'sector': 'Technology',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'GOOGL', 'company': 'Alphabet Inc.', 'sector': 'Communication Services',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'AMZN', 'company': 'Amazon.com Inc.', 'sector': 'Consumer Discretionary',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'TSLA', 'company': 'Tesla Inc.', 'sector': 'Consumer Discretionary',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'NVDA', 'company': 'NVIDIA Corporation', 'sector': 'Technology',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'META', 'company': 'Meta Platforms Inc.', 'sector': 'Communication Services',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'BRK-B', 'company': 'Berkshire Hathaway Inc.', 'sector': 'Financial',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'JPM', 'company': 'JPMorgan Chase & Co.', 'sector': 'Financial',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'JNJ', 'company': 'Johnson & Johnson', 'sector': 'Healthcare',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'V', 'company': 'Visa Inc.', 'sector': 'Financial',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'PG', 'company': 'Procter & Gamble Co.', 'sector': 'Consumer Staples',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'UNH', 'company': 'UnitedHealth Group Inc.', 'sector': 'Healthcare',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'HD', 'company': 'The Home Depot Inc.', 'sector': 'Consumer Discretionary',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'MA', 'company': 'Mastercard Incorporated', 'sector': 'Financial',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'BAC', 'company': 'Bank of America Corp.', 'sector': 'Financial',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'ABBV', 'company': 'AbbVie Inc.', 'sector': 'Healthcare',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'CRM', 'company': 'Salesforce Inc.', 'sector': 'Technology',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        },\n        {\n            'symbol': 'XOM', 'company': 'Exxon Mobil Corporation', 'sector': 'Energy',\n            'market_cap': 'Large Cap', 'announcement_time': 'Before Market Open'\n        },\n        {\n            'symbol': 'DIS', 'company': 'The Walt Disney Company', 'sector': 'Communication Services',\n            'market_cap': 'Large Cap', 'announcement_time': 'After Market Close'\n        }\n    ]\n    \n    earnings_data = []\n    start_date = datetime.now().date()\n    \n    for i, company in enumerate(companies):\n        # Generate earnings date within next 30 days\n        days_ahead = random.randint(1, 30)\n        earnings_date = start_date + timedelta(days=days_ahead)\n        \n        # Skip weekends\n        while earnings_date.weekday() >= 5:\n            earnings_date += timedelta(days=1)\n        \n        # Generate realistic earnings data\n        earnings_data.append({\n            **company,\n            'date': earnings_date.strftime('%Y-%m-%d'),\n            'quarter': f\"Q{((earnings_date.month - 1) // 3) + 1} {earnings_date.year}\",\n            'eps_estimate': round(random.uniform(0.5, 5.0), 2),\n            'eps_previous': round(random.uniform(0.4, 4.8), 2),\n            'revenue_estimate': f\"${random.randint(10, 200)}B\",\n            'beat_miss_history': f\"{random.randint(60, 85)}% beat rate\",\n            'analyst_coverage': random.randint(15, 45),\n            'days_until': days_ahead\n        })\n    \n    return sorted(earnings_data, key=lambda x: x['date'])\n\ndef apply_earnings_filters(data, sector_filter, market_cap_filter, announcement_time, search_term):\n    \"\"\"Apply filters to earnings data\"\"\"\n    \n    filtered_data = data.copy()\n    \n    # Sector filter\n    if sector_filter != \"All Sectors\":\n        filtered_data = [d for d in filtered_data if d['sector'] == sector_filter]\n    \n    # Market cap filter\n    if market_cap_filter != \"All\":\n        if \"Large Cap\" in market_cap_filter:\n            filtered_data = [d for d in filtered_data if d['market_cap'] == 'Large Cap']\n        elif \"Mid Cap\" in market_cap_filter:\n            filtered_data = [d for d in filtered_data if d['market_cap'] == 'Mid Cap']\n        elif \"Small Cap\" in market_cap_filter:\n            filtered_data = [d for d in filtered_data if d['market_cap'] == 'Small Cap']\n    \n    # Announcement time filter\n    if announcement_time != \"All\":\n        filtered_data = [d for d in filtered_data if d['announcement_time'] == announcement_time]\n    \n    # Search term filter\n    if search_term:\n        search_term = search_term.lower()\n        filtered_data = [\n            d for d in filtered_data \n            if search_term in d['symbol'].lower() or search_term in d['company'].lower()\n        ]\n    \n    return filtered_data\n\ndef display_earnings_calendar_view(earnings_data):\n    \"\"\"Display earnings in calendar format\"\"\"\n    \n    st.subheader(\"üìÖ Calendar View\")\n    \n    # Group earnings by date\n    earnings_by_date = {}\n    for earning in earnings_data:\n        date_key = earning['date']\n        if date_key not in earnings_by_date:\n            earnings_by_date[date_key] = []\n        earnings_by_date[date_key].append(earning)\n    \n    # Display calendar\n    for date_str, day_earnings in sorted(earnings_by_date.items()):\n        date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()\n        day_name = date_obj.strftime('%A')\n        \n        st.markdown(f\"### üìÖ {day_name}, {date_obj.strftime('%B %d, %Y')}\")\n        \n        for earning in day_earnings:\n            with st.expander(f\"üè¢ {earning['company']} ({earning['symbol']}) - {earning['announcement_time']}\"):\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.markdown(f\"**Sector:** {earning['sector']}\")\n                    st.markdown(f\"**Quarter:** {earning['quarter']}\")\n                    st.markdown(f\"**EPS Estimate:** ${earning['eps_estimate']}\")\n                    st.markdown(f\"**Previous EPS:** ${earning['eps_previous']}\")\n                \n                with col2:\n                    st.markdown(f\"**Revenue Estimate:** {earning['revenue_estimate']}\")\n                    st.markdown(f\"**Beat/Miss History:** {earning['beat_miss_history']}\")\n                    st.markdown(f\"**Analyst Coverage:** {earning['analyst_coverage']} analysts\")\n                    \n                    # Add to favorites button\n                    if st.button(f\"‚≠ê Add to Favorites\", key=f\"fav_{earning['symbol']}\"):\n                        if earning['symbol'] not in st.session_state.earnings_favorites:\n                            st.session_state.earnings_favorites.append(earning['symbol'])\n                            user_auth.auto_save_preference('earnings', 'favorites', st.session_state.earnings_favorites)\n                            st.success(f\"Added {earning['symbol']} to favorites\")\n\ndef display_earnings_list_view(earnings_data):\n    \"\"\"Display earnings in list format\"\"\"\n    \n    st.subheader(\"üìã List View\")\n    \n    # Convert to DataFrame for display\n    df_data = []\n    for earning in earnings_data:\n        df_data.append({\n            'Date': earning['date'],\n            'Symbol': earning['symbol'],\n            'Company': earning['company'],\n            'Sector': earning['sector'],\n            'Time': earning['announcement_time'],\n            'EPS Est.': f\"${earning['eps_estimate']}\",\n            'EPS Prev.': f\"${earning['eps_previous']}\",\n            'Revenue Est.': earning['revenue_estimate'],\n            'Days Until': earning['days_until']\n        })\n    \n    df = pd.DataFrame(df_data)\n    \n    # Color code by days until earnings\n    def color_days_until(val):\n        if val <= 1:\n            return 'background-color: #ffcccc'\n        elif val <= 3:\n            return 'background-color: #ffffcc'\n        elif val <= 7:\n            return 'background-color: #ccffcc'\n        else:\n            return ''\n    \n    styled_df = df.style.applymap(color_days_until, subset=['Days Until'])\n    st.dataframe(styled_df, use_container_width=True)\n\ndef calculate_stock_direction_prediction(symbol):\n    \"\"\"Calculate stock direction prediction based on historical patterns\"\"\"\n    \n    try:\n        # Get historical data (simulated analysis)\n        ticker = yf.Ticker(symbol)\n        hist = ticker.history(period=\"2y\")\n        \n        if hist.empty:\n            return {\n                'prediction_direction': 'Neutral',\n                'confidence': 50,\n                'expected_move': 0,\n                'historical_accuracy': 50\n            }\n        \n        # Simulate earnings analysis (in real scenario, would need earnings dates)\n        # Calculate volatility and trends\n        returns = hist['Close'].pct_change().dropna()\n        volatility = returns.std() * 100\n        trend = (hist['Close'].iloc[-20:].mean() / hist['Close'].iloc[-40:-20].mean() - 1) * 100\n        \n        # Prediction logic (simplified)\n        if trend > 5 and volatility < 3:\n            direction = 'Bullish'\n            confidence = min(85, 60 + abs(trend))\n        elif trend < -5 and volatility < 3:\n            direction = 'Bearish'\n            confidence = min(85, 60 + abs(trend))\n        else:\n            direction = 'Neutral'\n            confidence = 50 + random.uniform(-10, 10)\n        \n        expected_move = volatility * random.uniform(0.8, 1.5)\n        historical_accuracy = random.uniform(55, 80)\n        \n        return {\n            'prediction_direction': direction,\n            'confidence': round(confidence, 1),\n            'expected_move': round(expected_move, 1),\n            'historical_accuracy': round(historical_accuracy, 1)\n        }\n        \n    except Exception as e:\n        return {\n            'prediction_direction': 'Neutral',\n            'confidence': 50,\n            'expected_move': 0,\n            'historical_accuracy': 50\n        }\n\ndef display_prediction_details(earning):\n    \"\"\"Display detailed prediction information\"\"\"\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"**üìä Prediction Details**\")\n        st.markdown(f\"Direction: **{earning['prediction_direction']}**\")\n        st.markdown(f\"Confidence: **{earning['confidence']}%**\")\n        st.markdown(f\"Expected Move: **¬±{earning['expected_move']}%**\")\n        \n    with col2:\n        st.markdown(\"**üìà Historical Context**\")\n        st.markdown(f\"Historical Accuracy: **{earning['historical_accuracy']}%**\")\n        st.markdown(f\"Earnings Date: **{earning['date']}**\")\n        st.markdown(f\"Announcement Time: **{earning['announcement_time']}**\")\n    \n    # Prediction reasoning (simplified)\n    st.markdown(\"**üéØ Prediction Reasoning:**\")\n    if earning['prediction_direction'] == 'Bullish':\n        st.markdown(\"- Strong upward trend in recent weeks\")\n        st.markdown(\"- Lower than average volatility suggests stability\")\n        st.markdown(\"- Historical post-earnings performance positive\")\n    elif earning['prediction_direction'] == 'Bearish':\n        st.markdown(\"- Downward trend pattern identified\")\n        st.markdown(\"- Recent negative market sentiment\")\n        st.markdown(\"- Challenging sector environment\")\n    else:\n        st.markdown(\"- Mixed signals in technical indicators\")\n        st.markdown(\"- Neutral market sentiment\")\n        st.markdown(\"- Outcome highly dependent on earnings results\")\n\ndef display_pre_earnings_volatility():\n    \"\"\"Display pre-earnings volatility analysis\"\"\"\n    \n    st.subheader(\"üìä Pre-Earnings Volatility Analysis\")\n    \n    # Sample volatility data\n    symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    volatility_data = []\n    \n    for symbol in symbols:\n        current_vol = random.uniform(1.5, 8.0)\n        historical_avg = random.uniform(2.0, 6.0)\n        ratio = current_vol / historical_avg\n        \n        volatility_data.append({\n            'Symbol': symbol,\n            'Current Volatility': f\"{current_vol:.1f}%\",\n            'Historical Average': f\"{historical_avg:.1f}%\",\n            'Ratio': f\"{ratio:.2f}x\",\n            'Status': 'High' if ratio > 1.3 else 'Normal' if ratio > 0.8 else 'Low'\n        })\n    \n    df = pd.DataFrame(volatility_data)\n    \n    def color_status(val):\n        if val == 'High':\n            return 'background-color: #ffcccc'\n        elif val == 'Low':\n            return 'background-color: #ccffcc'\n        else:\n            return 'background-color: #ffffcc'\n    \n    styled_df = df.style.applymap(color_status, subset=['Status'])\n    st.dataframe(styled_df, use_container_width=True)\n\ndef display_post_earnings_reactions():\n    \"\"\"Display post-earnings reaction analysis\"\"\"\n    \n    st.subheader(\"üìà Post-Earnings Reaction Analysis\")\n    \n    # Sample reaction data\n    reaction_data = [\n        {'Company': 'Apple Inc.', 'Symbol': 'AAPL', 'Beat/Miss': 'Beat', 'Reaction': '+3.2%', 'Days': 1},\n        {'Company': 'Microsoft Corp.', 'Symbol': 'MSFT', 'Beat/Miss': 'Beat', 'Reaction': '+5.1%', 'Days': 1},\n        {'Company': 'Tesla Inc.', 'Symbol': 'TSLA', 'Beat/Miss': 'Miss', 'Reaction': '-8.3%', 'Days': 1},\n        {'Company': 'Amazon.com Inc.', 'Symbol': 'AMZN', 'Beat/Miss': 'Beat', 'Reaction': '+1.8%', 'Days': 1},\n        {'Company': 'NVIDIA Corp.', 'Symbol': 'NVDA', 'Beat/Miss': 'Beat', 'Reaction': '+12.5%', 'Days': 1}\n    ]\n    \n    df = pd.DataFrame(reaction_data)\n    \n    def color_reaction(val):\n        if '+' in str(val):\n            return 'background-color: #ccffcc'\n        else:\n            return 'background-color: #ffcccc'\n    \n    styled_df = df.style.applymap(color_reaction, subset=['Reaction'])\n    st.dataframe(styled_df, use_container_width=True)\n    \n    # Reaction chart\n    fig = px.bar(\n        df, x='Symbol', y=[float(r.replace('%', '').replace('+', '')) for r in df['Reaction']], \n        title='Post-Earnings Reactions (%)',\n        color=[float(r.replace('%', '').replace('+', '')) for r in df['Reaction']],\n        color_continuous_scale='RdYlGn'\n    )\n    st.plotly_chart(fig, use_container_width=True)\n\ndef display_sector_comparison():\n    \"\"\"Display sector-based earnings performance comparison\"\"\"\n    \n    st.subheader(\"üè¢ Sector Earnings Performance Comparison\")\n    \n    # Sample sector data\n    sector_data = [\n        {'Sector': 'Technology', 'Beat Rate': '75%', 'Avg Move': '+4.2%', 'Companies': 45},\n        {'Sector': 'Healthcare', 'Beat Rate': '68%', 'Avg Move': '+2.8%', 'Companies': 32},\n        {'Sector': 'Financial', 'Beat Rate': '72%', 'Avg Move': '+3.5%', 'Companies': 28},\n        {'Sector': 'Consumer Discretionary', 'Beat Rate': '65%', 'Avg Move': '+5.1%', 'Companies': 24},\n        {'Sector': 'Energy', 'Beat Rate': '58%', 'Avg Move': '+6.8%', 'Companies': 18}\n    ]\n    \n    df = pd.DataFrame(sector_data)\n    st.dataframe(df, use_container_width=True)\n    \n    # Sector performance chart\n    beat_rates = [int(br.replace('%', '')) for br in df['Beat Rate']]\n    \n    fig = px.bar(\n        df, x='Sector', y=beat_rates,\n        title='Earnings Beat Rate by Sector (%)',\n        text=df['Beat Rate']\n    )\n    fig.update_traces(textposition='outside')\n    st.plotly_chart(fig, use_container_width=True)\n\ndef display_earnings_surprise_impact():\n    \"\"\"Display earnings surprise impact analysis\"\"\"\n    \n    st.subheader(\"üéØ Earnings Surprise Impact Analysis\")\n    \n    st.info(\"Analysis of how different levels of earnings surprises impact stock prices\")\n    \n    # Sample surprise impact data\n    surprise_ranges = ['> +20%', '+10% to +20%', '+5% to +10%', '0% to +5%', '-5% to 0%', '< -5%']\n    avg_reactions = [15.2, 8.5, 4.2, 1.8, -2.1, -8.7]\n    \n    fig = px.bar(\n        x=surprise_ranges, y=avg_reactions,\n        title='Average Stock Reaction by Earnings Surprise Level',\n        labels={'x': 'Earnings Surprise Range', 'y': 'Average Stock Reaction (%)'},\n        color=avg_reactions,\n        color_continuous_scale='RdYlGn'\n    )\n    st.plotly_chart(fig, use_container_width=True)\n    \n    # Impact summary\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.metric(\"Big Beat Impact\", \"+15.2%\", \"avg reaction > +20% surprise\")\n    \n    with col2:\n        st.metric(\"Small Beat Impact\", \"+4.2%\", \"avg reaction +5% to +10% surprise\")\n    \n    with col3:\n        st.metric(\"Miss Impact\", \"-8.7%\", \"avg reaction < -5% surprise\")","size_bytes":30564},"modules/futures_overview.py":{"content":"import streamlit as st\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom plotly.subplots import make_subplots\nimport pandas as pd\nimport numpy as np\nimport yfinance as yf\nfrom datetime import datetime, timedelta\nfrom modules.user_auth import user_auth\nfrom modules import utils\nfrom modules.data_service import get_data_service, format_data_quality_indicator, get_data_quality_color\nimport json\n\n# Futures contracts and their symbols with fallback ETFs\nFUTURES_CONTRACTS = {\n    \"US Indices\": {\n        \"ES (S&P 500)\": {\"symbol\": \"ES=F\", \"fallback\": \"SPY\", \"name\": \"S&P 500 Futures\"},\n        \"NQ (NASDAQ)\": {\"symbol\": \"NQ=F\", \"fallback\": \"QQQ\", \"name\": \"NASDAQ Futures\"},\n        \"YM (Dow)\": {\"symbol\": \"YM=F\", \"fallback\": \"DIA\", \"name\": \"Dow Futures\"},\n        \"RTY (Russell 2000)\": {\"symbol\": \"RTY=F\", \"fallback\": \"IWM\", \"name\": \"Russell 2000 Futures\"}\n    },\n    \"Energy\": {\n        \"CL (Crude Oil)\": {\"symbol\": \"CL=F\", \"fallback\": \"USO\", \"name\": \"Crude Oil Futures\"},\n        \"NG (Natural Gas)\": {\"symbol\": \"NG=F\", \"fallback\": \"UNG\", \"name\": \"Natural Gas Futures\"},\n        \"HO (Heating Oil)\": {\"symbol\": \"HO=F\", \"fallback\": \"UHN\", \"name\": \"Heating Oil Futures\"},\n        \"RB (Gasoline)\": {\"symbol\": \"RB=F\", \"fallback\": \"UGA\", \"name\": \"Gasoline Futures\"}\n    },\n    \"Metals\": {\n        \"GC (Gold)\": {\"symbol\": \"GC=F\", \"fallback\": \"GLD\", \"name\": \"Gold Futures\"},\n        \"SI (Silver)\": {\"symbol\": \"SI=F\", \"fallback\": \"SLV\", \"name\": \"Silver Futures\"},\n        \"HG (Copper)\": {\"symbol\": \"HG=F\", \"fallback\": \"CPER\", \"name\": \"Copper Futures\"},\n        \"PA (Palladium)\": {\"symbol\": \"PA=F\", \"fallback\": \"PALL\", \"name\": \"Palladium Futures\"},\n        \"PL (Platinum)\": {\"symbol\": \"PL=F\", \"fallback\": \"PPLT\", \"name\": \"Platinum Futures\"}\n    },\n    \"Agriculture\": {\n        \"ZW (Wheat)\": {\"symbol\": \"ZW=F\", \"fallback\": \"WEAT\", \"name\": \"Wheat Futures\"},\n        \"ZC (Corn)\": {\"symbol\": \"ZC=F\", \"fallback\": \"CORN\", \"name\": \"Corn Futures\"},\n        \"ZS (Soybeans)\": {\"symbol\": \"ZS=F\", \"fallback\": \"SOYB\", \"name\": \"Soybean Futures\"},\n        \"CT (Cotton)\": {\"symbol\": \"CT=F\", \"fallback\": \"BAL\", \"name\": \"Cotton Futures\"},\n        \"SB (Sugar)\": {\"symbol\": \"SB=F\", \"fallback\": \"CANE\", \"name\": \"Sugar Futures\"}\n    },\n    \"Currency\": {\n        \"EUR/USD\": {\"symbol\": \"EURUSD=X\", \"fallback\": \"FXE\", \"name\": \"Euro/USD\"},\n        \"GBP/USD\": {\"symbol\": \"GBPUSD=X\", \"fallback\": \"FXB\", \"name\": \"British Pound/USD\"},\n        \"USD/JPY\": {\"symbol\": \"USDJPY=X\", \"fallback\": \"FXY\", \"name\": \"USD/Japanese Yen\"},\n        \"USD/CAD\": {\"symbol\": \"USDCAD=X\", \"fallback\": \"FXC\", \"name\": \"USD/Canadian Dollar\"}\n    },\n    \"Canadian\": {\n        \"TSX Index\": {\"symbol\": \"^GSPTSE\", \"fallback\": \"TDB902\", \"name\": \"TSX Composite Index\"},\n        \"CAD Futures\": {\"symbol\": \"CAD=X\", \"fallback\": \"FXC\", \"name\": \"Canadian Dollar Futures\"}\n    }\n}\n\ndef get_futures_data(symbol, fallback_symbol=None, period=\"1d\", force_refresh=False):\n    \"\"\"Get futures data with real-time capabilities and fallback support\"\"\"\n    try:\n        data_service = get_data_service()\n        \n        # For real-time data (current prices), use data service\n        if period == \"1d\":\n            # Try to get real-time quote first\n            quote_data = data_service.get_stock_quote(symbol, force_refresh=force_refresh)\n            \n            # If primary symbol fails and we have fallback, try fallback\n            if not quote_data and fallback_symbol:\n                quote_data = data_service.get_stock_quote(fallback_symbol, force_refresh=force_refresh)\n                symbol = fallback_symbol  # Update symbol for consistency\n            \n            if quote_data:\n                # Get historical data for charting\n                hist = data_service.get_historical_data(symbol, period=period)\n                if hist is None:\n                    # Fallback to yfinance for historical data if needed\n                    ticker = yf.Ticker(symbol)\n                    hist = ticker.history(period=period, interval=\"1m\")\n                \n                # Get company info\n                info = data_service.get_company_info(symbol) or {}\n                \n                result = {\n                    'symbol': symbol,\n                    'history': hist if hist is not None else pd.DataFrame(),\n                    'current_price': quote_data.get('price', 0),\n                    'change': quote_data.get('change', 0),\n                    'change_percent': quote_data.get('change_percent', 0),\n                    'volume': quote_data.get('volume', 0),\n                    'info': info,\n                    'data_quality': quote_data.get('data_quality', 'unknown'),\n                    'source': quote_data.get('source', 'unknown'),\n                    'timestamp': quote_data.get('timestamp', datetime.now().isoformat()),\n                    'cache_age': quote_data.get('cache_age', 0),\n                    'quality_indicator': format_data_quality_indicator(\n                        quote_data.get('data_quality', 'unknown'), \n                        quote_data.get('cache_age', 0)\n                    ),\n                    'quality_color': get_data_quality_color(quote_data.get('data_quality', 'unknown'))\n                }\n                return result\n        \n        # Fallback to original yfinance method for longer periods or if real-time fails\n        ticker = yf.Ticker(symbol)\n        hist = ticker.history(period=period, interval=\"1m\" if period == \"1d\" else \"1d\")\n        \n        if hist.empty and fallback_symbol:\n            # Try fallback symbol\n            ticker = yf.Ticker(fallback_symbol)\n            hist = ticker.history(period=period, interval=\"1m\" if period == \"1d\" else \"1d\")\n            symbol = fallback_symbol  # Update symbol for info retrieval\n        \n        if not hist.empty:\n            info = ticker.info\n            current_price = hist['Close'].iloc[-1]\n            \n            # Calculate change\n            if len(hist) >= 2:\n                prev_price = hist['Close'].iloc[-2] if period == \"1d\" else hist['Close'].iloc[0]\n                change = current_price - prev_price\n                change_percent = (change / prev_price) * 100 if prev_price != 0 else 0\n            else:\n                change = 0\n                change_percent = 0\n            \n            return {\n                'symbol': symbol,\n                'history': hist,\n                'current_price': current_price,\n                'change': change,\n                'change_percent': change_percent,\n                'volume': hist['Volume'].iloc[-1] if 'Volume' in hist.columns else 0,\n                'info': info,\n                'data_quality': 'fallback',\n                'source': 'yfinance',\n                'timestamp': datetime.now().isoformat(),\n                'cache_age': 0,\n                'quality_indicator': 'üî¥ DELAYED',\n                'quality_color': 'red'\n            }\n    except Exception as e:\n        st.error(f\"Error fetching data for {symbol}: {str(e)}\")\n    return None\n\ndef create_mini_chart(data, title, width=300, height=200):\n    \"\"\"Create a mini chart for finviz-style display\"\"\"\n    if not data or data['history'].empty:\n        return None\n    \n    hist = data['history']\n    change_color = 'green' if data['change'] >= 0 else 'red'\n    \n    fig = go.Figure()\n    \n    # Add price line\n    fig.add_trace(go.Scatter(\n        x=hist.index,\n        y=hist['Close'],\n        mode='lines',\n        name='Price',\n        line=dict(color=change_color, width=2),\n        hovertemplate='<b>%{y:.2f}</b><br>%{x}<extra></extra>'\n    ))\n    \n    # Update layout for compact display\n    fig.update_layout(\n        title=dict(\n            text=f\"{title}<br><span style='color:{change_color}'>${data['current_price']:.2f} ({data['change']:+.2f}, {data['change_percent']:+.2f}%)</span>\",\n            font=dict(size=12, color='white'),\n            x=0.5\n        ),\n        template=\"plotly_dark\",\n        width=width,\n        height=height,\n        margin=dict(l=30, r=30, t=60, b=30),\n        showlegend=False,\n        xaxis=dict(\n            showgrid=False,\n            showticklabels=False,\n            zeroline=False\n        ),\n        yaxis=dict(\n            showgrid=True,\n            gridcolor='rgba(128,128,128,0.2)',\n            showticklabels=True,\n            zeroline=False,\n            tickformat='.2f'\n        ),\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        hovermode='x'\n    )\n    \n    return fig\n\ndef get_market_status():\n    \"\"\"Get current market status\"\"\"\n    now = datetime.now()\n    \n    # Simplified market hours (US Eastern Time approximation)\n    if now.weekday() < 5:  # Monday to Friday\n        if 9 <= now.hour < 16:\n            return \"üü¢ Market Open\"\n        elif 16 <= now.hour < 20 or 4 <= now.hour < 9:\n            return \"üü° Extended Hours\"\n        else:\n            return \"üî¥ Market Closed\"\n    else:\n        return \"üî¥ Market Closed (Weekend)\"\n\ndef display_category_section(category_name, contracts, period, favorites, show_category):\n    \"\"\"Display a category section with futures charts\"\"\"\n    \n    with st.expander(f\"üìä {category_name}\", expanded=show_category):\n        if show_category:\n            # Create grid layout - 3 charts per row for optimal viewing\n            charts_per_row = 3\n            contract_items = list(contracts.items())\n            \n            for i in range(0, len(contract_items), charts_per_row):\n                cols = st.columns(charts_per_row)\n                \n                for j, col in enumerate(cols):\n                    if i + j < len(contract_items):\n                        contract_name, contract_info = contract_items[i + j]\n                        \n                        with col:\n                            # Get data for this contract\n                            data = get_futures_data(\n                                contract_info['symbol'], \n                                contract_info['fallback'], \n                                period\n                            )\n                            \n                            if data:\n                                # Create mini chart\n                                chart = create_mini_chart(data, contract_name)\n                                \n                                if chart:\n                                    st.plotly_chart(chart, use_container_width=True, key=f\"chart_{category_name}_{contract_name}\")\n                                    \n                                    # Add to favorites button\n                                    is_favorite = contract_info['symbol'] in favorites\n                                    fav_text = \"‚≠ê Remove from Favorites\" if is_favorite else \"‚òÜ Add to Favorites\"\n                                    \n                                    if st.button(fav_text, key=f\"fav_{category_name}_{contract_name}\"):\n                                        if is_favorite:\n                                            favorites.remove(contract_info['symbol'])\n                                        else:\n                                            favorites.append(contract_info['symbol'])\n                                        \n                                        # Save to user preferences\n                                        user_auth.auto_save_preference('futures', 'favorites', favorites)\n                                        st.rerun()\n                            else:\n                                st.error(f\"Unable to load data for {contract_name}\")\n\ndef get_market_movers(period=\"1d\"):\n    \"\"\"Get biggest movers in futures markets\"\"\"\n    movers_data = []\n    \n    # Collect data from all contracts\n    for category, contracts in FUTURES_CONTRACTS.items():\n        for contract_name, contract_info in contracts.items():\n            data = get_futures_data(contract_info['symbol'], contract_info['fallback'], period)\n            if data:\n                movers_data.append({\n                    'Contract': contract_name,\n                    'Category': category,\n                    'Price': data['current_price'],\n                    'Change': data['change'],\n                    'Change %': data['change_percent'],\n                    'Volume': data['volume']\n                })\n    \n    if movers_data:\n        df = pd.DataFrame(movers_data)\n        \n        # Sort by absolute percentage change for biggest movers\n        df['Abs_Change'] = abs(df['Change %'])\n        biggest_movers = df.nlargest(10, 'Abs_Change')\n        \n        # Top gainers and losers\n        gainers = df.nlargest(5, 'Change %')\n        losers = df.nsmallest(5, 'Change %')\n        \n        # Volume leaders\n        volume_leaders = df.nlargest(5, 'Volume')\n        \n        return {\n            'biggest_movers': biggest_movers,\n            'gainers': gainers,\n            'losers': losers,\n            'volume_leaders': volume_leaders\n        }\n    \n    return None\n\ndef display_market_summary():\n    \"\"\"Display market summary section\"\"\"\n    st.subheader(\"üìà Market Summary\")\n    \n    movers = get_market_movers()\n    \n    if movers:\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.markdown(\"**üöÄ Top Gainers**\")\n            for _, row in movers['gainers'].head(3).iterrows():\n                color = \"green\" if row['Change %'] > 0 else \"red\"\n                st.markdown(f\"<span style='color:{color}'>{row['Contract']}: {row['Change %']:+.2f}%</span>\", \n                           unsafe_allow_html=True)\n        \n        with col2:\n            st.markdown(\"**üìâ Top Losers**\")\n            for _, row in movers['losers'].head(3).iterrows():\n                color = \"green\" if row['Change %'] > 0 else \"red\"\n                st.markdown(f\"<span style='color:{color}'>{row['Contract']}: {row['Change %']:+.2f}%</span>\", \n                           unsafe_allow_html=True)\n        \n        with col3:\n            st.markdown(\"**üìä Biggest Movers**\")\n            for _, row in movers['biggest_movers'].head(3).iterrows():\n                color = \"green\" if row['Change %'] > 0 else \"red\"\n                st.markdown(f\"<span style='color:{color}'>{row['Contract']}: {abs(row['Change %']):.2f}%</span>\", \n                           unsafe_allow_html=True)\n        \n        with col4:\n            st.markdown(\"**üîä Volume Leaders**\")\n            for _, row in movers['volume_leaders'].head(3).iterrows():\n                if row['Volume'] > 0:\n                    st.markdown(f\"{row['Contract']}: {utils.format_volume(row['Volume'])}\")\n\ndef display_favorites_section(favorites, period):\n    \"\"\"Display favorites section\"\"\"\n    if favorites:\n        st.subheader(\"‚≠ê My Favorites\")\n        \n        # Create grid for favorites\n        charts_per_row = 4\n        for i in range(0, len(favorites), charts_per_row):\n            cols = st.columns(charts_per_row)\n            \n            for j, col in enumerate(cols):\n                if i + j < len(favorites):\n                    favorite_symbol = favorites[i + j]\n                    \n                    # Find contract info\n                    contract_name = None\n                    contract_info = None\n                    \n                    for category, contracts in FUTURES_CONTRACTS.items():\n                        for name, info in contracts.items():\n                            if info['symbol'] == favorite_symbol:\n                                contract_name = name\n                                contract_info = info\n                                break\n                        if contract_name:\n                            break\n                    \n                    if contract_info:\n                        with col:\n                            data = get_futures_data(\n                                contract_info['symbol'], \n                                contract_info['fallback'], \n                                period\n                            )\n                            \n                            if data:\n                                chart = create_mini_chart(data, contract_name)\n                                if chart:\n                                    st.plotly_chart(chart, use_container_width=True, key=f\"fav_chart_{favorite_symbol}\")\n\ndef display_futures_overview():\n    \"\"\"Main display function for futures overview\"\"\"\n    \n    # Header with market status\n    col1, col2 = st.columns([3, 1])\n    with col1:\n        st.header(\"üîÆ Futures Overview\")\n    with col2:\n        st.info(get_market_status())\n    \n    # Get user preferences\n    favorites = user_auth.get_user_preference('futures', 'favorites', [])\n    expanded_categories = user_auth.get_user_preference('futures', 'expanded_categories', \n                                                       {cat: True for cat in FUTURES_CONTRACTS.keys()})\n    default_period = user_auth.get_user_preference('futures', 'default_period', '1d')\n    \n    # Controls\n    col1, col2, col3 = st.columns([2, 1, 1])\n    \n    with col1:\n        st.markdown(\"**üìä Finviz-Style Futures Dashboard**\")\n        st.markdown(\"*Real-time futures data with Canadian and American market coverage*\")\n    \n    with col2:\n        period = st.selectbox(\n            \"Time Period\", \n            [\"1d\", \"5d\", \"1mo\"], \n            index=[\"1d\", \"5d\", \"1mo\"].index(default_period),\n            key=\"futures_period\"\n        )\n        # Save preference\n        user_auth.auto_save_preference('futures', 'default_period', period)\n    \n    with col3:\n        if st.button(\"üîÑ Refresh Data\"):\n            st.cache_data.clear()\n            st.rerun()\n    \n    # Display favorites first if any\n    if favorites:\n        display_favorites_section(favorites, period)\n        st.markdown(\"---\")\n    \n    # Market summary\n    display_market_summary()\n    st.markdown(\"---\")\n    \n    # Category selection\n    st.subheader(\"üìã Category Settings\")\n    category_cols = st.columns(len(FUTURES_CONTRACTS))\n    \n    for i, category in enumerate(FUTURES_CONTRACTS.keys()):\n        with category_cols[i]:\n            show_category = st.checkbox(\n                f\"Show {category}\", \n                value=expanded_categories.get(category, True),\n                key=f\"show_{category}\"\n            )\n            expanded_categories[category] = show_category\n    \n    # Save category preferences\n    user_auth.auto_save_preference('futures', 'expanded_categories', expanded_categories)\n    \n    st.markdown(\"---\")\n    \n    # Display each category\n    for category_name, contracts in FUTURES_CONTRACTS.items():\n        if expanded_categories.get(category_name, True):\n            display_category_section(category_name, contracts, period, favorites, True)\n    \n    # Footer with disclaimers\n    st.markdown(\"---\")\n    st.markdown(\"\"\"\n    **üìä Data Sources & Notes:**\n    - Primary: Yahoo Finance futures data\n    - Fallback: Related ETFs when futures data unavailable\n    - Updates: Real-time with 1-minute cache\n    - Coverage: US, Canadian, Energy, Metals, Agriculture, Currency futures\n    \n    **‚ö†Ô∏è Disclaimer:** For educational purposes only. Not financial advice.\n    \"\"\")","size_bytes":19088}},"version":1}